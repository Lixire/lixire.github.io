<!--
1: Using prettify
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CS 246</title>

<link rel="stylesheet" type="text/css" href="https://www.dropbox.com/s/atz4kqwayz4hlhk/markDown.css?raw=1">

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>

</head>
<body><h1 id="cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</h1>

<blockquote>
  <p>Brad Lushman <br>
  Office: DC 3110 <br>
  Email: bmlushma <br>
  <a href="http://www.student.cs.uwaterloo.ca/~cs246">http://www.student.cs.uwaterloo.ca/~cs246</a> <br>
  Linux is required! Ripperino</p>
</blockquote>

<p><div class="toc">
<ul>
<li><a href="#cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</a><ul>
<li><a href="#lecture-1">Lecture 1</a><ul>
<li><a href="#linux-please">Linux, Please</a></li>
<li><a href="#module-1-linux-shell">Module 1 - Linux Shell</a></li>
<li><a href="#linux-file-system">Linux File System</a></li>
<li><a href="#pipes">Pipes</a></li>
</ul>
</li>
<li><a href="#lecture-2">Lecture 2</a><ul>
<li><a href="#pipes-cont">Pipes Cont.</a></li>
<li><a href="#pattern-matching-in-text-files">Pattern-Matching in Text Files</a></li>
<li><a href="#permissions">Permissions</a></li>
</ul>
</li>
<li><a href="#lecture-3">Lecture 3</a><ul>
<li><a href="#shell-scripts">Shell Scripts</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#loops">Loops</a></li>
</ul>
</li>
<li><a href="#lecture-4">Lecture - 4</a><ul>
<li><a href="#se-topic-testing">SE Topic: Testing</a></li>
<li><a href="#module-2-c">Module 2: C++</a></li>
<li><a href="#compiling-c-programs">Compiling C++ programs</a></li>
<li><a href="#inputoutput">Input/Output</a></li>
</ul>
</li>
<li><a href="#lecture-5">Lecture 5</a><ul>
<li><a href="#reading-strings">Reading Strings</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#string-operations">String Operations:</a></li>
<li><a href="#default-fn-params">Default f’n Params</a></li>
<li><a href="#overloading">Overloading</a></li>
</ul>
</li>
<li><a href="#lecture-6">Lecture 6</a><ul>
<li><a href="#structs">Structs</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#parameter-passing">Parameter Passing</a></li>
<li><a href="#references">References</a></li>
<li><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
</ul>
</li>
<li><a href="#lecture-7">Lecture 7</a><ul>
<li><a href="#operator-overloading">Operator Overloading</a></li>
<li><a href="#overloading-and">Overloading &lt;&lt; and &gt;&gt;</a></li>
<li><a href="#the-preprocessor">The Preprocessor</a></li>
<li><a href="#separate-compilation">Separate Compilation</a></li>
<li><a href="#compiling-separately">Compiling Separately</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</a><ul>
<li><a href="#lecture-8">Lecture 8</a><ul>
<li><a href="#classes">Classes</a></li>
</ul>
</li>
<li><a href="#lecture-9">Lecture 9</a><ul>
<li><a href="#uniform-initialization">Uniform Initialization</a></li>
<li><a href="#destructors">Destructors</a></li>
<li><a href="#copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</a></li>
</ul>
</li>
<li><a href="#lecture-10">Lecture 10</a><ul>
<li><a href="#rvalues-rvalue-references">Rvalues + Rvalue References</a></li>
<li><a href="#copymove-elision">Copy/Move Elision</a></li>
</ul>
</li>
<li><a href="#lecture-10-1">Lecture - 10</a><ul>
<li><a href="#separate-compilation-for-classes">Separate Compilation for Classes</a></li>
<li><a href="#arrays-of-objects">Arrays of Objects</a></li>
<li><a href="#const-objects">Const Objects</a></li>
<li><a href="#static-fields-methods">Static Fields + Methods</a></li>
<li><a href="#static-member-functions">Static Member Functions</a></li>
<li><a href="#invariants-encapsulation">Invariants + Encapsulation</a></li>
</ul>
</li>
<li><a href="#cs-246-tut-5">CS 246 TUT 5</a></li>
<li><a href="#lecture-12">Lecture 12</a><ul>
<li><a href="#se-topic-design-patterns">SE Topic: Design Patterns</a></li>
<li><a href="#tools-topic-make">Tools topic: make</a></li>
</ul>
</li>
<li><a href="#lecture-13">Lecture 13</a><ul>
<li><a href="#makefile">Makefile</a></li>
<li><a href="#system-modelling">System Modelling</a></li>
<li><a href="#aggegation">Aggegation</a></li>
<li><a href="#inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</a></li>
</ul>
</li>
<li><a href="#lecture-14">Lecture 14</a><ul>
<li><a href="#destructor-revisited">Destructor Revisited</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>



<h2 id="lecture-1">Lecture 1</h2>



<h3 id="linux-please">Linux, Please</h3>

<blockquote>
  <p>Options: <br>
  1. Lab, computers <br>
  2. Install Linux on your machine <br>
  3. ssh into school machines (recommended) (Windows: download putty.exe, winscp for file transfer) <br>
  4. Cygwin - ewwwwwww <br>
  Also - install an xwindows server. eg. XMing</p>
</blockquote>

<p>Modules:  <br>
1 - Linux Shell (2 weeks) <br>
2 - C++ (10 weeks) <br>
3 - Tools (interspersed) <br>
4 - Software engineering (interspersed)</p>

<p>Homework: Print Linux handout from Piazza, and bring it to class</p>



<h3 id="module-1-linux-shell">Module 1 - Linux Shell</h3>

<blockquote>
  <p>Shell - interface to OS - get the OS to do things - run programs, manage files - graphical shell (clicking with mouse/ touch interface) - command line - type commands at a prompt - more versatile</p>
</blockquote>

<p>This course: bash</p>

<p>Make sure you are using bash! - Log in + type echo $0 <br>
- should say bash</p>



<h3 id="linux-file-system">Linux File System</h3>

<p>Working with files <br>
- cat - displays the contents of a file <br>
- cat /usr/share/dict/words <br>
- general format: root (top) directory/ directories (contains files)/ file</p>

<blockquote>
  <p>In Linux, a directory is considered a kind of file</p>
</blockquote>

<p><code>^C</code> to stop a program <br>
ls : list files in current dir (non-hidden files) <br>
ls -a : gives all files (even hidden ones) <br>
hidden files start with a dot <br>
pwd - prints current directory</p>

<p>What happens if you type cat? <br>
- waits for input <br>
- prints everything you type <br>
Useful? - if we can capture input in file. <br>
Observe: </p>

<p><code>cat &gt; output.txt</code></p>

<p>To stop: Ctrl - D (^D) at the beginning of a line sends an end of file signal <br>
In general: command args &gt; file ; executes command args + captures the output in file <br>
- called <strong><em>output redirection</em></strong></p>

<p>Can also redirect input:</p>

<p><code>cat &lt; inputfile.txt</code></p>

<ul>
<li>takes input from inputfile.txt instead of keyboard</li>
<li>displays inputfile.txt</li>
<li>seems equal to cat inputfile.txt</li>
</ul>

<p>What’s the difference?</p>

<p><code>cat inputfile.txt</code></p>

<p>passes the name <code>inputfile.txt</code> as an arg to cat. cat opens the file and displays it</p>

<p><code>cat &lt; inputfile.txt</code></p>

<p>SHELL opens <code>inputfile.txt</code> and passes the contents to cat in place of keyboard or input</p>

<p>Observe:</p>



<pre class="prettyprint"><code class=" hljs avrasm">wc output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span> output<span class="hljs-preprocessor">.txt</span>

wc &lt; output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span></code></pre>

<p>Also: <code>cat *.txt</code> &lt;- globbing pattern <br>
(* means match any sequence of chars) <br>
- shell finds all files in the current dir that matches the pattern + substitutes on the cmd line.  <br>
(eg. <code>cat a.txt, b.txt, c.txt</code> - opens all 3 and displays)</p>

<p>More globbing patterns - Linux Sheet <br>
Many, but not all programs accept input either on the command line or by redirection</p>

<p>Can do both redirections <br>
<code>cat &lt; in.txt &gt; out.txt</code></p>

<p>Every process is attached to 3 streams: stdin, stderr, stdout</p>

<dl>
<dt>By default</dt>
<dd>stdin = keyboard - redirect with &lt;</dd>

<dd>stdout, stderr = screen (redirect with &gt;)</dd>

<dt>stderr</dt>
<dd>separate output stream - for error messages</dd>

<dd>so that output + error messages can go to different places</dd>

<dd>so that error msgs don’t clutter output file + corrupt formatting <br>
Also: stdout may be buffered - system may wait to accumulate output before actually printing it ( flushing the buffer)</dd>
</dl>

<p>stderr - never buffered - get errror msgs immediately</p>



<h3 id="pipes">Pipes</h3>

<p>Use output from one program as the input of another</p>

<blockquote>
  <p><strong>Example: How many words occur in the first 20 lines of myfile.txt?</strong> <br>
  Tools (sheet): <br>
  <code>head -n file</code> gives the first n lines of the file <br>
  <code>wc</code> counts words, lines, characters <br>
  <code>wc -w</code> gives just words <br>
  Soln: head -20 myfile.txt | wc -w <br>
  the | is a pipe</p>
</blockquote>



<h2 id="lecture-2">Lecture 2</h2>



<h3 id="pipes-cont">Pipes Cont.</h3>

<p>How many words occur in the first 20 lines of myfile.txt? <br>
Sol’n <code>head -20 myfile.txt | wc -w</code> or <code>cat myfile.txt | head -20 | wc -w</code></p>

<p>Eg. Suppose words1.txt, words2.txt, etc. contain lists of words, one per line. Print a duplicate-free list of all words that occur in any of these lines.</p>

<blockquote>
  <p><strong>uniq</strong> - removes CONSECUTIVE duplicate entries -if entries are sorted, then it removes <em>all</em> duplicates <br>
  <strong>sort</strong> - sorts lines</p>
</blockquote>

<p><code>cat words*.txt | sort | uniq</code></p>

<p>Can we use the output of one program as param of another? (yes)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> <span class="hljs-string">"Today is <span class="hljs-variable">$(date)</span> and I am <span class="hljs-variable">$(whoami)</span>"</span>
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Shell executes date + whoami + substitues the result into the command line <br>
The quotations make it into only ONE arg. Also, whitespace here is used.</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> Today is $(date) and I am           $(whoami)
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Here, echo is given 7 arguments. Whitespace is ignored</p>

<blockquote>
  <p>Careful: </p>
  
  <pre class="prettyprint"><code class=" hljs applescript">echo 'Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)'
&gt; Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)</code></pre>
  
  <p>Single quotes does not make any substitutions.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs delphi">echo *
echo <span class="hljs-string">'*'</span> #outputs the same <span class="hljs-comment">(*)
echo "*" #outputs the same (*)</span></code></pre>



<h3 id="pattern-matching-in-text-files">Pattern-Matching in Text Files</h3>

<dl>
<dt>egrep (“extended global regular expression print”)</dt>
<dd>egrep pattern file - prints every line in a file that contains a match to pattern</dd>
</dl>

<p>eg. Print every line in index.html that contains cs246.</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep cs246 index.html</code></pre>

<p>How many lines in index.html contain cs246 or CS246?</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"cs246|CS246"</span> index.html | wc <span class="hljs-operator">-l</span> //the quotes are really important here since bash thinks | is a pipe otherwise</code></pre>

<p>Alt soln:</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"(cs|CS)246"</span> index.html | wc <span class="hljs-operator">-l</span></code></pre>

<p>Available patterns - called regular expressions (different from globbing patterns)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-string">"(c|C)(s|S)246"</span> -also matches cS246, Cs246
<span class="hljs-string">"[cC][sS]246"</span></code></pre>

<p>[..] - any one char between [ and ] <br>
[<script type="math/tex" id="MathJax-Element-316">\text{^}</script> .. ] - any one char except</p>

<p>Add optional space:  <code>"[cC][sS] ?246"</code> <br>
? = 0 or 1 of the preceding expression (0 or 1 space in this case) <br>
* = 0 or more of preceding </p>



<pre class="prettyprint"><code class=" hljs r"><span class="hljs-string">"(cs)*246"</span>
&gt; <span class="hljs-number">246</span>, cs246, cscs246 <span class="hljs-keyword">...</span></code></pre>

<p>. = any single character <br>
.* = anything</p>



<pre class="prettyprint"><code class=" hljs perl">egrep <span class="hljs-string">"cs.<span class="hljs-variable">*246</span>"</span> <span class="hljs-keyword">index</span>.html</code></pre>

<ul>
<li>lines containing cs(anything) 246</li>
<li>^, $ - beginning + end of a line <br>
<code>"^cs246"</code> - lines that start with 246 <br>
<code>"^cs246$"</code> - lines that are exactly 246 <br>
+ = 1 or more occurrences of preceding pattern <br>
.+ - non-empty.</li>
</ul>

<p>Eg lines of even length</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-string">"^(..)*$"</span></code></pre>

<p>Files in the current dir whose names contain exactly one a.</p>



<pre class="prettyprint"><code class=" hljs 1c">ls <span class="hljs-string">| egrep "</span>[^a]*a[^a]*<span class="hljs-string">"</span></code></pre>

<p>All words in the global dictionary that start with e and have 5 characters</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">egrep <span class="hljs-string">"^e....$"</span> /usr/share/dict/<span class="hljs-keyword">words</span></code></pre>



<h3 id="permissions">Permissions</h3>

<p><code>ls - l</code> - “long form” listening</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-attribute">-rw</span><span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span> <span class="hljs-number">1</span> j2smith j2smith <span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span> abc<span class="hljs-built_in">.</span>txt
(<span class="hljs-subst">-</span>)<span class="hljs-keyword">type</span><span class="hljs-subst">|</span>(rw<span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span>)permissions<span class="hljs-subst">|</span>(<span class="hljs-number">1</span>)<span class="hljs-variable">#of</span> links<span class="hljs-subst">|</span> (j2smith) owner<span class="hljs-subst">|</span> (j2smith) <span class="hljs-keyword">group</span><span class="hljs-subst">|</span> (<span class="hljs-number">25</span>) size <span class="hljs-subst">|</span> (<span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>) last modified <span class="hljs-subst">|</span> (abc<span class="hljs-built_in">.</span>txt) name</code></pre>

<dl>
<dt>groups</dt>
<dd>a user can belong to one or more groups</dd>

<dd>a file can be associated with one group</dd>

<dt>type</dt>
<dd><code>-</code> an ordinary file</dd>

<dd><code>d</code> directory</dd>

<dt>permissions</dt>
<dd><code>rwxrwxrwx</code> -&gt; 1st rwx bits are “user bits”, then next 3 are “group bits”, last is “other bits” <br>
<strong>Apply to:</strong> <br>
- user bits: file’s owner <br>
- group bits: members of the file’s group other than the owner <br>
- other bits: everyone else <br>
<code>r</code> - read bit <br>
<code>w</code> - write bit <br>
<code>x</code> - execute bit</dd>
</dl>

<table>
<thead>
<tr>
  <th>Bit</th>
  <th>Meaning for Ordinary Files</th>
  <th>Meaning for directories</th>
</tr>
</thead>
<tbody><tr>
  <td>r</td>
  <td><code>files contents can be read</code></td>
  <td><code>directory's contents can be read (eg. ls works, globbing, tab completion)</code></td>
</tr>
<tr>
  <td>w</td>
  <td><code>files contents can be modified</code></td>
  <td><code>directory's contents can be modified</code></td>
</tr>
<tr>
  <td>x</td>
  <td><code>file can be executed as a program</code></td>
  <td><code>directory can be navigated (i.e. can cd into the dir)</code></td>
</tr>
</tbody></table>


<blockquote>
  <p>dir’s exec. bit not set = no access at all to the dir, nor to any subdir, nor to any file within it. <br>
  Changing permissions: <code>chmod mode file</code></p>
</blockquote>

<p>Mode:</p>

<table>
<thead>
<tr>
  <th></th>
  <th></th>
  <th></th>
</tr>
</thead>
<tbody><tr>
  <td>u - user</td>
  <td><ul>
add perm
</ul></td>
  <td>r read</td>
</tr>
<tr>
  <td>g - group</td>
  <td><ul>
remove perm
</ul></td>
  <td>w write</td>
</tr>
<tr>
  <td>o - other</td>
  <td>= set perm</td>
  <td>x execute</td>
</tr>
<tr>
  <td>a- all</td>
  <td></td>
  <td></td>
</tr>
</tbody></table>


<p>eg.  <br>
give others read permission: chmod o+r file  <br>
make everyone’s permission rx: a = rx <br>
give owner full control: u = rwx or u+rwx</p>

<blockquote>
  <p>Changing permissions - &gt; exclusive right of the owner</p>
</blockquote>



<h2 id="lecture-3">Lecture 3</h2>



<h3 id="shell-scripts">Shell Scripts</h3>

<blockquote>
  <p>files containing sequences of shell commands, executed as programs</p>
</blockquote>

<p>eg. Print date, current user, current dir</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-comment">#!/bin/bash //"shebang" line - executes this file as a bash script</span>
date
whoami
<span class="hljs-built_in">pwd</span></code></pre>

<blockquote>
  <p>Note: the script does not have the execute bit turned on. Give the file execute permission: <code>chmod u+x myscript</code> <br>
  Run the file: <code>./myscript</code></p>
</blockquote>



<h3 id="variables">Variables</h3>

<p><code>x=1</code> (NO spaces)</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
&gt; <span class="hljs-number">1</span></code></pre>

<blockquote>
  <p>Note: use <script type="math/tex" id="MathJax-Element-317"> when fetching the value of a var  
  No </script> when setting a var. <br>
  Good practice: <script type="math/tex" id="MathJax-Element-318">{x}  
  All vars contain STRINGS. x is the string 1  
  Eg. dir=~cs246  
  echo </script>{dir}</p>
</blockquote>

<p>Some “global” vars available: <br>
Important: PATH - list of dirs; When you type a command, the shell searches these directories in order for a program with that name</p>

<blockquote>
  <p>Eg. Check whether a word is in the directory <br>
  eg. <code>./isItAWord hello</code></p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/shar/dict/words</code></pre>

<blockquote>
  <p>Prints nothing if word not found <br>
  Prints the word if found</p>
</blockquote>

<p>Eg. - a good password should not be in the dictionary <br>
answer whether a word is a good password</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/share/dict/words &gt; /dev/null //(suppresses output)
<span class="hljs-keyword">if</span> [ $? <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> ]; <span class="hljs-keyword">then</span> //the ; here allows you to put the <span class="hljs-keyword">then</span> on the same line
    <span class="hljs-built_in">echo</span> Bad password
<span class="hljs-keyword">else</span> 
    <span class="hljs-built_in">echo</span> Maybe a good password
<span class="hljs-keyword">fi</span> //ends the <span class="hljs-keyword">if</span>?</code></pre>

<p>Note: every program returns a status code when finished <br>
egrep: returns 0 if found, 1 if not found (In Linux: 0 is success, non-0 is fail)</p>

<p>$? = status of the most recently executed command</p>

<p>Verify # of args ; print error msg if wrong</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">usage</span></span>(){
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> password"</span> &gt;&amp;<span class="hljs-number">2</span>
}
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> <span class="hljs-operator">-ne</span> <span class="hljs-number">1</span>]; <span class="hljs-keyword">then</span>
    usage
    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">fi</span>
...(as before)</code></pre>



<pre class="prettyprint"><code class=" hljs r">If stmt: //comparisons + other conditions handout
    <span class="hljs-keyword">if</span> [ cond ]; then
        <span class="hljs-keyword">...</span>
    elif [ cond ]; then
        <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">...</span>
fi</code></pre>



<h3 id="loops">Loops</h3>

<p>Print #’s from 1 to $1</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
x=<span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> [ <span class="hljs-variable">$x</span> -le <span class="hljs-variable">$1</span>]; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
    x=<span class="hljs-variable">$x</span>+<span class="hljs-number">1</span>
<span class="hljs-keyword">done</span></code></pre>

<p>This gives you “1+1” literally if x=1 <br>
you want $((…)) for arithmetic instead</p>

<p>Looping over a list <br>
eg. Rename all .cpp files to .cc</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *.cpp; <span class="hljs-keyword">do</span>
    mv <span class="hljs-variable">${name}</span> <span class="hljs-variable">${name%cpp}</span>cc
<span class="hljs-keyword">done</span></code></pre>

<blockquote>
  <p>note: <br>
  *.cpp -&gt; glob - replaced with all matching files  <br>
  name%cpp is the val of name, without the trailing cpp.</p>
</blockquote>

<p>How many times does word <script type="math/tex" id="MathJax-Element-319">1 appear in file </script>2?</p>



<pre class="prettyprint"><code class=" hljs bash">x=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$2</span>); <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span> = <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]; <span class="hljs-keyword">then</span>
        x=$((x+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span></code></pre>

<blockquote>
  <p>Payday is the last Friday of the month. When is this month’s payday? <br>
  2 tasks: Compute date <br>
               Report answer</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">answer</span></span>(){
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month is the 31st"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month: the <span class="hljs-variable">${1}</span>th"</span>
}<span class="hljs-keyword">fi</span>
answer $(cal | awk <span class="hljs-string">'{print $6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<p>Generalize to any month. <code>cal October 2016</code> -gives Oct’s calendar <br>
let payday October 2016 give october’s payday</p>

<p>ALL OF THESE ARE IN THE REPO</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-function"><span class="hljs-title">answer</span></span>(){
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$2</span> ]; <span class="hljs-keyword">then</span>
        preamble=<span class="hljs-variable">$2</span>
    <span class="hljs-keyword">else</span>
        preamble = <span class="hljs-string">"This month"</span>
    <span class="hljs-keyword">fi</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble}</span>: the 31st"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble: the ${1}</span>th}"</span>
    <span class="hljs-keyword">fi</span>
}
answer $(cal <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> | awk <span class="hljs-string">'{print #6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<blockquote>
  <p>note: no such thing as scope. You can reference from anywhere. if the var doesn’t exist, you get a blank.</p>
</blockquote>



<h2 id="lecture-4">Lecture - 4</h2>



<h3 id="se-topic-testing">SE Topic: Testing</h3>

<ul>
<li>essential part of program development</li>
<li>on going  <br>
<ul><li>not just at the end</li>
<li>Begins <strong>before</strong> you start coding</li>
<li>Test suites - expected behaviour <br>
<script type="math/tex" id="MathJax-Element-320">\neq</script> debugging - cannot debug without first testing</li></ul></li>
<li>cannot guarantee correctness - cannot prove wrongness</li>
<li>ideally, developer + tester should be different people</li>
</ul>

<p>Human testing </p>

<ul>
<li>humans look over code, find flaws</li>
<li>code inspections, walk throughs</li>
<li>not on your assignments</li>
</ul>

<p>Machine testing</p>

<ul>
<li>run program on selected input, check against spec</li>
<li>can’t check everything <br>
<ul><li>choose test cases carefully</li></ul></li>
</ul>

<p>Black/White/Grey Box Testing</p>

<ul>
<li>no/full/some knowledge of implementation</li>
</ul>

<p>Start with black box, supplement with white box</p>

<p>Black box:</p>

<ul>
<li>various classes of input <br>
<ul><li>numeric ranges</li>
<li>positive vs. negative</li></ul></li>
<li>boundaries of valid ranges (edge cases)</li>
<li>multiple simultaneous boundaries (corner cases)</li>
<li>intuition/experience - guess at likely errors</li>
<li>extreme cases</li>
</ul>

<p>White box:</p>

<ul>
<li>execute all logical paths through the program</li>
<li>make sure every f’n runs</li>
</ul>

<p>Performance testing - is the program efficient enough? <br>
Regression testing</p>

<ul>
<li>make sure new changes to program don’t break old test caes</li>
<li>test suites, testing scripts</li>
</ul>



<h3 id="module-2-c">Module 2: C++</h3>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">//Hello world in C:</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Hello world in C++:</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hello world"</span> &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>Notes: main <strong>must</strong> return int in C++ (if no return in main, 0 is implied)</p>
</blockquote>

<ul>
<li><code>stdio.h</code> , <code>printf</code> still available in c++</li>
<li>preferred C++ <code>I/O</code> header <code>&lt;iostream&gt;</code></li>
</ul>

<p>Output: <br>
std::cout &lt;&lt; ___ &lt;&lt; ___ &lt;&lt; ___ (___ is data) <br>
std::endl = end of line</p>

<ul>
<li>using namespace std: <br>
<ul><li>lets you say cout/endl instead of std::cout/std::endl</li></ul></li>
</ul>



<h3 id="compiling-c-programs">Compiling C++ programs</h3>

<p><code>g++-5 -std=c++14 program.cc &lt;-o program&gt; (name of the excutable(by default, a.out))</code></p>

<p>OR</p>

<p><code>g++14 program.cc -o program</code> <br>
<code>./program</code></p>



<h3 id="inputoutput">Input/Output</h3>

<p>3 I/O streams: </p>

<ul>
<li>cin - for reading from stdin</li>
<li>cout, cerr - for printing to stdout, stderr</li>
</ul>

<p>I/O operators:</p>

<ul>
<li>&lt;&lt; “put to” (output)</li>
<li>&gt;&gt; “get from” (input)</li>
<li>cerr &lt;&lt; x;</li>
<li>cin &gt;&gt; x; <br>


<blockquote>
  <p>operator points in the direction of information flow</p></blockquote></li>
  </ul> <br>
  E.g. Add 2#’s







<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> nanospace <span class="hljs-built_in">std</span>
<span class="hljs-comment">//above two lines are usually there even if teach doesn't write it (omit from now on)</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;
    <span class="hljs-built_in">cout</span> &lt;&lt; x + y &lt;&lt; endl;
}</code></pre>




<blockquote>
  <p>notes: <code>cin &gt;&gt; ignores whitespace</code> <br>
  what if input doesn’t contain an int? -statement fails, value of var is undefined</p>
</blockquote>

What if the input is exhausted before we get two ints?

<ul>
<li>same as before</li>
</ul>

<hr>

<p>If the read failed: <code>cin.fail()</code> will be true <br>
If EOF: <code>cin.eof()</code> and <code>cin.fail()</code> will both be true</p>

<ul>
<li>but not until attempted read fails</li>
</ul>

<p>Ex: read all ints from stdin, echo them and per line to std out. Stop on any failure.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &gt;&gt; i;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.fail()) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: Here is an implicit conversion from cin to bool</p>
  
  <ul>
  <li>cin can be used as a condition - true if success, false if failed</li>
  </ul>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v2.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &lt;&lt; i;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cin</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: &gt;&gt; is c’s right bitshift operator. <code>a &gt;&gt; b</code> shifts  a’s bits to the right by b spots. <br>
  E.g. 21 &gt;&gt; 3 -&gt; 21 = 10101 shifted 3 =<script type="math/tex" id="MathJax-Element-321">10_{\text(binary)}</script> = 2 <br>
  But when LHS is cin, &gt;&gt; is “get from”</p>
</blockquote>

<p>operator &gt;&gt;: </p>

<ul>
<li>inputs: cin (stream), data (variety of types)</li>
<li>output? - returns cin (istream)</li>
</ul>

<p>This is why we can write <code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</code> the &gt;&gt; returns cin as each &gt;&gt; is calculated, which allows y and z to also be read in.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v3.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v4.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; i){
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<h2 id="lecture-5">Lecture 5</h2>

<p>Ex: Read ints + echo to stdout until EOF. Skip all non-int input</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)){
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.eof()) <span class="hljs-keyword">break</span>;
            <span class="hljs-built_in">cin</span>.clear(); <span class="hljs-comment">//clears the fail bit</span>
            <span class="hljs-built_in">cin</span>.ignore(); <span class="hljs-comment">//skips the next char (because the char causing this to fail is still there)</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt;i &lt;&lt; endl;
    }
}</code></pre>



<h3 id="reading-strings">Reading Strings</h3>

<p><code>type std::string (#include &lt;string&gt;)</code></p>

<ul>
<li>more details later</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s; <span class="hljs-comment">//skip leading whitespace (stop at whitespace)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">//(therefore only reads one word)</span>
}</code></pre>

<p>If we want the whitespace: <code>getline(cin, s);</code></p>

<ul>
<li>reads from current position to next newline into s.</li>
</ul>

<p><code>cout &lt;&lt; 95 &lt;&lt; endl;</code></p>

<p>What if we want to print a # in hexadecimal?</p>

<p><code>cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; endl; \\prints 5f</code></p>

<blockquote>
  <p>hex : I/O manipulator - all subsequent ints printed in hex</p>
</blockquote>

<p><code>cout &lt;&lt; dec</code> to go back to decimal</p>

<p>Other manipulators - notes <code>#include &lt;iomanip&gt;</code></p>

<p>Stream abstraction applies to other sources of data</p>

<p>Files </p>

<ul>
<li>Read from a file instead of stdin</li>
<li>std::ifstream - read from a file</li>
<li>std::ofstream - write to a file</li>
</ul>

<p>File access in C:</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">char</span> s[<span class="hljs-number">256</span>];
    FILE *file = fopen(<span class="hljs-string">"myfile.txt"</span>,<span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">"%255s"</span>, s);
        <span class="hljs-keyword">if</span>(feof(file)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    }
    fclose(file);
}</code></pre>

<p>C++:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    ifstream file{<span class="hljs-string">"myfile.txt"</span>}; <span class="hljs-comment">// Initialization syntax. Declaring an ifstream opens the file</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(file &gt;&gt; s){
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
    } <span class="hljs-comment">// file is closed automatically as soon as the ifstream (file) goes out of scope :o woah</span>
}</code></pre>

<blockquote>
  <p>note: This is the same as reading from cin in c++ except we use file in the while loop.</p>
</blockquote>

<p>Anything you can do with cin/cout, you can also do with an ifstream/ofstream.</p>

<p>Example - strings - attach a stream to a string var + read from/write to it</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include&lt;sstream&gt;</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span>
<span class="hljs-comment">//-read from/write to a string</span>
<span class="hljs-keyword">int</span> lo = _____, hi = _____;
<span class="hljs-built_in">ostringstream</span> ss;
ss &lt;&lt; <span class="hljs-string">"Enter a # btwn "</span> &lt;&lt; lo &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; hi;
<span class="hljs-built_in">string</span> s = ss.str();</code></pre>

<p>Eg - convert string to #</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter a # "</span> &lt;&lt;endl;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s;
    (<span class="hljs-built_in">string</span> stream ss {s}); <span class="hljs-comment">// {s} &lt;- initialization</span>
    <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"I said, "</span>;
}
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"You entered "</span> &lt;&lt; n &lt;&lt; endl;</code></pre>

<p>Example revisited: Echo #’s, skip non-#’s</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; s){
        <span class="hljs-built_in">istringstream</span> ss {s};
        <span class="hljs-keyword">int</span> n;
        <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
    }
}</code></pre>



<h3 id="strings">Strings</h3>

<p>In C: </p>

<ul>
<li>array of char (char* or char[]) terminated by ‘\0’</li>
<li>explicitly manage memory - allocate more as strings get larger</li>
<li>easy to overwrite \0 and corrupt memory</li>
</ul>

<p>C++ strings:</p>

<ul>
<li>grow as needed (no memory management)</li>
<li>safer to manipulate</li>
</ul>

<p>Eg: string s = “Hello”; // still a c-style string (char array with \0)</p>

<blockquote>
  <p>s  -  c++ string created from the c string on initialization</p>
</blockquote>



<h3 id="string-operations">String Operations:</h3>

<p>Equality - s1 == s2, s1 != s2 <br>
Comparison - s1 &lt;= s2 (lexicographic) <br>
Get individual chars - s[0] , s[1], … etc <br>
Concat: s3 = s1 + s2;   s3 += s4</p>



<h3 id="default-fn-params">Default f’n Params</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> printWordsInFile(<span class="hljs-built_in">string</span> name = <span class="hljs-string">"suite.txt"</span>){
    ifstream file {name};
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (file &gt;&gt; s) <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
}
printWordsInFile(<span class="hljs-string">"suite2.txt"</span>);
printWordsInFile(); <span class="hljs-comment">//uses stuite.txt</span></code></pre>

<blockquote>
  <p>Note: Optional parameters must be LAST</p>
</blockquote>



<h3 id="overloading">Overloading</h3>

<p>C:</p>

<ul>
<li><code>int negInt(int n) {return -n;}</code></li>
<li><code>bool negBool(bool b) {return !b;}</code></li>
</ul>

<p>C++</p>

<p>F’ns with different param lists can share the same name <br>
<code>int neg(int n) {return -n;}</code> <br>
<code>bool neg(bool b) {return !b;}</code></p>

<p>Compiler uses # + type of args to decide which neg is being called <br>
Overloads must differ in # or types of args - may not differ on just return type</p>



<h2 id="lecture-6">Lecture 6</h2>



<h3 id="structs">Structs</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node next; <span class="hljs-comment">//what's wrong? This makes the struct have no finite size since</span>
    <span class="hljs-comment">// this contains a node in a node in a node ... etc which has no calculable size</span>
};</code></pre>



<h3 id="constants">Constants</h3>

<p><code>const int maxGrade = 100; // must be initialized</code></p>

<p><code>Node n1 = {5, nullptr}; \\syntax for a null ptr. Do not say NULL or 0 in this class</code></p>

<p><code>const Node n2=n1</code></p>

<ul>
<li>immutable copy of n1</li>
<li>can’t change n2’s fields</li>
</ul>



<h3 id="parameter-passing">Parameter Passing</h3>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> n){++n;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 5</span></code></pre>

<p>call-by-value-inc gets a copy of x, increments the copy, original unchanged</p>

<p>If a function needs to modify an arg - pass a ptr</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc(<span class="hljs-keyword">int</span> *n){(*n)++;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(&amp;x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 6</span></code></pre>

<blockquote>
  <p>Q: why cin &gt;&gt; x and not cin &gt;&gt; &amp;x ? <br>
  A: C++ has another ptr-like type: references</p>
</blockquote>



<h3 id="references">References</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> &amp;z = y; <span class="hljs-comment">//z is an lvalue reference to y. Like a const ptr.</span>
<span class="hljs-comment">//similar to int *const z = &amp;y;</span></code></pre>

<p>References are like constant ptrs with automatic de-referencing  <br>
z -&gt; y [10]</p>



<pre class="prettyprint"><code class="language-cpp hljs ">z = <span class="hljs-number">12</span>; <span class="hljs-comment">//(NOT *z = 12)</span>
<span class="hljs-comment">//(now, y == 12)</span>

<span class="hljs-keyword">int</span> *p = &amp;z; <span class="hljs-comment">// gives the address of y</span></code></pre>

<p>In all cases, z behaves exactly like y.</p>

<p>z is an alias (“another name”) for y</p>

<p><strong>Things you can’t do with lvalue references:</strong></p>

<ol>
<li>Leave them uninitialized. eg int &amp;x; <br>
<ul><li>Must be initialized to something that has an address (an lvalue), since refs are ptrs: <code>int &amp;x = 3;</code> X , <code>int &amp;x = y + z;</code> X , <code>int &amp;x = y;</code> Is okay</li></ul></li>
<li>Create a ptr to a reference: <br>
<ul><li><code>int &amp;*x;</code>- for c, always start at var and then go left. So x is a pointer to a ref of an int.</li>
<li>ref to ptr OK: <code>int *&amp;x = ... ;</code></li></ul></li>
<li>Create a reference to a reference <br>
<ul><li><code>int &amp;&amp;x = ... ;</code> - this means something difference (we’ll talk about this later)</li></ul></li>
<li>Create an array of references: <code>int &amp;r[3] = {n,n,n};</code> X</li>
</ol>

<p>What <em>can</em> you do? pass as f’n params:</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> &amp;n){++n;} <span class="hljs-comment">// notice that there's no ptr deref and &amp;n is a const. ptr to the arg.</span>
<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 6</span></code></pre>

<blockquote>
  <p>So why does cin &gt;&gt; x work? - takes x by reference</p>
</blockquote>

<p><code>istream &amp; operator &gt;&gt; (istream &amp;in, int&amp;data)</code></p>

<p>Pass-by-value. eg: <code>int f(int n) { ... } copies the arguement</code></p>

<ul>
<li>if the arg is big, copying can be expensive <br>
eg: <code>struct Really Big { ... }</code>,</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(ReallyBig rb){ ... }; <span class="hljs-comment">// really slow</span>
<span class="hljs-keyword">int</span> g(ReallyBig &amp;rb){ ... }; <span class="hljs-comment">// &amp;rb is now an alias - fast. Downside is that rb can be changed by the f'n. You don't know.</span>
<span class="hljs-keyword">int</span> h(<span class="hljs-keyword">const</span> ReallyBig &amp;rb) { ... }; <span class="hljs-comment">// really fast and param can't be changed. woah</span></code></pre>

<p>Advice: prefer pass-by-const-ref over pass-by-value for anything larger than a ptr - unless the f’n needs to make a copy anyway. Then, maybe pass-by-value.</p>

<p>Also: <code>int f(int &amp;n) { ... }</code>      <code>int g(const int &amp;n) { ... }</code></p>



<pre class="prettyprint"><code class="language-cpp hljs ">f(<span class="hljs-number">5</span>); <span class="hljs-comment">// won't compile. can't initialize an lvalue ref (n) to a literal value. if n changes, can't change the literal 5.</span>
g(<span class="hljs-number">5</span>); <span class="hljs-comment">//is a-OK since n can never be changed. Compiler allows this. How? compiler creates a temp location to hold the 5, so the reference n has something to point to.</span></code></pre>



<h3 id="dynamic-memory-allocation">Dynamic Memory Allocation</h3>

<p>C: </p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>( ... *<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
...
<span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//DON'T USE THESE IN C++</span></code></pre>

<blockquote>
  <p>Instead: new/delete - type aware and less error-prone</p>
</blockquote>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};

Node *np = <span class="hljs-keyword">new</span> Node;
...
<span class="hljs-keyword">delete</span> np;</code></pre>

<ul>
<li>all local vars reside on the stack - vars are deallocated when they go out of scope (stack is popped).</li>
<li>allocated memory resides on the heap.</li>
<li>remains allocated until delete is called</li>
<li>if you don’t delete all allocated memory - memory leak</li>
<li>program will eventually fail - incorrect behaviour</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">10</span>];
...
<span class="hljs-keyword">delete</span> [np];</code></pre>



<pre class="prettyprint"><code class=" hljs coffeescript">Node getMeANode(){ <span class="hljs-regexp">//</span><span class="hljs-keyword">return</span>-<span class="hljs-keyword">by</span>-value = copy. expensive?
    Node n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-regexp">//</span>-<span class="hljs-keyword">return</span> <span class="hljs-keyword">by</span> ptr(ret) instead?
Node *getMeANode(){
    Node n;
    <span class="hljs-keyword">return</span> &amp;n;
    <span class="hljs-regexp">//</span>BAD - returns a ptr to stack - allocated data which <span class="hljs-keyword">is</span> dead <span class="hljs-literal">on</span> <span class="hljs-keyword">return</span>
}

Node *getMeANode(){ <span class="hljs-regexp">//</span>Ok - returns a ptr to Heap data - still alive - but don<span class="hljs-string">'t forget to delete it!
    return new Node;
}</span></code></pre>



<h2 id="lecture-7">Lecture 7</h2>



<h3 id="operator-overloading">Operator Overloading</h3>

<p>Give meanings to c++ operators for our own types <br>
eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    Vec v={v1.x + v2.x , v1.y + v2.y};
    <span class="hljs-keyword">return</span> v;
}

Vec <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> {k*v.x, k*v.y} <span class="hljs-comment">//okay since compiler knows that it's a vec based on the return type</span>
}
<span class="hljs-comment">// this only works when scalar is on the left (eg. k*v). To get v*k, we need to make another function.</span>
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Vec &amp;v, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k){
    <span class="hljs-keyword">return</span> k*v;
}</code></pre>



<h3 id="overloading-and">Overloading &lt;&lt; and &gt;&gt;</h3>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Grade{
    <span class="hljs-keyword">int</span> theGrade;
};

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Grade &amp;g){
    out &lt;&lt; g.theGrade &lt;&lt; <span class="hljs-string">'%'</span>;
    <span class="hljs-keyword">return</span> out
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, Grade &amp;g){
    in &gt;&gt; g.theGrade;
    <span class="hljs-keyword">if</span>(g.theGrade &lt; <span class="hljs-number">0</span>) g.theGrade=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(g.theGrade&gt;<span class="hljs-number">100</span>) g.theGrade=<span class="hljs-number">100</span>;
    <span class="hljs-keyword">return</span> in;
}</code></pre>



<h3 id="the-preprocessor">The Preprocessor</h3>

<p>Transforms the program before the compiler sees it. #<script type="math/tex" id="MathJax-Element-322">\text{_____}</script> = preprocessor directive</p>

<p>eg.<code>#include</code> <br>
Including old C headers - new naming convention <br>
eg. Instead of <code>#include &lt;stdio.h&gt;, use #include&lt;cstdio&gt;</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define VAR VALUE <span class="hljs-comment">//- sets a preprocessor variable, then all occurrences of VAR in the source file are replaced with VALUE</span></span>
<span class="hljs-preprocessor">#define MAX 10</span>
<span class="hljs-keyword">int</span> x[MAX] <span class="hljs-comment">//transformed to int x[10]. Was a cheap way of const from the old days (1970s) before const was a thing</span>

<span class="hljs-preprocessor">#define FLAG <span class="hljs-comment">//sets the variable FLAG; Value is the empty string</span></span></code></pre>

<p>Defined constants are useful for conditional compilation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define IOS 1</span>
<span class="hljs-preprocessor">#define BBOS 2</span>
<span class="hljs-preprocessor">#define OS IOS <span class="hljs-comment">//(or BBOS)</span></span>
<span class="hljs-preprocessor">#if OS==IOS</span>
    <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//Removed if OS!=IOS</span>
<span class="hljs-preprocessor">#elif OS==BBOS</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//this code is removed if OS!=BBOS</span>
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>Special Case</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#if 0 <span class="hljs-comment">//never true - all inner text is removed before it gets to the compiler</span></span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-comment">//heavy-duty "comment out"</span></code></pre>

<p>Can also define symbols via compiler arguments</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class="language-bash hljs ">g++<span class="hljs-number">14</span> -DX=<span class="hljs-number">15</span> define.cc -o define</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifdef NAME <span class="hljs-comment">//true if NAME has been defined</span></span>
<span class="hljs-preprocessor">#ifndef NAME <span class="hljs-comment">//true if NAME HAS NOT been defined</span></span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-preprocessor">#ifdef DEBUG</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"setting x=1"</span> &lt;&lt;endl;
    <span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(x&lt;<span class="hljs-number">10</span>){
        ++x;
        <span class="hljs-preprocessor">#ifdef DEBUG</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x is now"</span> &lt;&lt; endl;
        <span class="hljs-preprocessor">#endif</span>
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class=" hljs lua">gc++<span class="hljs-number">14</span> -DDEBUG <span class="hljs-built_in">debug</span>.cc -o <span class="hljs-built_in">debug</span>
//enables <span class="hljs-built_in">debug</span> output</code></pre>



<h3 id="separate-compilation">Separate Compilation</h3>

<p>Split program into composable modules, with</p>

<dl>
<dt>Interface</dt>
<dd>type definitions, prototypes for functions - .h file</dd>

<dt>Implementation</dt>
<dd>full definitions of functions - .cc file</dd>

<dt><em>Recall</em>: declaration</dt>
<dd>asserts existence</dd>

<dd>def’n - full details - allocates space (for vars/f’ns)</dd>
</dl>

<p>E.g. Interface (vec.h)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}
Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> main(){
    Vec v = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
    v = v+v;
    ...
}
<span class="hljs-comment">//implied vec.cc</span>

<span class="hljs-preprocessor">#include "vec.h" <span class="hljs-comment">//we include vec.h here because we don't know what a vec is.</span></span>
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
     ...
     ...
     ...
}</code></pre>

<blockquote>
  <p>Recall: an entity can be declared many times, but defined at most once</p>
</blockquote>



<h3 id="compiling-separately">Compiling Separately</h3>



<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">vec</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span>
<span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">main</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span></code></pre>

<blockquote>
  <p><code>-c</code> -&gt; means compile only, do not link, do not build the executable. Produces an object file.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs avrasm">g++<span class="hljs-number">14</span> vec<span class="hljs-preprocessor">.o</span> main<span class="hljs-preprocessor">.o</span> -o main</code></pre>



<h1 id="never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</h1>

<p>Global var: <code>int globalNum;</code></p>



<h2 id="lecture-8">Lecture 8</h2>

<p>vec.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
};
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> globalVar;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);</code></pre>

<p>vec.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> global Num;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    ...
}</code></pre>

<p>Let’s write a linear algebra module <br>
linalg.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>linalg.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>The above won’t compile:</p>

<ul>
<li>main.cc, linalg.cc include linalg.h, vec.h, linalg.h includes vec,h</li>
<li>main.cc, linalg.cc get 2 copies of vec.h therefore struct vec defined twice. x</li>
</ul>

<blockquote>
  <p>Need to prevent files from being included twice</p>
</blockquote>

<p>Sol’n: “include guard:” <br>
vec.h </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifndef VEC_H</span>
<span class="hljs-preprocessor">#define VEC_H</span>
... file contents
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>first time vec.h is included. Symbol VEC_H is not defined so file is included. After that, symbol is defined so vec.h is never included twice.</p>

<p>Always - put include guards in .h files <br>
Never - include .cc files - many many different functions. Included .cc file, you defined everything again and again and again.</p>

<p>Never - put using namespace std in header files. This directive would be forced on any client that includes this file <br>
- inside header files, always say std::cin, std::string etc.</p>



<h3 id="classes">Classes</h3>

<ul>
<li>can put functions inside of structs</li>
</ul>

<p>eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> assns*<span class="hljs-number">0.4</span> + mt*<span class="hljs-number">0.2</span> + final*<span class="hljs-number">0.4</span>;
    }
};
Student s{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; s.grade() &lt;&lt; endl;</code></pre>

<p>class </p>

<ul>
<li>a struct type that can contain f’ns</li>
<li>c++ has a class keyword - we will use it later</li>
</ul>

<p>object</p>

<ul>
<li>an instance of a class</li>
</ul>

<p>eg: <code>Student</code> - class, <code>s</code> - object, <code>{60, 70, 80}</code></p>

<p>The function grade - called a member function (or method) <br>
What doe assns, mt, final inside of grade ( ) {…} mean? <br>
- they are fields of the current object upon which grade was invoked</p>

<p>e.g. </p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>};
billy.grade(); \\method call uses billy<span class="hljs-string">'s assns, mt, final</span></code></pre>

<p>Formally: methods take a hidden extra parameter called this - ptr to the object on which the method was invoked. eg. billy.grade() &lt;- (this) == &amp;billy <br>
can write</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;assns *<span class="hljs-number">0.4</span> + <span class="hljs-keyword">this</span>-&gt;mt*<span class="hljs-number">0.2</span> + <span class="hljs-keyword">this</span>-&gt;final*<span class="hljs-number">0.4</span>;
    }
};</code></pre>

<p>Initializing Objects</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//ok, but limited</span></code></pre>

<p>Better: Write a method that does initialization: a constructor (ctor)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){...}
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final){
        <span class="hljs-keyword">this</span>-&gt;assns = assns;
        <span class="hljs-keyword">this</span>-&gt;mt = mt;
        <span class="hljs-keyword">this</span>-&gt;final = final;
    }
}

Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//better. Even though this looks the same as above, this calls a ctor if it has been defined. IF no ctor has been defined, these initialize the individual fields of student.</span></code></pre>

<p>Head allocation:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student xpBilly = <span class="hljs-keyword">new</span> Student{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Advantages  of ctors: default params, overloading, sanity checks</p>

<p>eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    Student(in assns = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> mt=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> final=<span class="hljs-number">0</span>){
        <span class="hljs-keyword">this</span>.assns = assns;
        <span class="hljs-keyword">this</span>.mt = mt;
        <span class="hljs-keyword">this</span>.final =final;
    }
}</code></pre>

<blockquote>
  <p>Note: Every class comes with a default (ie no-arg) ctor (which just default constructs all fields that are objects). <br>
  eg.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec v; <span class="hljs-comment">//default ctor (does nothing in this case, the fields aren't objects)</span></code></pre>

<p>But the built-in default ctor goes away if you provide a ctor <br>
E.g.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y){
        <span class="hljs-keyword">this</span>-&gt;x=x;
        <span class="hljs-keyword">this</span>-&gt;y=y;
    }
}
Vec v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}; OK
Vec v; XXXX</code></pre>

<p>What if a struct contains consts or refs?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> MyStruct{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst; <span class="hljs-comment">//these two have to be initialized</span>
    <span class="hljs-keyword">int</span> &amp;myRef;
};

<span class="hljs-keyword">int</span> z;
<span class="hljs-keyword">struct</span> MyStuct {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst = <span class="hljs-number">5</span>; 
    <span class="hljs-keyword">int</span> &amp;myRef=z;
}; <span class="hljs-comment">//this is kind of bad since not every MyStruct wants the same val. Compiles, though</span></code></pre>

<p>But does every instance of student need the same value of myConst, etc?</p>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//const (doesn't change) but not the same for all students.</span>
}</code></pre>

<p>Where do we initialize? ctor body? TOO LATE!</p>

<p>Where do we initialize? ctor body? - too late - fields must be fully constructed by then.</p>

<p>What happens when an object is created:</p>

<ol>
<li>space is allocated</li>
<li>fields are constructed //need to put our initializations here</li>
<li>ctor body runs</li>
</ol>

<p>How? - member initialization list (MIL)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">int</span> assns, mt, final;
    Student(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final):
        id{id}, assns{assns}, mt{mt}, final{final} {}
}</code></pre>

<blockquote>
  <p>Here: id - field, {id} - params <br>
  Note: can initialize any field this way, not just const + refs <br>
  Note: Fields initialized in the order in which they are declared in the class, even if the MIL orders them differently <br>
  Note: MIL sometimes more efficient than setting fields in the body. (o/w - run default ctor, then reassign in the body) EMBRACE THE MIL! ALL HAIL. PRAISE BE.</p>
</blockquote>

<p>what if a field is initialized inline AND in the MIL?</p>



<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">vec</span>(<span class="hljs-keyword">int</span> x); x{x} {}
};</code></pre>

<p>MIL takes precedence</p>



<h2 id="lecture-9">Lecture 9</h2>



<h3 id="uniform-initialization">Uniform Initialization</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> x(<span class="hljs-number">5</span>);
<span class="hljs-built_in">string</span> s = <span class="hljs-string">"hello"</span>;
<span class="hljs-built_in">string</span> s(<span class="hljs-string">"hello"</span>);
Student billy(<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>);
<span class="hljs-comment">//preferred (cs246 doesn't care which init you use though). This was updated as of a few years ago.</span>
<span class="hljs-keyword">int</span> x{<span class="hljs-number">5</span>};
<span class="hljs-built_in">string</span> s{<span class="hljs-string">"hello"</span>};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Now consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student bobby = billy; <span class="hljs-comment">//-how does this init happen? the COPY CONSTRUCTOR. For constructing one object as a copy of another</span></code></pre>

<blockquote>
  <p>Note: Every class comes with:</p>
  
  <ul>
  <li>default ctor (default constructs all fields that are objects) <br>
  <ul><li>copy ctor (just copies all the fields)</li>
  <li>copy assignment operator</li>
  <li>destructor</li>
  <li>move ctor</li>
  <li>move assignment operator</li></ul></li>
  </ul>
</blockquote>

<p>Building your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns,mt,final;
    Student(...) {...}
    Student(<span class="hljs-keyword">const</span> Student &amp;other): assns {assns}, mt {mt}, final {final} {}
}; <span class="hljs-comment">//equiv. to built in</span></code></pre>

<p>When is the built-in copy ctor not correct?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next
    Node(<span class="hljs-keyword">int</span> data, Node *next): data {data}, next{next} {}
    ...
};
Node *n = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
Node m = *n;
Node *p =<span class="hljs-keyword">new</span> Node{*n};</code></pre>

<p><img src="http://amyqiu.me/Notes/pointer.png"> <br>
Simple copy of fields -&gt; only the first node is actually copied (<em>shallow copy</em>) <br>
If you want a <em>deep copy</em> (copies the whole list),  must write your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(<span class="hljs-keyword">const</span> Node &amp;other): data{other.data}, next{ other.next? <span class="hljs-keyword">new</span> Node (*other.next) : <span class="hljs-keyword">nullptr</span>}{}
} <span class="hljs-comment">//we have some sneaky recursion going on here. This recursively invokes the copy ctor + copies the rest of the list</span></code></pre>

<p>The copy ctor is called:</p>

<ol>
<li>When an object initializes another object</li>
<li>When an object is passed by value</li>
<li>When an object is returned by value (* - not always)</li>
</ol>

<blockquote>
  <p>Note: Careful with ctors that can take ONE parameter:</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};</code></pre>

<p>single-arg ctors create implicit conversions. <br>
Eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">4</span>};
<span class="hljs-comment">// - also I can call:</span>
Node n =<span class="hljs-number">4</span>; <span class="hljs-comment">//- implicit conversion from int to node.</span>
<span class="hljs-keyword">int</span> f(Node n){...}
f(<span class="hljs-number">4</span>); <span class="hljs-comment">//works -4 is implicitly converted to Node</span></code></pre>

<blockquote>
  <p>Danger - accidentally passing an int to a f’n expecting a Node. Compiler will not signal an error. <br>
  Good idea - disable the implicit conversion - make the ctor explicit</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};
Node n{<span class="hljs-number">4</span>}; <span class="hljs-comment">//ok</span>
Node n = <span class="hljs-number">4</span>; <span class="hljs-comment">//error</span></code></pre>



<h3 id="destructors">Destructors</h3>

<p>When an object is destroyed (stack-allocated: goes out of scope, heap-allocated: is deleted) a method called the destructor runs. Classes comes with a dtor (just calls dtor on all fields that are objects) <br>
When an object is destroyed:</p>

<ol>
<li>The dtor body runs</li>
<li>field’s dtors invoked in reverse declaration order</li>
<li>space deallocated</li>
</ol>

<p>When do we need to write one?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span> <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};</code></pre>

<p>If np goes out of scope - the pointer is reclaimed (stack-allocated). The entire list is leaked. <br>
If we say <code>delete np;</code> then the 2 &amp; 3 nodes are leaked</p>

<p>Write a dtor to ensure the whole list is freed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;} <span class="hljs-comment">//&lt;- recursively calls next's dtor - frees the whole list.</span>
};</code></pre>

<p>Now - <code>delete np;</code> -frees the whole list</p>



<h3 id="copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane = billy; <span class="hljs-comment">//copy ctor</span>
Student mary; <span class="hljs-comment">//default ctor</span>
mary = billy; <span class="hljs-comment">//copy, but not construction. copy assignment operator is `=` - uses compiler-supplied default</span></code></pre>

<p>May need to write your own:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-comment">//So that cascading works your return itself. Eg. a=b=c=4; returns a = b = c; (c=4 now), a=b, (b=4 as well now), and then a=4;</span>
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        data=other.data;
        <span class="hljs-keyword">delete</span> next; <span class="hljs-comment">//the existing node might have other nodes so we need to delete those.</span>
        next=other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        <span class="hljs-comment">//THIS IS DANGEROUS</span>
    }
}</code></pre>

<p>Why?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
n=n; <span class="hljs-comment">//deletes n + then tries to copy n to n. undefined behaviour</span>
*p = *q;
a[i] = a[j];</code></pre>

<p>When writing operator=, ALWAYS be wary of self-assignment:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        data = other.data;
        <span class="hljs-keyword">delete</span> next;
        next = other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};</code></pre>

<p>Better:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp=next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data=other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }</code></pre>

<p>//if new fails, Node is still in a valid state.</p>



<h2 id="lecture-10">Lecture 10</h2>



<pre class="prettyprint"><code class="language-cpp hljs ">Node&amp; operators=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp = next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data = other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>
}</code></pre>

<p>Alternative: copy + swap idiom &lt;3</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;utility&gt;</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">void</span> swap(Node &amp;other){
        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
        swap(data,other.data);
        swap(next, other.next);
    }
}

Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    Node tmp = other; <span class="hljs-comment">//tmp = copy of other</span>
    swap(tmp); <span class="hljs-comment">//me = copy of other. tmp = my old fields</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//my old data deleted when tmp goes out of scope</span>
}</code></pre>



<h3 id="rvalues-rvalue-references">Rvalues + Rvalue References</h3>

<blockquote>
  <p>Recall: - an lvalue is anything with an address. -an lvalue reference (&amp;) is like a const pointer with automatic dereferencing. -always initialized to a lvalue.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node m=n; <span class="hljs-comment">//copy ctor;</span>
Node m2;
m2=n; <span class="hljs-comment">//copy assignment operator</span>

Node plusOne(Node n){
    <span class="hljs-keyword">for</span>(Node *p=&amp;n;p;p=p-&gt;next){
        ++p-&gt;data;
    }
    <span class="hljs-keyword">return</span> n;
}
Node m3 = plusOne(n); <span class="hljs-comment">//copy ctor. What is "other" here? Reference to what?</span></code></pre>

<ul>
<li>Compiler creates a <code>temporary</code> object to hold the result of plusOne</li>
<li>Other is a reference to this temporary - copy ctor deep-copies data from this temporary. <br>
<em>But:</em> - the temporary is just going to be discarded anyway, as soon as the stmt <code>Node m3 = plusOne(n);</code> is done</li>
<li>wasteful to copy from the temp. Why not just steal it instead? - save the cost of a copy. <br>
-Need to be able to tell whether the other is a reference to a temporary or a standalone object <br>
C++ - rvalue reference -&gt; Node &amp;&amp; is a reference to a temporary object (rvalue) of type Node.</li>
</ul>

<p>Version of the ctor that takes Node &amp;&amp;.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(Node &amp;&amp; other): <span class="hljs-comment">//called a move ctor</span>
    <span class="hljs-comment">// what should the move ctor do? Should steal other's data.</span>
        data{other.data},
        next{other.next} {
            other.next=<span class="hljs-keyword">nullptr</span>; <span class="hljs-comment">//else the list is destroyed when other is destroyed. This ctor is constant time.</span>
        }
}</code></pre>

<p>Similarly:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node m;
m=plusOne(n); <span class="hljs-comment">//Assignment from temporary</span>
<span class="hljs-comment">//More assignment operator:</span>
<span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(Node &amp;&amp;other){
        swap(other); <span class="hljs-comment">//steal other's data</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//destroy my old data. swap without copy</span>
    }
}</code></pre>

<p>If you don’t define move ctor/assignment, the copy versions will be used. If the move ctor/assignment is defined, it will replace all calls to copy ctor/assignment when the argument is a temporary (rvalue).</p>



<h3 id="copymove-elision">Copy/Move Elision</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec makeAVec(){
    <span class="hljs-keyword">return</span> {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}; <span class="hljs-comment">//invokes a basic ctor</span>
}
Vec v=makeAVec(); <span class="hljs-comment">//what runs? Not Sure! When compiled in g++, there's the basic ctor (no move/copy ctor).</span></code></pre>

<p>In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn’t have to) <br>
In this example: makeAVec writes it’s result ({0,0}) directly into the space occupied by v in the caller, rather than copy or move it later. <br>
Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> doSomething(vec v)<span class="hljs-comment">//&lt;- pass-by-value copy/move ctor</span>
{...}
doSomething(makeAVec()); <span class="hljs-comment">//-result of makeAVec is written directly into the parameter. There is no copy or move. This is allowed even if dropping ctor calls would change the behaviour of the program. eg. if the ctors print something.</span></code></pre>

<p>You are not expected to know exactly when move/copy elision is allowed, just that it is possible.</p>

<p>If you need all of the ctors to run: <code>g++14 -fno-elide-constructors</code> runs all constructors. But this can slow down your program considerably</p>

<p>In Summary: Rule of 5 (Big 5)</p>

<ul>
<li>If you need a custom version of any one of: <br>
<ul><li>copy ctor</li>
<li>copy assignment</li>
<li>dtor</li>
<li>move ctor</li>
<li>move assignment <br>
Then you usually need a custom version of all five. (The circumstances that require you to need one, usually require you to need all of them)</li></ul></li>
</ul>

<blockquote>
  <p>Notice: <br>
  <code>operator=</code> is a member function, not a standalone function <br>
  When an operator is a member, <code>this</code> is the first arguement</p>
  
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
  <span class="hljs-keyword">int</span> x,y;
  ...
  Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec&amp;other){
     <span class="hljs-keyword">return</span>{x+other.x, y+other.y};
  }
  Vec <span class="hljs-keyword">operator</span>*{<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k}{ <span class="hljs-comment">//implements v*k</span>
     <span class="hljs-keyword">return</span> {x*k, y*k};
  }
  <span class="hljs-comment">//How do we implement k*v? Can't be a member -first arg not Vec. -Write it as a standalone:</span>
}
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
  <span class="hljs-keyword">return</span> v*k;
}</code></pre>
</blockquote>

<p>I/O operators:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    ...
    ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out){
        <span class="hljs-keyword">return</span> out &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; y;
    }
};
<span class="hljs-comment">//what's wrong? Make Vec the first arg. -&gt; Use as vec&lt;&lt;cout;</span></code></pre>

<p>So define &lt;&lt;. &gt;&gt; as standalone fns.  <br>
Certain operators <strong>must</strong> be members:</p>

<ul>
<li>operator=</li>
<li>operator[]</li>
<li>operator()</li>
<li>operator T (where T is a type)</li>
</ul>



<h2 id="lecture-10-1">Lecture - 10</h2>



<h3 id="separate-compilation-for-classes">Separate Compilation for Classes</h3>

<p>Node.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor"># ...</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data, Node*next=<span class="hljs-keyword">nullptr</span>);
    <span class="hljs-keyword">bool</span> hasNext();
};</code></pre>

<p>Node.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "node.h"</span>
Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next} {} <span class="hljs-comment">//compiler will yell at you for this. No return type and can't use init for f'ns.</span>
Node::Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next}{} <span class="hljs-comment">//tells compiler that it belongs to a class</span>

<span class="hljs-keyword">bool</span> hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;} <span class="hljs-comment">//will yell and say that you're using an undeclared variable</span>
<span class="hljs-keyword">bool</span> Node::hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;}<span class="hljs-comment">//better</span></code></pre>

<p><code>::</code> - scope resolution operator <br>
<code>Node:: ____</code> means <code>____</code> within class node <br>
<code>::</code> like <code>.</code> where LHS is a class or namespace, not an object</p>



<h3 id="arrays-of-objects">Arrays of Objects</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y): x{x}, y{y} {}
};
Vec *vp = <span class="hljs-keyword">new</span> Vec[<span class="hljs-number">5</span>]; <span class="hljs-comment">// X</span>
Vec moreVecs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// X</span>
<span class="hljs-comment">//there want to call the default ctor on each item. Can't init array elements - no default ctor.</span></code></pre>

<p>Options</p>

<ol>
<li>Provide a default ctor</li>
<li>For stack arrays: <br>
<code>Vec moreVecs[] = {{0,0}, {1,3}, {2,4}};</code></li>
<li>For heap arrays: -create an array of ptrs</li>
</ol>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec **vp = <span class="hljs-keyword">new</span> Vec*[<span class="hljs-number">5</span>];
vp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> Vec {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
vp[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> Vec[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>;++i){
    <span class="hljs-keyword">delete</span> vp[i];
}
<span class="hljs-keyword">delete</span>[] vp;</code></pre>



<h3 id="const-objects">Const Objects</h3>

<p>Const objects arise often</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(<span class="hljs-keyword">const</span> Node &amp;n) {...}</code></pre>

<p>What is a const object? Can’t change fields <br>
Question: Can we call methods on a const object? <br>
<em>Issue:</em> <br>
The method may modify fields, violate const <br>
Answer: Yes - we can call methods that promise not to change fields</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>; <span class="hljs-comment">//this method will not change fields</span>
};</code></pre>

<p>Compiler checks that const methods don’t modify fields. Only const methods can be called on const objects.</p>

<p>Now consider: want to collect usage stats on student objects</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">int</span> numMethodCalls=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodcalls; <span class="hljs-comment">//method isn't const anymore. If you take const out, can't call grade on const students</span>
        <span class="hljs-keyword">return</span> ...
    }
};</code></pre>

<p>But mutating numMethodCalls affects only the <strong>physical constness</strong> of student objects, not the <strong>logical constness</strong></p>

<p>Want to be able to update numMethodCalls, even if the object is const - declare the field <code>mutable</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodCalls;
        <span class="hljs-keyword">return</span> ...;
    }
};</code></pre>

<p>mutable fields can be changed, even if the object is const.</p>



<h3 id="static-fields-methods">Static Fields + Methods</h3>

<p><code>numMethodCalls</code> tracked # of method calls for each particular Student <br>
What if we want to track method calls over all Students? <br>
Or what if we want to know how many Students were created? <br>
<strong>Static members</strong> - associated with the class itself, not with any specified instance (object).</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstances;
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final): assns{assns}, mt{mt}, final{final} {
        ++numInstances;
    }
};

<span class="hljs-keyword">int</span> Student::numInstances=<span class="hljs-number">0</span>; <span class="hljs-comment">//in .cc file</span></code></pre>

<p>static fields must be defined, external to the class</p>



<h3 id="static-member-functions">Static Member Functions</h3>

<ul>
<li>Don’t depend on a specific instance (no <code>this</code> param)</li>
<li>Can only access static fields + call other static methods</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstance;
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> printNumInstances(){
        <span class="hljs-built_in">cout</span> &lt;&lt; numInstances &lt;&lt; endl;
    }
};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane{<span class="hljs-number">70</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>};
Student::printNumInstances(); <span class="hljs-comment">//2</span></code></pre>



<h3 id="invariants-encapsulation">Invariants + Encapsulation</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(<span class="hljs-keyword">int</span> data, Node*next);
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;}
};
Node n1 {<span class="hljs-number">1</span>, newNode {<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node n2 {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>};
Node n3 {<span class="hljs-number">4</span>, &amp;n2};</code></pre>

<p>What happens when these go out of scope?</p>

<ul>
<li>n1: dtor runs, whole list is deleted OK</li>
<li>n2, n3 go out of scope - n3’s dtor attempts to delete n2 but n2 is on the stack, not the heap! Undefined behaviour!</li>
</ul>

<p>Class Node relies on an assumption for its proper operation - next is either <code>nullptr</code> or allocated by <code>new</code>.</p>

<p>This is an <strong>invariant</strong> - statement that holds true, upon which Node relies. <br>
But we can’t guarantee this invariant - can’t trust the user to use Node properly.  <br>
Can’t enforce any invariants - user can interfere with our data.</p>

<blockquote>
  <p>Eg. - Stack : Invariant -&gt; last item pushed is first item popped. <br>
  but not if the client can rearrange the underlying data. </p>
</blockquote>

<p>Hard to reason about programs if you can’t rely on invariants. <br>
To enforce invariants - we introduce <code>encapsulation</code>  - we can’t clients to treat our objects as black boxes - capsules.</p>

<ul>
<li>implementation details sealed away</li>
<li>can only interact via provided methods</li>
<li>abstraction - regains control over our objects</li>
</ul>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs ">strut Vec{
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y); <span class="hljs-comment">//public by default</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">//can't be accessed outside the struct Vec.</span>
    <span class="hljs-keyword">public</span>:
        Vec <span class="hljs-keyword">operator</span>+(...);<span class="hljs-comment">//anyone can access</span>
        ...
};</code></pre>

<p>In general: want fields to be private - only methods should be public.  <br>
Better to have default visibility to be private. <br>
Switch from struct to class. <br>
THIS IS THE ONLY DIFFERENCE BETWEEN STRUCT AND CLASS -&gt; default visibility. Public in <code>struct</code>. Private in <code>class</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x,y);
    Vec <span class="hljs-keyword">operator</span>+(...);
    ...
};</code></pre>



<h2 id="cs-246-tut-5">CS 246 TUT 5</h2>

<blockquote>
  <p>Summary: Rvalues &amp; Lvalues <br>
  Move Copy/Assignment <br>
  Rule of Five <br>
  Member Operators</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> value;
    Node *next;
};

Node add(Node n, <span class="hljs-keyword">int</span> inc){ <span class="hljs-comment">//copy ctor runs</span>
    <span class="hljs-keyword">for</span>(Node *m=&amp;n; m != <span class="hljs-keyword">nullptr</span>; m = m-&gt;next){
        m-&gt;value += inc;
    }
    <span class="hljs-keyword">return</span> n;
}

Node n1{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
Node n2 = add(n1,<span class="hljs-number">3</span>); <span class="hljs-comment">//move ctor</span>
n2 = add(n1, <span class="hljs-number">4</span>); <span class="hljs-comment">//move assign</span>

Node(Node &amp;&amp;other): <span class="hljs-comment">//impl of the move ctor</span>
value{other.value}, next{other.next} {
    other.next = <span class="hljs-keyword">nullptr</span>;
}</code></pre>

<p>Node &amp;operator=(Node &amp;&amp;other){ <br>
    swap(value, other.value); <br>
    swap(next, other.next); <br>
    return *this; <br>
}</p>

<p>lvalue -&gt; with address <br>
rvalue -&gt; without address</p>



<h2 id="lecture-12">Lecture 12</h2>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
        <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);
        Vec <span class="hljs-keyword">operator</span>+(...);
        ...
};</code></pre>

<p>Fix our linked list class: <br>
list.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node; <span class="hljs-comment">//private nested class. Only accessible within list.</span>
    Node *theList = <span class="hljs-keyword">nullptr</span>;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> addToFront(<span class="hljs-keyword">int</span> n);
        <span class="hljs-keyword">int</span> ith(<span class="hljs-keyword">int</span> n) <span class="hljs-keyword">const</span>;
        ~List(){<span class="hljs-keyword">delete</span> theList;}
};</code></pre>

<p>list.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "list.h"</span>
<span class="hljs-keyword">struct</span> List::Node{ <span class="hljs-comment">// Nested class</span>
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(...): ... {}
    ~Node() {<span class="hljs-keyword">delete</span> next;}
};

<span class="hljs-keyword">void</span> List::addToFront(<span class="hljs-keyword">int</span> n){
    theList = <span class="hljs-keyword">new</span> Node {n, theList};
}

<span class="hljs-keyword">int</span> List::ith(<span class="hljs-keyword">int</span> i)<span class="hljs-keyword">const</span>{
    Node *cur = theList;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n &lt; i &amp;&amp; cur; ++n; curr=cur-&gt;next);
    <span class="hljs-keyword">return</span> cur-&gt; data;
}</code></pre>

<p>Only List can create/manipulate Node objects <br>
<script type="math/tex" id="MathJax-Element-323">\therefore</script> Can guarantee the invariant that next is either nullptr or allocated by new.</p>

<p>pause</p>

<hr>

<p>But - Now we can’t traverse the list from front node to node, as would a linked list.  <br>
Repeatedly calling ith - <script type="math/tex" id="MathJax-Element-324">O(n^2)</script> time. <br>
But we can’t expose the nodes, or we lose encapsulation</p>



<h3 id="se-topic-design-patterns">SE Topic: Design Patterns</h3>

<ul>
<li>certain problems arise frequently</li>
<li>keep track of good solutions, use in similar situations</li>
</ul>

<dl>
<dt>Design Pattern</dt>
<dd>If you have problem X, solution Y will fix it.</dd>
</dl>

<blockquote>
  <p>Book Rec: Design Patterns (by the gang of four)</p>
</blockquote>

<hr>

<p>resume</p>

<p>Solution: Create a class that manages access to nodes <br>
- Create a class that manages access to nodes <br>
- abstraction of a ptr <br>
- walk the list without exposing the actual ptrs.</p>

<p>Inspiration:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *p=a; p! = a+n ; ++p){
    ... *p ...
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    Node *theList;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">explicit</span> Iterator(Node *p):p{p}{}
                <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> p-&gt;data;} <span class="hljs-comment">// returns p-&gt;data ITSELF. allows the user to update it themselves. (eg. Iterator it ... ; *it = 7;)</span>
                Iterator &amp;<span class="hljs-keyword">operator</span>++(){p=p-&gt;next; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Iterator &amp;other){ <span class="hljs-keyword">return</span> p==other.p;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Iterator &amp;other){
                    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>==other);
                }
        };
        Iterator begin(){<span class="hljs-keyword">return</span> Iterator{theList};}
        Iterator end(){<span class="hljs-keyword">return</span> Iterator{<span class="hljs-keyword">nullptr</span>};}
        ...<span class="hljs-comment">//other methods like ith</span>
        ... 
};</code></pre>

<p>Client:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    List l;
    l.addToFront(<span class="hljs-number">1</span>);
    l.addToFront(<span class="hljs-number">2</span>);
    l.addToFront(<span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span>(List::Iterator it=l.begin(); it!=l.end();++it){
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;endl;
    }
}</code></pre>

<blockquote>
  <p>Shortcut: automatic type deduction - <code>auto x = y;</code> . <code>auto</code> automatically gives x the same type as y.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = l.begin(); it!=l.end(); ++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}</code></pre>

<blockquote>
  <p>Shorter cut: range-based for loop</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:l){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}</code></pre>

<p>Available for any class with:</p>

<ul>
<li>methods begin + end that produces iterators</li>
<li>iterators must support !=, prefix ++, unary *</li>
</ul>

<p>If you want to modify the list items (or save copying):</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;n: l){
    ++n;
}</code></pre>

<p>Iterators shall return later.</p>

<p>Encapsulation ctd.</p>

<p>List  Client can create iterators directly :o</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> it = List::Iterator{<span class="hljs-keyword">nullptr</span>}; <span class="hljs-comment">//well, they only can make a nullptr iterator. But still. Bad form.</span></code></pre>

<ul>
<li>violate encapsulation - client should be using begin/end.</li>
</ul>

<p>We could make Iterator’s ctor private. Then client can’t call <code>List::Iterator(...)</code> . But then neither can List.</p>

<p>Solution: Give List privileged access to Iterator. Make it a <code>friend</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">explicit</span> Iterator(Node *p); <span class="hljs-comment">//private</span>
            <span class="hljs-keyword">public</span>:
                ...
                <span class="hljs-keyword">friend</span> clas List; <span class="hljs-comment">// List has access to all members of Iterator.</span>
        };
    ...
};</code></pre>

<p>Now List can still create iterators, but client can only create them by calling <code>begin()</code> and <code>end()</code>.</p>

<p>Advice: give your classes as few friends as possible. weakens encapsulation. <br>
Once again: keep fields private. What if you want to give access to fields? use accessor + mutator methods.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> getX()<span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> x;} <span class="hljs-comment">//accessor</span>
        <span class="hljs-keyword">void</span> setY(<span class="hljs-keyword">int</span> newY){y=newY;} <span class="hljs-comment">//mutator</span>
};</code></pre>

<hr>

<p>what about operator &lt;&lt; - needs x+y, can’t be a member <br>
If no getX, getY - make operator &lt;&lt; a friend function</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v);
}

<span class="hljs-comment">//.cc</span>
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> out &lt;&lt; v.x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v.y;
}</code></pre>



<h3 id="tools-topic-make">Tools topic: make</h3>

<p>Separate compilation: <code>g++14 -c list.cc</code> , <code>g++14 -c node.cc</code>, <code>g++14 -c iter.cc</code>, <code>g++14 -c main.cc</code>, <code>g++14 list.o node.o iter.o main.o -o myprog</code> <br>
Why do we do this? So we don’t have to recompile files that haven’t changed.</p>

<p>How do you keep track of what’s changed? <br>
Let Linux help you - with make.</p>

<p>Create a Makefile that says which files depend on which other files. <br>
myprog: main.o list.o node.o iter.o //myprog depends on these <br>
[   ] (MUST be a TAB) g++-5 -std=c++14 main.o list.o node.o iter.o -o myprog (&lt;- how to rebuild)</p>



<h2 id="lecture-13">Lecture 13</h2>



<h3 id="makefile">Makefile</h3>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">myprog:</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>==++<span class="hljs-number">14</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span> -o myprog
<span class="hljs-label">list.o:</span> list<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>=c++<span class="hljs-number">14</span> -c list<span class="hljs-preprocessor">.cc</span>
etc</code></pre>

<p>What does myprogram depend on? <br>
- Recursively build these, if necessary <br>
iter.cc changes: - now newer than iter.o (by last modified date). <script type="math/tex" id="MathJax-Element-325">\therefore</script> rebuilt iter.o <br>
- now iter.o newer than myprogram. <script type="math/tex" id="MathJax-Element-326">\therefore</script> rebuild myprogram <br>
- To do a full rebuild, make clean, make</p>

<p>Generalize with variables</p>



<pre class="prettyprint"><code class=" hljs lasso">CXX <span class="hljs-subst">=</span> g<span class="hljs-subst">++-</span><span class="hljs-number">5</span> <span class="hljs-comment">//compiler's name</span>
CXXFLAGS <span class="hljs-subst">=</span> <span class="hljs-attribute">-std</span><span class="hljs-subst">=</span>c<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-Wall</span> <span class="hljs-comment">//(Wall turns on warnings)</span></code></pre>

<p>eg. </p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> iter<span class="hljs-preprocessor">.h</span>
    ${CXX} ${CXXFLAGS} -c iter<span class="hljs-preprocessor">.cc</span></code></pre>

<p>Shortcut: for any rule of the form</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">x.o:</span> <span class="hljs-built_in">x</span><span class="hljs-preprocessor">.cc</span> a<span class="hljs-preprocessor">.h</span> b<span class="hljs-preprocessor">.h</span></code></pre>

<p>-can leave out the build command <br>
- make guesses that you want</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-variable">${CXX}</span> <span class="hljs-variable">${CXXFLAGS}</span> -c x.cc -o x.o</code></pre>

<p>Biggest problem with writing Makefiles <br>
-working out dependencies <br>
and maintaining them if they change.</p>

<p>Can get help from g++</p>



<pre class="prettyprint"><code class=" hljs lasso">g<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-MMD</span> <span class="hljs-attribute">-c</span> iter<span class="hljs-built_in">.</span>cc</code></pre>

<p>-creates iter.o and iter.d <br>
iter.d</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span></code></pre>

<p>Now just include this in the Makefile</p>



<pre class="prettyprint"><code class=" hljs r">CXXFLAGS= -std=c++<span class="hljs-number">14</span> -Wall -MMD
<span class="hljs-keyword">...</span>
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS: .o=.d}
<span class="hljs-keyword">...</span></code></pre>

<p>-include ${DEPENDS}</p>



<h3 id="system-modelling">System Modelling</h3>

<p>building an 00 system: <br>
- identify abstractions <br>
- formalize relationships among them <br>
Helpful to map these out <br>
popular standard: UML (Unified Modelling Language) <br>
Modelling a Class</p>

<table>
<thead>
<tr>
  <th>Name</th>
  <th>Vec</th>
</tr>
</thead>
<tbody><tr>
  <td>Fields(optional)</td>
  <td>-x:Integer, -y:Integer</td>
</tr>
<tr>
  <td>Methods(optional)</td>
  <td>+getx: Integer, +getY:Integer</td>
</tr>
</tbody></table>


<p>Visibility: <code>-</code> -&gt; private, <code>+</code> -&gt; public <br>
Relationship: Composition of Classes</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);
};
<span class="hljs-comment">//Two vecs define a basis</span>
<span class="hljs-keyword">class</span> Basis{
    Vec v1,v2;
};
Basis b; <span class="hljs-comment">//XXX can't initialize v1, v2 - no default ctor for Vec.</span></code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Basis{
    Vec v1, v2;
    <span class="hljs-keyword">public</span>:
        Basis(): v1{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}, v2 {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>} {}
};</code></pre>

<p>Embedding one obj.(Vec) inside another (Basis) called <strong>Composition</strong> <br>
Relationship between Basis + Vec is called “owns-a” - A Basis “owns” the two Vec objects.</p>

<p>If A “owns-a” B then typically -</p>

<ul>
<li>B has no identity outside A (B is a part of A)</li>
<li>If A is destroyed, B is destroyed</li>
<li>If A is copied, B is copied (deep copy) <br>
E.g: A car owns y wheels - a wheel is a part of a car <br>
-destroy the car -&gt; destroy the wheels <br>
-copy the car -&gt; copy the wheels</li>
</ul>

<p>Implement: usually as composition of classes <br>
Modelling <br>
<img src="http://amyqiu.me/Notes/ownsa.png"> <br>
More details: links on course website</p>



<h3 id="aggegation">Aggegation</h3>

<p>Compare car parts in a car (“owns a”) vs car parts in a catalogue. <br>
The catalogue contains parts, but the parts exists on their own. “has-a” relationship (aggregation)</p>

<p>If A “has a” B, then typically</p>

<ul>
<li>B has an existence outside of its association with A</li>
<li>If A is destroyed, B lives on</li>
<li>If A is copied, B is not (shallow copies) <br>
<ul><li>copies of A share the same B</li></ul></li>
</ul>

<p>e.g.: Ducks in a pond <br>
<img src="http://amyqiu.me/Notes/hasa.png"> <br>
Typical Implementation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Pond {
    Duck *ducks[maxDucks];
};</code></pre>



<h3 id="inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</h3>

<p>Suppose you want to track your collection of books</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    ...
};

<span class="hljs-keyword">class</span> Text{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> topic;
    ...
};

<span class="hljs-keyword">class</span> Comic{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> hero;
    ...
};</code></pre>

<p>-Doesn’t affress relationship among these classes. <br>
-How would we create an array or list containing a mixture of these? <br>
Observe that Texts + comics are KINDS of books. Books with extra features <br>
In c++ - inheritance</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{ <span class="hljs-comment">//Base class or superclass</span>
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        Book(...);
        ...
};

<span class="hljs-comment">//Derived classes or subclasses</span>
<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(...);
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> hero;
    <span class="hljs-keyword">public</span>:
        Comic(...);
};</code></pre>

<p>Derived classes inherit fields + methods from the base class. <br>
So Text, Comic have title author, numPages. <br>
Any method that can be called on Book can be called on Text, Comic. <br>
Who can see these members? <br>
title, author, numPages are private in Book. - outsiders can’t see them. <br>
Can Text, Comic see them? <br>
No. Even subclasses can’t see them!</p>

<p>How do we initialize Text?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): title{title}, author{author}, numPages{numPages}, topic{topic}{} <span class="hljs-comment">//WRONG. DOESN'T WORK HAHA</span>
};</code></pre>

<p>Wrong for 2 reasons:</p>

<ul>
<li>title, author, numPages not accessible in Text</li>
<li>when an object is created: <br>
<ol><li>space is allocated</li>
<li><strong>superclass part is constructed</strong> (in this case, Book doesn’t have a default ctor. Can’t do this)</li>
<li>fields are constructed</li>
<li>ctor body runs</li></ol></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p; <span class="hljs-comment">//read right to left. p is a constant pointer to an int.</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//p is a pointer to an int that is constant</span></code></pre>



<h2 id="lecture-14">Lecture 14</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
      Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): Book {title, author, numPages}, topic{topic}{}
};</code></pre>

<p>If the superclass has no default ctor, the subclass MUST invoke a superclass ctor in its Member Initialization List.</p>

<p>If you want to give the subclass access to certain superclass members, use <strong>protected</strong> visibility.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-keyword">protected</span>:
      <span class="hljs-built_in">string</span> title, author;
      <span class="hljs-keyword">int</span> numPages;
      ...
};

<span class="hljs-keyword">class</span> Topic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
      ...
      <span class="hljs-keyword">void</span> addAuthor(<span class="hljs-built_in">string</span> auth) {author+=auth;} <span class="hljs-comment">//ok since we protected author</span>
};</code></pre>

<p>Not a good idea to give subclasses unlimited access to fields. Breaks encapsulation and invariant. -&gt; eg. if you really don’t want Book to have the author Robert Munch, but you can’t guarantee that all subclasses will follow that rule and since they can change fields, breaks invariant.</p>

<p>Better: make fields private and provide protected access.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-built_in">string</span> getTitle() <span class="hljs-keyword">const</span>;
        <span class="hljs-keyword">void</span> setAuthor(<span class="hljs-built_in">string</span> auth);
        ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span>;
    ...
};</code></pre>

<p>Relationship among Text, Comic, Book is called “is-a” <br>
- a Text is a Book <br>
- a Comic is a Book <br>
- protected: #</p>

<p><img src="amyqiu.me/Notes/TextComic.png"></p>

<p>Method isItHeavy - when is a book heavy? <br>
- for ordinary Books - &gt; 200 pgs <br>
- for Text - &gt; 500 pages <br>
- for Comics - &gt; 30 pages</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">200</span>;}
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">30</span>;}
};

<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">500</span>;}
};

Book b{<span class="hljs-string">"A small book"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">50</span>};
Comic c{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; b.isItHeavy() <span class="hljs-comment">//false</span>
     &lt;&lt; c.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>Since a Comic “is a” Book, we can do this:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};</code></pre>

<p>Q: Is b heavy? <br>
Which isItHeavy runs: Book::isItHeavy, or Comic:isItHeavy ? <br>
A: NO - b is not heavy. Book::isItHeavy runs. <br>
Why? <br>
<img src="amyqiu.me/Notes/ComicvsBook.png"> <br>
Since I’ve allocated only enough space for a Book and Comic is bigger, I must treat b as a book no matter what.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{...};
<span class="hljs-comment">//tries to fit a Comic object where there is only space for a Book object. What happens? - slicing occurs - c++ makes comic fit by chopping off bits. Hero field is chopped off so comic is coerced into a Book.</span></code></pre>

<p>So this converts the comic into a Book and Book::isItHeavy runs.</p>

<p>When accessing objects through ptrs, slicing is unnecessary and doesn’t happen.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Comic *pc = &amp;c;
<span class="hljs-built_in">cout</span> &lt;&lt;  pc -&gt; isItHeavy(); <span class="hljs-comment">//true</span>
     &lt;&lt; pb -&gt; isItHeavy(); <span class="hljs-comment">//not heavy</span></code></pre>

<p>still Book:isItHeavy runs when we access pb-&gt;isItHeavy(). <br>
Same object behaves differently, depending on what kind of ptr points at it. <br>
Compiler uses the type of the pointer (or reference) to determine which isItHeavy to run. - does not consider the actual type of the object <br>
Means a comic is only a comic when pointed at by a comic ptr -proabably not what we want.</p>

<p>How do we make comic act like a Comic, even when pointed at by a Book ptr? <br>
Declare the method <strong>virtual</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {...};
        ...
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Comic(...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> override{...}
        ...
};

Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Book &amp;rb = c;
Comic *pc = &amp;;

<span class="hljs-built_in">cout</span> &lt;&lt; pc-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; pb-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; rb.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>E.g. <br>
My Book Collection:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *myBooks[<span class="hljs-number">20</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span> ; ++i){
    <span class="hljs-built_in">cout</span> &lt;&lt; myBooks[i] -&gt;isItHeavy() &lt;&lt; endl; <span class="hljs-comment">// uses the right isItHeavy for corresponding types. :D</span>
}</code></pre>

<p>Accommadates multiple types under one abstraction <br>
-polymorphism (“many forms”)</p>

<hr>



<h3 id="destructor-revisited">Destructor Revisited</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    <span class="hljs-keyword">int</span> *x;
    <span class="hljs-keyword">public</span>:
        X(<span class="hljs-keyword">int</span> n): x{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]}{}
        ~X(){<span class="hljs-keyword">delete</span> [] x;}
};

<span class="hljs-keyword">class</span> Y: <span class="hljs-keyword">public</span> X{
    <span class="hljs-keyword">int</span> *y;
    <span class="hljs-keyword">public</span>:
        Y(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n): X{n}, y{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m]}{}
        ~Y(){<span class="hljs-keyword">delete</span> [] y};
};</code></pre>

<p>You don’t have to delete X. X’s dtor will run after Y automatically since it’s the superclass.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">X *myX = <span class="hljs-keyword">new</span> Y{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>};
<span class="hljs-keyword">delete</span> myX; <span class="hljs-comment">//- leaks, why? X's dtor ran, but myX points to a Y. Y's dtor never runs here.</span></code></pre>

<p>So only x, but not y is freed. <br>
How can we ensure that deletion through superclass ptr will call subclass dtor? <br>
- declare the dtor virtual</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">virtual</span> ~X(){
            <span class="hljs-keyword">delete</span> x;
        }
};</code></pre>

<p>ALWAYS - make the dtor virtual in classes that are meant to have subclasses <br>
-even if the dtor doesn’t do anything <br>
If a subclass is NOT meant to have subclasses, declare it <code>final</code>:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Y final: <span class="hljs-keyword">public</span> X{
    ...
};</code></pre></body>
</html>

<!--
2: Using highlight.js
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CS 246</title>
<link rel="stylesheet" type="text/css" href="https://www.dropbox.com/s/atz4kqwayz4hlhk/markDown.css?raw=1">
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script> 
</head>
<body><h1 id="cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</h1>

<blockquote>
  <p>Brad Lushman <br>
  Office: DC 3110 <br>
  Email: bmlushma <br>
  <a href="http://www.student.cs.uwaterloo.ca/~cs246">http://www.student.cs.uwaterloo.ca/~cs246</a> <br>
  Linux is required! Ripperino</p>
</blockquote>

<p><div class="toc">
<ul>
<li><a href="#cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</a><ul>
<li><a href="#lecture-1">Lecture 1</a><ul>
<li><a href="#linux-please">Linux, Please</a></li>
<li><a href="#module-1-linux-shell">Module 1 - Linux Shell</a></li>
<li><a href="#linux-file-system">Linux File System</a></li>
<li><a href="#pipes">Pipes</a></li>
</ul>
</li>
<li><a href="#lecture-2">Lecture 2</a><ul>
<li><a href="#pipes-cont">Pipes Cont.</a></li>
<li><a href="#pattern-matching-in-text-files">Pattern-Matching in Text Files</a></li>
<li><a href="#permissions">Permissions</a></li>
</ul>
</li>
<li><a href="#lecture-3">Lecture 3</a><ul>
<li><a href="#shell-scripts">Shell Scripts</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#loops">Loops</a></li>
</ul>
</li>
<li><a href="#lecture-4">Lecture - 4</a><ul>
<li><a href="#se-topic-testing">SE Topic: Testing</a></li>
<li><a href="#module-2-c">Module 2: C++</a></li>
<li><a href="#compiling-c-programs">Compiling C++ programs</a></li>
<li><a href="#inputoutput">Input/Output</a></li>
</ul>
</li>
<li><a href="#lecture-5">Lecture 5</a><ul>
<li><a href="#reading-strings">Reading Strings</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#string-operations">String Operations:</a></li>
<li><a href="#default-fn-params">Default f’n Params</a></li>
<li><a href="#overloading">Overloading</a></li>
</ul>
</li>
<li><a href="#lecture-6">Lecture 6</a><ul>
<li><a href="#structs">Structs</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#parameter-passing">Parameter Passing</a></li>
<li><a href="#references">References</a></li>
<li><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
</ul>
</li>
<li><a href="#lecture-7">Lecture 7</a><ul>
<li><a href="#operator-overloading">Operator Overloading</a></li>
<li><a href="#overloading-and">Overloading &lt;&lt; and &gt;&gt;</a></li>
<li><a href="#the-preprocessor">The Preprocessor</a></li>
<li><a href="#separate-compilation">Separate Compilation</a></li>
<li><a href="#compiling-separately">Compiling Separately</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</a><ul>
<li><a href="#lecture-8">Lecture 8</a><ul>
<li><a href="#classes">Classes</a></li>
</ul>
</li>
<li><a href="#lecture-9">Lecture 9</a><ul>
<li><a href="#uniform-initialization">Uniform Initialization</a></li>
<li><a href="#destructors">Destructors</a></li>
<li><a href="#copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</a></li>
</ul>
</li>
<li><a href="#lecture-10">Lecture 10</a><ul>
<li><a href="#rvalues-rvalue-references">Rvalues + Rvalue References</a></li>
<li><a href="#copymove-elision">Copy/Move Elision</a></li>
</ul>
</li>
<li><a href="#lecture-10-1">Lecture - 10</a><ul>
<li><a href="#separate-compilation-for-classes">Separate Compilation for Classes</a></li>
<li><a href="#arrays-of-objects">Arrays of Objects</a></li>
<li><a href="#const-objects">Const Objects</a></li>
<li><a href="#static-fields-methods">Static Fields + Methods</a></li>
<li><a href="#static-member-functions">Static Member Functions</a></li>
<li><a href="#invariants-encapsulation">Invariants + Encapsulation</a></li>
</ul>
</li>
<li><a href="#cs-246-tut-5">CS 246 TUT 5</a></li>
<li><a href="#lecture-12">Lecture 12</a><ul>
<li><a href="#se-topic-design-patterns">SE Topic: Design Patterns</a></li>
<li><a href="#tools-topic-make">Tools topic: make</a></li>
</ul>
</li>
<li><a href="#lecture-13">Lecture 13</a><ul>
<li><a href="#makefile">Makefile</a></li>
<li><a href="#system-modelling">System Modelling</a></li>
<li><a href="#aggegation">Aggegation</a></li>
<li><a href="#inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</a></li>
</ul>
</li>
<li><a href="#lecture-14">Lecture 14</a><ul>
<li><a href="#destructor-revisited">Destructor Revisited</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>



<h2 id="lecture-1">Lecture 1</h2>



<h3 id="linux-please">Linux, Please</h3>

<blockquote>
  <p>Options: <br>
  1. Lab, computers <br>
  2. Install Linux on your machine <br>
  3. ssh into school machines (recommended) (Windows: download putty.exe, winscp for file transfer) <br>
  4. Cygwin - ewwwwwww <br>
  Also - install an xwindows server. eg. XMing</p>
</blockquote>

<p>Modules:  <br>
1 - Linux Shell (2 weeks) <br>
2 - C++ (10 weeks) <br>
3 - Tools (interspersed) <br>
4 - Software engineering (interspersed)</p>

<p>Homework: Print Linux handout from Piazza, and bring it to class</p>



<h3 id="module-1-linux-shell">Module 1 - Linux Shell</h3>

<blockquote>
  <p>Shell - interface to OS - get the OS to do things - run programs, manage files - graphical shell (clicking with mouse/ touch interface) - command line - type commands at a prompt - more versatile</p>
</blockquote>

<p>This course: bash</p>

<p>Make sure you are using bash! - Log in + type echo $0 <br>
- should say bash</p>



<h3 id="linux-file-system">Linux File System</h3>

<p>Working with files <br>
- cat - displays the contents of a file <br>
- cat /usr/share/dict/words <br>
- general format: root (top) directory/ directories (contains files)/ file</p>

<blockquote>
  <p>In Linux, a directory is considered a kind of file</p>
</blockquote>

<p><code>^C</code> to stop a program <br>
ls : list files in current dir (non-hidden files) <br>
ls -a : gives all files (even hidden ones) <br>
hidden files start with a dot <br>
pwd - prints current directory</p>

<p>What happens if you type cat? <br>
- waits for input <br>
- prints everything you type <br>
Useful? - if we can capture input in file. <br>
Observe: </p>

<p><code>cat &gt; output.txt</code></p>

<p>To stop: Ctrl - D (^D) at the beginning of a line sends an end of file signal <br>
In general: command args &gt; file ; executes command args + captures the output in file <br>
- called <strong><em>output redirection</em></strong></p>

<p>Can also redirect input:</p>

<p><code>cat &lt; inputfile.txt</code></p>

<ul>
<li>takes input from inputfile.txt instead of keyboard</li>
<li>displays inputfile.txt</li>
<li>seems equal to cat inputfile.txt</li>
</ul>

<p>What’s the difference?</p>

<p><code>cat inputfile.txt</code></p>

<p>passes the name <code>inputfile.txt</code> as an arg to cat. cat opens the file and displays it</p>

<p><code>cat &lt; inputfile.txt</code></p>

<p>SHELL opens <code>inputfile.txt</code> and passes the contents to cat in place of keyboard or input</p>

<p>Observe:</p>



<pre class="prettyprint"><code class=" hljs avrasm">wc output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span> output<span class="hljs-preprocessor">.txt</span>

wc &lt; output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span></code></pre>

<p>Also: <code>cat *.txt</code> &lt;- globbing pattern <br>
(* means match any sequence of chars) <br>
- shell finds all files in the current dir that matches the pattern + substitutes on the cmd line.  <br>
(eg. <code>cat a.txt, b.txt, c.txt</code> - opens all 3 and displays)</p>

<p>More globbing patterns - Linux Sheet <br>
Many, but not all programs accept input either on the command line or by redirection</p>

<p>Can do both redirections <br>
<code>cat &lt; in.txt &gt; out.txt</code></p>

<p>Every process is attached to 3 streams: stdin, stderr, stdout</p>

<dl>
<dt>By default</dt>
<dd>stdin = keyboard - redirect with &lt;</dd>

<dd>stdout, stderr = screen (redirect with &gt;)</dd>

<dt>stderr</dt>
<dd>separate output stream - for error messages</dd>

<dd>so that output + error messages can go to different places</dd>

<dd>so that error msgs don’t clutter output file + corrupt formatting <br>
Also: stdout may be buffered - system may wait to accumulate output before actually printing it ( flushing the buffer)</dd>
</dl>

<p>stderr - never buffered - get errror msgs immediately</p>



<h3 id="pipes">Pipes</h3>

<p>Use output from one program as the input of another</p>

<blockquote>
  <p><strong>Example: How many words occur in the first 20 lines of myfile.txt?</strong> <br>
  Tools (sheet): <br>
  <code>head -n file</code> gives the first n lines of the file <br>
  <code>wc</code> counts words, lines, characters <br>
  <code>wc -w</code> gives just words <br>
  Soln: head -20 myfile.txt | wc -w <br>
  the | is a pipe</p>
</blockquote>



<h2 id="lecture-2">Lecture 2</h2>



<h3 id="pipes-cont">Pipes Cont.</h3>

<p>How many words occur in the first 20 lines of myfile.txt? <br>
Sol’n <code>head -20 myfile.txt | wc -w</code> or <code>cat myfile.txt | head -20 | wc -w</code></p>

<p>Eg. Suppose words1.txt, words2.txt, etc. contain lists of words, one per line. Print a duplicate-free list of all words that occur in any of these lines.</p>

<blockquote>
  <p><strong>uniq</strong> - removes CONSECUTIVE duplicate entries -if entries are sorted, then it removes <em>all</em> duplicates <br>
  <strong>sort</strong> - sorts lines</p>
</blockquote>

<p><code>cat words*.txt | sort | uniq</code></p>

<p>Can we use the output of one program as param of another? (yes)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> <span class="hljs-string">"Today is <span class="hljs-variable">$(date)</span> and I am <span class="hljs-variable">$(whoami)</span>"</span>
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Shell executes date + whoami + substitues the result into the command line <br>
The quotations make it into only ONE arg. Also, whitespace here is used.</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> Today is $(date) and I am           $(whoami)
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Here, echo is given 7 arguments. Whitespace is ignored</p>

<blockquote>
  <p>Careful: </p>
  
  <pre class="prettyprint"><code class=" hljs applescript">echo 'Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)'
&gt; Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)</code></pre>
  
  <p>Single quotes does not make any substitutions.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs delphi">echo *
echo <span class="hljs-string">'*'</span> #outputs the same <span class="hljs-comment">(*)
echo "*" #outputs the same (*)</span></code></pre>



<h3 id="pattern-matching-in-text-files">Pattern-Matching in Text Files</h3>

<dl>
<dt>egrep (“extended global regular expression print”)</dt>
<dd>egrep pattern file - prints every line in a file that contains a match to pattern</dd>
</dl>

<p>eg. Print every line in index.html that contains cs246.</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep cs246 index.html</code></pre>

<p>How many lines in index.html contain cs246 or CS246?</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"cs246|CS246"</span> index.html | wc <span class="hljs-operator">-l</span> //the quotes are really important here since bash thinks | is a pipe otherwise</code></pre>

<p>Alt soln:</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"(cs|CS)246"</span> index.html | wc <span class="hljs-operator">-l</span></code></pre>

<p>Available patterns - called regular expressions (different from globbing patterns)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-string">"(c|C)(s|S)246"</span> -also matches cS246, Cs246
<span class="hljs-string">"[cC][sS]246"</span></code></pre>

<p>[..] - any one char between [ and ] <br>
[<script type="math/tex" id="MathJax-Element-316">\text{^}</script> .. ] - any one char except</p>

<p>Add optional space:  <code>"[cC][sS] ?246"</code> <br>
? = 0 or 1 of the preceding expression (0 or 1 space in this case) <br>
* = 0 or more of preceding </p>



<pre class="prettyprint"><code class=" hljs r"><span class="hljs-string">"(cs)*246"</span>
&gt; <span class="hljs-number">246</span>, cs246, cscs246 <span class="hljs-keyword">...</span></code></pre>

<p>. = any single character <br>
.* = anything</p>



<pre class="prettyprint"><code class=" hljs perl">egrep <span class="hljs-string">"cs.<span class="hljs-variable">*246</span>"</span> <span class="hljs-keyword">index</span>.html</code></pre>

<ul>
<li>lines containing cs(anything) 246</li>
<li>^, $ - beginning + end of a line <br>
<code>"^cs246"</code> - lines that start with 246 <br>
<code>"^cs246$"</code> - lines that are exactly 246 <br>
+ = 1 or more occurrences of preceding pattern <br>
.+ - non-empty.</li>
</ul>

<p>Eg lines of even length</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-string">"^(..)*$"</span></code></pre>

<p>Files in the current dir whose names contain exactly one a.</p>



<pre class="prettyprint"><code class=" hljs 1c">ls <span class="hljs-string">| egrep "</span>[^a]*a[^a]*<span class="hljs-string">"</span></code></pre>

<p>All words in the global dictionary that start with e and have 5 characters</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">egrep <span class="hljs-string">"^e....$"</span> /usr/share/dict/<span class="hljs-keyword">words</span></code></pre>



<h3 id="permissions">Permissions</h3>

<p><code>ls - l</code> - “long form” listening</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-attribute">-rw</span><span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span> <span class="hljs-number">1</span> j2smith j2smith <span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span> abc<span class="hljs-built_in">.</span>txt
(<span class="hljs-subst">-</span>)<span class="hljs-keyword">type</span><span class="hljs-subst">|</span>(rw<span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span>)permissions<span class="hljs-subst">|</span>(<span class="hljs-number">1</span>)<span class="hljs-variable">#of</span> links<span class="hljs-subst">|</span> (j2smith) owner<span class="hljs-subst">|</span> (j2smith) <span class="hljs-keyword">group</span><span class="hljs-subst">|</span> (<span class="hljs-number">25</span>) size <span class="hljs-subst">|</span> (<span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>) last modified <span class="hljs-subst">|</span> (abc<span class="hljs-built_in">.</span>txt) name</code></pre>

<dl>
<dt>groups</dt>
<dd>a user can belong to one or more groups</dd>

<dd>a file can be associated with one group</dd>

<dt>type</dt>
<dd><code>-</code> an ordinary file</dd>

<dd><code>d</code> directory</dd>

<dt>permissions</dt>
<dd><code>rwxrwxrwx</code> -&gt; 1st rwx bits are “user bits”, then next 3 are “group bits”, last is “other bits” <br>
<strong>Apply to:</strong> <br>
- user bits: file’s owner <br>
- group bits: members of the file’s group other than the owner <br>
- other bits: everyone else <br>
<code>r</code> - read bit <br>
<code>w</code> - write bit <br>
<code>x</code> - execute bit</dd>
</dl>

<table>
<thead>
<tr>
  <th>Bit</th>
  <th>Meaning for Ordinary Files</th>
  <th>Meaning for directories</th>
</tr>
</thead>
<tbody><tr>
  <td>r</td>
  <td><code>files contents can be read</code></td>
  <td><code>directory's contents can be read (eg. ls works, globbing, tab completion)</code></td>
</tr>
<tr>
  <td>w</td>
  <td><code>files contents can be modified</code></td>
  <td><code>directory's contents can be modified</code></td>
</tr>
<tr>
  <td>x</td>
  <td><code>file can be executed as a program</code></td>
  <td><code>directory can be navigated (i.e. can cd into the dir)</code></td>
</tr>
</tbody></table>


<blockquote>
  <p>dir’s exec. bit not set = no access at all to the dir, nor to any subdir, nor to any file within it. <br>
  Changing permissions: <code>chmod mode file</code></p>
</blockquote>

<p>Mode:</p>

<table>
<thead>
<tr>
  <th></th>
  <th></th>
  <th></th>
</tr>
</thead>
<tbody><tr>
  <td>u - user</td>
  <td><ul>
add perm
</ul></td>
  <td>r read</td>
</tr>
<tr>
  <td>g - group</td>
  <td><ul>
remove perm
</ul></td>
  <td>w write</td>
</tr>
<tr>
  <td>o - other</td>
  <td>= set perm</td>
  <td>x execute</td>
</tr>
<tr>
  <td>a- all</td>
  <td></td>
  <td></td>
</tr>
</tbody></table>


<p>eg.  <br>
give others read permission: chmod o+r file  <br>
make everyone’s permission rx: a = rx <br>
give owner full control: u = rwx or u+rwx</p>

<blockquote>
  <p>Changing permissions - &gt; exclusive right of the owner</p>
</blockquote>



<h2 id="lecture-3">Lecture 3</h2>



<h3 id="shell-scripts">Shell Scripts</h3>

<blockquote>
  <p>files containing sequences of shell commands, executed as programs</p>
</blockquote>

<p>eg. Print date, current user, current dir</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-comment">#!/bin/bash //"shebang" line - executes this file as a bash script</span>
date
whoami
<span class="hljs-built_in">pwd</span></code></pre>

<blockquote>
  <p>Note: the script does not have the execute bit turned on. Give the file execute permission: <code>chmod u+x myscript</code> <br>
  Run the file: <code>./myscript</code></p>
</blockquote>



<h3 id="variables">Variables</h3>

<p><code>x=1</code> (NO spaces)</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
&gt; <span class="hljs-number">1</span></code></pre>

<blockquote>
  <p>Note: use <script type="math/tex" id="MathJax-Element-317"> when fetching the value of a var  
  No </script> when setting a var. <br>
  Good practice: <script type="math/tex" id="MathJax-Element-318">{x}  
  All vars contain STRINGS. x is the string 1  
  Eg. dir=~cs246  
  echo </script>{dir}</p>
</blockquote>

<p>Some “global” vars available: <br>
Important: PATH - list of dirs; When you type a command, the shell searches these directories in order for a program with that name</p>

<blockquote>
  <p>Eg. Check whether a word is in the directory <br>
  eg. <code>./isItAWord hello</code></p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/shar/dict/words</code></pre>

<blockquote>
  <p>Prints nothing if word not found <br>
  Prints the word if found</p>
</blockquote>

<p>Eg. - a good password should not be in the dictionary <br>
answer whether a word is a good password</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/share/dict/words &gt; /dev/null //(suppresses output)
<span class="hljs-keyword">if</span> [ $? <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> ]; <span class="hljs-keyword">then</span> //the ; here allows you to put the <span class="hljs-keyword">then</span> on the same line
    <span class="hljs-built_in">echo</span> Bad password
<span class="hljs-keyword">else</span> 
    <span class="hljs-built_in">echo</span> Maybe a good password
<span class="hljs-keyword">fi</span> //ends the <span class="hljs-keyword">if</span>?</code></pre>

<p>Note: every program returns a status code when finished <br>
egrep: returns 0 if found, 1 if not found (In Linux: 0 is success, non-0 is fail)</p>

<p>$? = status of the most recently executed command</p>

<p>Verify # of args ; print error msg if wrong</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">usage</span></span>(){
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> password"</span> &gt;&amp;<span class="hljs-number">2</span>
}
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> <span class="hljs-operator">-ne</span> <span class="hljs-number">1</span>]; <span class="hljs-keyword">then</span>
    usage
    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">fi</span>
...(as before)</code></pre>



<pre class="prettyprint"><code class=" hljs r">If stmt: //comparisons + other conditions handout
    <span class="hljs-keyword">if</span> [ cond ]; then
        <span class="hljs-keyword">...</span>
    elif [ cond ]; then
        <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">...</span>
fi</code></pre>



<h3 id="loops">Loops</h3>

<p>Print #’s from 1 to $1</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
x=<span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> [ <span class="hljs-variable">$x</span> -le <span class="hljs-variable">$1</span>]; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
    x=<span class="hljs-variable">$x</span>+<span class="hljs-number">1</span>
<span class="hljs-keyword">done</span></code></pre>

<p>This gives you “1+1” literally if x=1 <br>
you want $((…)) for arithmetic instead</p>

<p>Looping over a list <br>
eg. Rename all .cpp files to .cc</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *.cpp; <span class="hljs-keyword">do</span>
    mv <span class="hljs-variable">${name}</span> <span class="hljs-variable">${name%cpp}</span>cc
<span class="hljs-keyword">done</span></code></pre>

<blockquote>
  <p>note: <br>
  *.cpp -&gt; glob - replaced with all matching files  <br>
  name%cpp is the val of name, without the trailing cpp.</p>
</blockquote>

<p>How many times does word <script type="math/tex" id="MathJax-Element-319">1 appear in file </script>2?</p>



<pre class="prettyprint"><code class=" hljs bash">x=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$2</span>); <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span> = <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]; <span class="hljs-keyword">then</span>
        x=$((x+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span></code></pre>

<blockquote>
  <p>Payday is the last Friday of the month. When is this month’s payday? <br>
  2 tasks: Compute date <br>
               Report answer</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">answer</span></span>(){
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month is the 31st"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month: the <span class="hljs-variable">${1}</span>th"</span>
}<span class="hljs-keyword">fi</span>
answer $(cal | awk <span class="hljs-string">'{print $6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<p>Generalize to any month. <code>cal October 2016</code> -gives Oct’s calendar <br>
let payday October 2016 give october’s payday</p>

<p>ALL OF THESE ARE IN THE REPO</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-function"><span class="hljs-title">answer</span></span>(){
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$2</span> ]; <span class="hljs-keyword">then</span>
        preamble=<span class="hljs-variable">$2</span>
    <span class="hljs-keyword">else</span>
        preamble = <span class="hljs-string">"This month"</span>
    <span class="hljs-keyword">fi</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble}</span>: the 31st"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble: the ${1}</span>th}"</span>
    <span class="hljs-keyword">fi</span>
}
answer $(cal <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> | awk <span class="hljs-string">'{print #6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<blockquote>
  <p>note: no such thing as scope. You can reference from anywhere. if the var doesn’t exist, you get a blank.</p>
</blockquote>



<h2 id="lecture-4">Lecture - 4</h2>



<h3 id="se-topic-testing">SE Topic: Testing</h3>

<ul>
<li>essential part of program development</li>
<li>on going  <br>
<ul><li>not just at the end</li>
<li>Begins <strong>before</strong> you start coding</li>
<li>Test suites - expected behaviour <br>
<script type="math/tex" id="MathJax-Element-320">\neq</script> debugging - cannot debug without first testing</li></ul></li>
<li>cannot guarantee correctness - cannot prove wrongness</li>
<li>ideally, developer + tester should be different people</li>
</ul>

<p>Human testing </p>

<ul>
<li>humans look over code, find flaws</li>
<li>code inspections, walk throughs</li>
<li>not on your assignments</li>
</ul>

<p>Machine testing</p>

<ul>
<li>run program on selected input, check against spec</li>
<li>can’t check everything <br>
<ul><li>choose test cases carefully</li></ul></li>
</ul>

<p>Black/White/Grey Box Testing</p>

<ul>
<li>no/full/some knowledge of implementation</li>
</ul>

<p>Start with black box, supplement with white box</p>

<p>Black box:</p>

<ul>
<li>various classes of input <br>
<ul><li>numeric ranges</li>
<li>positive vs. negative</li></ul></li>
<li>boundaries of valid ranges (edge cases)</li>
<li>multiple simultaneous boundaries (corner cases)</li>
<li>intuition/experience - guess at likely errors</li>
<li>extreme cases</li>
</ul>

<p>White box:</p>

<ul>
<li>execute all logical paths through the program</li>
<li>make sure every f’n runs</li>
</ul>

<p>Performance testing - is the program efficient enough? <br>
Regression testing</p>

<ul>
<li>make sure new changes to program don’t break old test caes</li>
<li>test suites, testing scripts</li>
</ul>



<h3 id="module-2-c">Module 2: C++</h3>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">//Hello world in C:</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Hello world in C++:</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hello world"</span> &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>Notes: main <strong>must</strong> return int in C++ (if no return in main, 0 is implied)</p>
</blockquote>

<ul>
<li><code>stdio.h</code> , <code>printf</code> still available in c++</li>
<li>preferred C++ <code>I/O</code> header <code>&lt;iostream&gt;</code></li>
</ul>

<p>Output: <br>
std::cout &lt;&lt; ___ &lt;&lt; ___ &lt;&lt; ___ (___ is data) <br>
std::endl = end of line</p>

<ul>
<li>using namespace std: <br>
<ul><li>lets you say cout/endl instead of std::cout/std::endl</li></ul></li>
</ul>



<h3 id="compiling-c-programs">Compiling C++ programs</h3>

<p><code>g++-5 -std=c++14 program.cc &lt;-o program&gt; (name of the excutable(by default, a.out))</code></p>

<p>OR</p>

<p><code>g++14 program.cc -o program</code> <br>
<code>./program</code></p>



<h3 id="inputoutput">Input/Output</h3>

<p>3 I/O streams: </p>

<ul>
<li>cin - for reading from stdin</li>
<li>cout, cerr - for printing to stdout, stderr</li>
</ul>

<p>I/O operators:</p>

<ul>
<li>&lt;&lt; “put to” (output)</li>
<li>&gt;&gt; “get from” (input)</li>
<li>cerr &lt;&lt; x;</li>
<li>cin &gt;&gt; x; <br>


<blockquote>
  <p>operator points in the direction of information flow</p></blockquote></li>
  </ul> <br>
  E.g. Add 2#’s







<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> nanospace <span class="hljs-built_in">std</span>
<span class="hljs-comment">//above two lines are usually there even if teach doesn't write it (omit from now on)</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;
    <span class="hljs-built_in">cout</span> &lt;&lt; x + y &lt;&lt; endl;
}</code></pre>




<blockquote>
  <p>notes: <code>cin &gt;&gt; ignores whitespace</code> <br>
  what if input doesn’t contain an int? -statement fails, value of var is undefined</p>
</blockquote>

What if the input is exhausted before we get two ints?

<ul>
<li>same as before</li>
</ul>

<hr>

<p>If the read failed: <code>cin.fail()</code> will be true <br>
If EOF: <code>cin.eof()</code> and <code>cin.fail()</code> will both be true</p>

<ul>
<li>but not until attempted read fails</li>
</ul>

<p>Ex: read all ints from stdin, echo them and per line to std out. Stop on any failure.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &gt;&gt; i;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.fail()) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: Here is an implicit conversion from cin to bool</p>
  
  <ul>
  <li>cin can be used as a condition - true if success, false if failed</li>
  </ul>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v2.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &lt;&lt; i;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cin</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: &gt;&gt; is c’s right bitshift operator. <code>a &gt;&gt; b</code> shifts  a’s bits to the right by b spots. <br>
  E.g. 21 &gt;&gt; 3 -&gt; 21 = 10101 shifted 3 =<script type="math/tex" id="MathJax-Element-321">10_{\text(binary)}</script> = 2 <br>
  But when LHS is cin, &gt;&gt; is “get from”</p>
</blockquote>

<p>operator &gt;&gt;: </p>

<ul>
<li>inputs: cin (stream), data (variety of types)</li>
<li>output? - returns cin (istream)</li>
</ul>

<p>This is why we can write <code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</code> the &gt;&gt; returns cin as each &gt;&gt; is calculated, which allows y and z to also be read in.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v3.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v4.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; i){
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<h2 id="lecture-5">Lecture 5</h2>

<p>Ex: Read ints + echo to stdout until EOF. Skip all non-int input</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)){
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.eof()) <span class="hljs-keyword">break</span>;
            <span class="hljs-built_in">cin</span>.clear(); <span class="hljs-comment">//clears the fail bit</span>
            <span class="hljs-built_in">cin</span>.ignore(); <span class="hljs-comment">//skips the next char (because the char causing this to fail is still there)</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt;i &lt;&lt; endl;
    }
}</code></pre>



<h3 id="reading-strings">Reading Strings</h3>

<p><code>type std::string (#include &lt;string&gt;)</code></p>

<ul>
<li>more details later</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s; <span class="hljs-comment">//skip leading whitespace (stop at whitespace)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">//(therefore only reads one word)</span>
}</code></pre>

<p>If we want the whitespace: <code>getline(cin, s);</code></p>

<ul>
<li>reads from current position to next newline into s.</li>
</ul>

<p><code>cout &lt;&lt; 95 &lt;&lt; endl;</code></p>

<p>What if we want to print a # in hexadecimal?</p>

<p><code>cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; endl; \\prints 5f</code></p>

<blockquote>
  <p>hex : I/O manipulator - all subsequent ints printed in hex</p>
</blockquote>

<p><code>cout &lt;&lt; dec</code> to go back to decimal</p>

<p>Other manipulators - notes <code>#include &lt;iomanip&gt;</code></p>

<p>Stream abstraction applies to other sources of data</p>

<p>Files </p>

<ul>
<li>Read from a file instead of stdin</li>
<li>std::ifstream - read from a file</li>
<li>std::ofstream - write to a file</li>
</ul>

<p>File access in C:</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">char</span> s[<span class="hljs-number">256</span>];
    FILE *file = fopen(<span class="hljs-string">"myfile.txt"</span>,<span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">"%255s"</span>, s);
        <span class="hljs-keyword">if</span>(feof(file)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    }
    fclose(file);
}</code></pre>

<p>C++:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    ifstream file{<span class="hljs-string">"myfile.txt"</span>}; <span class="hljs-comment">// Initialization syntax. Declaring an ifstream opens the file</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(file &gt;&gt; s){
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
    } <span class="hljs-comment">// file is closed automatically as soon as the ifstream (file) goes out of scope :o woah</span>
}</code></pre>

<blockquote>
  <p>note: This is the same as reading from cin in c++ except we use file in the while loop.</p>
</blockquote>

<p>Anything you can do with cin/cout, you can also do with an ifstream/ofstream.</p>

<p>Example - strings - attach a stream to a string var + read from/write to it</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include&lt;sstream&gt;</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span>
<span class="hljs-comment">//-read from/write to a string</span>
<span class="hljs-keyword">int</span> lo = _____, hi = _____;
<span class="hljs-built_in">ostringstream</span> ss;
ss &lt;&lt; <span class="hljs-string">"Enter a # btwn "</span> &lt;&lt; lo &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; hi;
<span class="hljs-built_in">string</span> s = ss.str();</code></pre>

<p>Eg - convert string to #</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter a # "</span> &lt;&lt;endl;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s;
    (<span class="hljs-built_in">string</span> stream ss {s}); <span class="hljs-comment">// {s} &lt;- initialization</span>
    <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"I said, "</span>;
}
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"You entered "</span> &lt;&lt; n &lt;&lt; endl;</code></pre>

<p>Example revisited: Echo #’s, skip non-#’s</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; s){
        <span class="hljs-built_in">istringstream</span> ss {s};
        <span class="hljs-keyword">int</span> n;
        <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
    }
}</code></pre>



<h3 id="strings">Strings</h3>

<p>In C: </p>

<ul>
<li>array of char (char* or char[]) terminated by ‘\0’</li>
<li>explicitly manage memory - allocate more as strings get larger</li>
<li>easy to overwrite \0 and corrupt memory</li>
</ul>

<p>C++ strings:</p>

<ul>
<li>grow as needed (no memory management)</li>
<li>safer to manipulate</li>
</ul>

<p>Eg: string s = “Hello”; // still a c-style string (char array with \0)</p>

<blockquote>
  <p>s  -  c++ string created from the c string on initialization</p>
</blockquote>



<h3 id="string-operations">String Operations:</h3>

<p>Equality - s1 == s2, s1 != s2 <br>
Comparison - s1 &lt;= s2 (lexicographic) <br>
Get individual chars - s[0] , s[1], … etc <br>
Concat: s3 = s1 + s2;   s3 += s4</p>



<h3 id="default-fn-params">Default f’n Params</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> printWordsInFile(<span class="hljs-built_in">string</span> name = <span class="hljs-string">"suite.txt"</span>){
    ifstream file {name};
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (file &gt;&gt; s) <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
}
printWordsInFile(<span class="hljs-string">"suite2.txt"</span>);
printWordsInFile(); <span class="hljs-comment">//uses stuite.txt</span></code></pre>

<blockquote>
  <p>Note: Optional parameters must be LAST</p>
</blockquote>



<h3 id="overloading">Overloading</h3>

<p>C:</p>

<ul>
<li><code>int negInt(int n) {return -n;}</code></li>
<li><code>bool negBool(bool b) {return !b;}</code></li>
</ul>

<p>C++</p>

<p>F’ns with different param lists can share the same name <br>
<code>int neg(int n) {return -n;}</code> <br>
<code>bool neg(bool b) {return !b;}</code></p>

<p>Compiler uses # + type of args to decide which neg is being called <br>
Overloads must differ in # or types of args - may not differ on just return type</p>



<h2 id="lecture-6">Lecture 6</h2>



<h3 id="structs">Structs</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node next; <span class="hljs-comment">//what's wrong? This makes the struct have no finite size since</span>
    <span class="hljs-comment">// this contains a node in a node in a node ... etc which has no calculable size</span>
};</code></pre>



<h3 id="constants">Constants</h3>

<p><code>const int maxGrade = 100; // must be initialized</code></p>

<p><code>Node n1 = {5, nullptr}; \\syntax for a null ptr. Do not say NULL or 0 in this class</code></p>

<p><code>const Node n2=n1</code></p>

<ul>
<li>immutable copy of n1</li>
<li>can’t change n2’s fields</li>
</ul>



<h3 id="parameter-passing">Parameter Passing</h3>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> n){++n;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 5</span></code></pre>

<p>call-by-value-inc gets a copy of x, increments the copy, original unchanged</p>

<p>If a function needs to modify an arg - pass a ptr</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc(<span class="hljs-keyword">int</span> *n){(*n)++;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(&amp;x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 6</span></code></pre>

<blockquote>
  <p>Q: why cin &gt;&gt; x and not cin &gt;&gt; &amp;x ? <br>
  A: C++ has another ptr-like type: references</p>
</blockquote>



<h3 id="references">References</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> &amp;z = y; <span class="hljs-comment">//z is an lvalue reference to y. Like a const ptr.</span>
<span class="hljs-comment">//similar to int *const z = &amp;y;</span></code></pre>

<p>References are like constant ptrs with automatic de-referencing  <br>
z -&gt; y [10]</p>



<pre class="prettyprint"><code class="language-cpp hljs ">z = <span class="hljs-number">12</span>; <span class="hljs-comment">//(NOT *z = 12)</span>
<span class="hljs-comment">//(now, y == 12)</span>

<span class="hljs-keyword">int</span> *p = &amp;z; <span class="hljs-comment">// gives the address of y</span></code></pre>

<p>In all cases, z behaves exactly like y.</p>

<p>z is an alias (“another name”) for y</p>

<p><strong>Things you can’t do with lvalue references:</strong></p>

<ol>
<li>Leave them uninitialized. eg int &amp;x; <br>
<ul><li>Must be initialized to something that has an address (an lvalue), since refs are ptrs: <code>int &amp;x = 3;</code> X , <code>int &amp;x = y + z;</code> X , <code>int &amp;x = y;</code> Is okay</li></ul></li>
<li>Create a ptr to a reference: <br>
<ul><li><code>int &amp;*x;</code>- for c, always start at var and then go left. So x is a pointer to a ref of an int.</li>
<li>ref to ptr OK: <code>int *&amp;x = ... ;</code></li></ul></li>
<li>Create a reference to a reference <br>
<ul><li><code>int &amp;&amp;x = ... ;</code> - this means something difference (we’ll talk about this later)</li></ul></li>
<li>Create an array of references: <code>int &amp;r[3] = {n,n,n};</code> X</li>
</ol>

<p>What <em>can</em> you do? pass as f’n params:</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> &amp;n){++n;} <span class="hljs-comment">// notice that there's no ptr deref and &amp;n is a const. ptr to the arg.</span>
<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 6</span></code></pre>

<blockquote>
  <p>So why does cin &gt;&gt; x work? - takes x by reference</p>
</blockquote>

<p><code>istream &amp; operator &gt;&gt; (istream &amp;in, int&amp;data)</code></p>

<p>Pass-by-value. eg: <code>int f(int n) { ... } copies the arguement</code></p>

<ul>
<li>if the arg is big, copying can be expensive <br>
eg: <code>struct Really Big { ... }</code>,</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(ReallyBig rb){ ... }; <span class="hljs-comment">// really slow</span>
<span class="hljs-keyword">int</span> g(ReallyBig &amp;rb){ ... }; <span class="hljs-comment">// &amp;rb is now an alias - fast. Downside is that rb can be changed by the f'n. You don't know.</span>
<span class="hljs-keyword">int</span> h(<span class="hljs-keyword">const</span> ReallyBig &amp;rb) { ... }; <span class="hljs-comment">// really fast and param can't be changed. woah</span></code></pre>

<p>Advice: prefer pass-by-const-ref over pass-by-value for anything larger than a ptr - unless the f’n needs to make a copy anyway. Then, maybe pass-by-value.</p>

<p>Also: <code>int f(int &amp;n) { ... }</code>      <code>int g(const int &amp;n) { ... }</code></p>



<pre class="prettyprint"><code class="language-cpp hljs ">f(<span class="hljs-number">5</span>); <span class="hljs-comment">// won't compile. can't initialize an lvalue ref (n) to a literal value. if n changes, can't change the literal 5.</span>
g(<span class="hljs-number">5</span>); <span class="hljs-comment">//is a-OK since n can never be changed. Compiler allows this. How? compiler creates a temp location to hold the 5, so the reference n has something to point to.</span></code></pre>



<h3 id="dynamic-memory-allocation">Dynamic Memory Allocation</h3>

<p>C: </p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>( ... *<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
...
<span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//DON'T USE THESE IN C++</span></code></pre>

<blockquote>
  <p>Instead: new/delete - type aware and less error-prone</p>
</blockquote>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};

Node *np = <span class="hljs-keyword">new</span> Node;
...
<span class="hljs-keyword">delete</span> np;</code></pre>

<ul>
<li>all local vars reside on the stack - vars are deallocated when they go out of scope (stack is popped).</li>
<li>allocated memory resides on the heap.</li>
<li>remains allocated until delete is called</li>
<li>if you don’t delete all allocated memory - memory leak</li>
<li>program will eventually fail - incorrect behaviour</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">10</span>];
...
<span class="hljs-keyword">delete</span> [np];</code></pre>



<pre class="prettyprint"><code class=" hljs coffeescript">Node getMeANode(){ <span class="hljs-regexp">//</span><span class="hljs-keyword">return</span>-<span class="hljs-keyword">by</span>-value = copy. expensive?
    Node n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-regexp">//</span>-<span class="hljs-keyword">return</span> <span class="hljs-keyword">by</span> ptr(ret) instead?
Node *getMeANode(){
    Node n;
    <span class="hljs-keyword">return</span> &amp;n;
    <span class="hljs-regexp">//</span>BAD - returns a ptr to stack - allocated data which <span class="hljs-keyword">is</span> dead <span class="hljs-literal">on</span> <span class="hljs-keyword">return</span>
}

Node *getMeANode(){ <span class="hljs-regexp">//</span>Ok - returns a ptr to Heap data - still alive - but don<span class="hljs-string">'t forget to delete it!
    return new Node;
}</span></code></pre>



<h2 id="lecture-7">Lecture 7</h2>



<h3 id="operator-overloading">Operator Overloading</h3>

<p>Give meanings to c++ operators for our own types <br>
eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    Vec v={v1.x + v2.x , v1.y + v2.y};
    <span class="hljs-keyword">return</span> v;
}

Vec <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> {k*v.x, k*v.y} <span class="hljs-comment">//okay since compiler knows that it's a vec based on the return type</span>
}
<span class="hljs-comment">// this only works when scalar is on the left (eg. k*v). To get v*k, we need to make another function.</span>
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Vec &amp;v, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k){
    <span class="hljs-keyword">return</span> k*v;
}</code></pre>



<h3 id="overloading-and">Overloading &lt;&lt; and &gt;&gt;</h3>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Grade{
    <span class="hljs-keyword">int</span> theGrade;
};

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Grade &amp;g){
    out &lt;&lt; g.theGrade &lt;&lt; <span class="hljs-string">'%'</span>;
    <span class="hljs-keyword">return</span> out
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, Grade &amp;g){
    in &gt;&gt; g.theGrade;
    <span class="hljs-keyword">if</span>(g.theGrade &lt; <span class="hljs-number">0</span>) g.theGrade=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(g.theGrade&gt;<span class="hljs-number">100</span>) g.theGrade=<span class="hljs-number">100</span>;
    <span class="hljs-keyword">return</span> in;
}</code></pre>



<h3 id="the-preprocessor">The Preprocessor</h3>

<p>Transforms the program before the compiler sees it. #<script type="math/tex" id="MathJax-Element-322">\text{_____}</script> = preprocessor directive</p>

<p>eg.<code>#include</code> <br>
Including old C headers - new naming convention <br>
eg. Instead of <code>#include &lt;stdio.h&gt;, use #include&lt;cstdio&gt;</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define VAR VALUE <span class="hljs-comment">//- sets a preprocessor variable, then all occurrences of VAR in the source file are replaced with VALUE</span></span>
<span class="hljs-preprocessor">#define MAX 10</span>
<span class="hljs-keyword">int</span> x[MAX] <span class="hljs-comment">//transformed to int x[10]. Was a cheap way of const from the old days (1970s) before const was a thing</span>

<span class="hljs-preprocessor">#define FLAG <span class="hljs-comment">//sets the variable FLAG; Value is the empty string</span></span></code></pre>

<p>Defined constants are useful for conditional compilation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define IOS 1</span>
<span class="hljs-preprocessor">#define BBOS 2</span>
<span class="hljs-preprocessor">#define OS IOS <span class="hljs-comment">//(or BBOS)</span></span>
<span class="hljs-preprocessor">#if OS==IOS</span>
    <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//Removed if OS!=IOS</span>
<span class="hljs-preprocessor">#elif OS==BBOS</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//this code is removed if OS!=BBOS</span>
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>Special Case</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#if 0 <span class="hljs-comment">//never true - all inner text is removed before it gets to the compiler</span></span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-comment">//heavy-duty "comment out"</span></code></pre>

<p>Can also define symbols via compiler arguments</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class="language-bash hljs ">g++<span class="hljs-number">14</span> -DX=<span class="hljs-number">15</span> define.cc -o define</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifdef NAME <span class="hljs-comment">//true if NAME has been defined</span></span>
<span class="hljs-preprocessor">#ifndef NAME <span class="hljs-comment">//true if NAME HAS NOT been defined</span></span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-preprocessor">#ifdef DEBUG</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"setting x=1"</span> &lt;&lt;endl;
    <span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(x&lt;<span class="hljs-number">10</span>){
        ++x;
        <span class="hljs-preprocessor">#ifdef DEBUG</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x is now"</span> &lt;&lt; endl;
        <span class="hljs-preprocessor">#endif</span>
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class=" hljs lua">gc++<span class="hljs-number">14</span> -DDEBUG <span class="hljs-built_in">debug</span>.cc -o <span class="hljs-built_in">debug</span>
//enables <span class="hljs-built_in">debug</span> output</code></pre>



<h3 id="separate-compilation">Separate Compilation</h3>

<p>Split program into composable modules, with</p>

<dl>
<dt>Interface</dt>
<dd>type definitions, prototypes for functions - .h file</dd>

<dt>Implementation</dt>
<dd>full definitions of functions - .cc file</dd>

<dt><em>Recall</em>: declaration</dt>
<dd>asserts existence</dd>

<dd>def’n - full details - allocates space (for vars/f’ns)</dd>
</dl>

<p>E.g. Interface (vec.h)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}
Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> main(){
    Vec v = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
    v = v+v;
    ...
}
<span class="hljs-comment">//implied vec.cc</span>

<span class="hljs-preprocessor">#include "vec.h" <span class="hljs-comment">//we include vec.h here because we don't know what a vec is.</span></span>
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
     ...
     ...
     ...
}</code></pre>

<blockquote>
  <p>Recall: an entity can be declared many times, but defined at most once</p>
</blockquote>



<h3 id="compiling-separately">Compiling Separately</h3>



<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">vec</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span>
<span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">main</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span></code></pre>

<blockquote>
  <p><code>-c</code> -&gt; means compile only, do not link, do not build the executable. Produces an object file.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs avrasm">g++<span class="hljs-number">14</span> vec<span class="hljs-preprocessor">.o</span> main<span class="hljs-preprocessor">.o</span> -o main</code></pre>



<h1 id="never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</h1>

<p>Global var: <code>int globalNum;</code></p>



<h2 id="lecture-8">Lecture 8</h2>

<p>vec.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
};
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> globalVar;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);</code></pre>

<p>vec.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> global Num;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    ...
}</code></pre>

<p>Let’s write a linear algebra module <br>
linalg.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>linalg.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>The above won’t compile:</p>

<ul>
<li>main.cc, linalg.cc include linalg.h, vec.h, linalg.h includes vec,h</li>
<li>main.cc, linalg.cc get 2 copies of vec.h therefore struct vec defined twice. x</li>
</ul>

<blockquote>
  <p>Need to prevent files from being included twice</p>
</blockquote>

<p>Sol’n: “include guard:” <br>
vec.h </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifndef VEC_H</span>
<span class="hljs-preprocessor">#define VEC_H</span>
... file contents
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>first time vec.h is included. Symbol VEC_H is not defined so file is included. After that, symbol is defined so vec.h is never included twice.</p>

<p>Always - put include guards in .h files <br>
Never - include .cc files - many many different functions. Included .cc file, you defined everything again and again and again.</p>

<p>Never - put using namespace std in header files. This directive would be forced on any client that includes this file <br>
- inside header files, always say std::cin, std::string etc.</p>



<h3 id="classes">Classes</h3>

<ul>
<li>can put functions inside of structs</li>
</ul>

<p>eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> assns*<span class="hljs-number">0.4</span> + mt*<span class="hljs-number">0.2</span> + final*<span class="hljs-number">0.4</span>;
    }
};
Student s{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; s.grade() &lt;&lt; endl;</code></pre>

<p>class </p>

<ul>
<li>a struct type that can contain f’ns</li>
<li>c++ has a class keyword - we will use it later</li>
</ul>

<p>object</p>

<ul>
<li>an instance of a class</li>
</ul>

<p>eg: <code>Student</code> - class, <code>s</code> - object, <code>{60, 70, 80}</code></p>

<p>The function grade - called a member function (or method) <br>
What doe assns, mt, final inside of grade ( ) {…} mean? <br>
- they are fields of the current object upon which grade was invoked</p>

<p>e.g. </p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>};
billy.grade(); \\method call uses billy<span class="hljs-string">'s assns, mt, final</span></code></pre>

<p>Formally: methods take a hidden extra parameter called this - ptr to the object on which the method was invoked. eg. billy.grade() &lt;- (this) == &amp;billy <br>
can write</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;assns *<span class="hljs-number">0.4</span> + <span class="hljs-keyword">this</span>-&gt;mt*<span class="hljs-number">0.2</span> + <span class="hljs-keyword">this</span>-&gt;final*<span class="hljs-number">0.4</span>;
    }
};</code></pre>

<p>Initializing Objects</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//ok, but limited</span></code></pre>

<p>Better: Write a method that does initialization: a constructor (ctor)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){...}
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final){
        <span class="hljs-keyword">this</span>-&gt;assns = assns;
        <span class="hljs-keyword">this</span>-&gt;mt = mt;
        <span class="hljs-keyword">this</span>-&gt;final = final;
    }
}

Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//better. Even though this looks the same as above, this calls a ctor if it has been defined. IF no ctor has been defined, these initialize the individual fields of student.</span></code></pre>

<p>Head allocation:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student xpBilly = <span class="hljs-keyword">new</span> Student{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Advantages  of ctors: default params, overloading, sanity checks</p>

<p>eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    Student(in assns = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> mt=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> final=<span class="hljs-number">0</span>){
        <span class="hljs-keyword">this</span>.assns = assns;
        <span class="hljs-keyword">this</span>.mt = mt;
        <span class="hljs-keyword">this</span>.final =final;
    }
}</code></pre>

<blockquote>
  <p>Note: Every class comes with a default (ie no-arg) ctor (which just default constructs all fields that are objects). <br>
  eg.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec v; <span class="hljs-comment">//default ctor (does nothing in this case, the fields aren't objects)</span></code></pre>

<p>But the built-in default ctor goes away if you provide a ctor <br>
E.g.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y){
        <span class="hljs-keyword">this</span>-&gt;x=x;
        <span class="hljs-keyword">this</span>-&gt;y=y;
    }
}
Vec v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}; OK
Vec v; XXXX</code></pre>

<p>What if a struct contains consts or refs?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> MyStruct{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst; <span class="hljs-comment">//these two have to be initialized</span>
    <span class="hljs-keyword">int</span> &amp;myRef;
};

<span class="hljs-keyword">int</span> z;
<span class="hljs-keyword">struct</span> MyStuct {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst = <span class="hljs-number">5</span>; 
    <span class="hljs-keyword">int</span> &amp;myRef=z;
}; <span class="hljs-comment">//this is kind of bad since not every MyStruct wants the same val. Compiles, though</span></code></pre>

<p>But does every instance of student need the same value of myConst, etc?</p>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//const (doesn't change) but not the same for all students.</span>
}</code></pre>

<p>Where do we initialize? ctor body? TOO LATE!</p>

<p>Where do we initialize? ctor body? - too late - fields must be fully constructed by then.</p>

<p>What happens when an object is created:</p>

<ol>
<li>space is allocated</li>
<li>fields are constructed //need to put our initializations here</li>
<li>ctor body runs</li>
</ol>

<p>How? - member initialization list (MIL)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">int</span> assns, mt, final;
    Student(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final):
        id{id}, assns{assns}, mt{mt}, final{final} {}
}</code></pre>

<blockquote>
  <p>Here: id - field, {id} - params <br>
  Note: can initialize any field this way, not just const + refs <br>
  Note: Fields initialized in the order in which they are declared in the class, even if the MIL orders them differently <br>
  Note: MIL sometimes more efficient than setting fields in the body. (o/w - run default ctor, then reassign in the body) EMBRACE THE MIL! ALL HAIL. PRAISE BE.</p>
</blockquote>

<p>what if a field is initialized inline AND in the MIL?</p>



<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">vec</span>(<span class="hljs-keyword">int</span> x); x{x} {}
};</code></pre>

<p>MIL takes precedence</p>



<h2 id="lecture-9">Lecture 9</h2>



<h3 id="uniform-initialization">Uniform Initialization</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> x(<span class="hljs-number">5</span>);
<span class="hljs-built_in">string</span> s = <span class="hljs-string">"hello"</span>;
<span class="hljs-built_in">string</span> s(<span class="hljs-string">"hello"</span>);
Student billy(<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>);
<span class="hljs-comment">//preferred (cs246 doesn't care which init you use though). This was updated as of a few years ago.</span>
<span class="hljs-keyword">int</span> x{<span class="hljs-number">5</span>};
<span class="hljs-built_in">string</span> s{<span class="hljs-string">"hello"</span>};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Now consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student bobby = billy; <span class="hljs-comment">//-how does this init happen? the COPY CONSTRUCTOR. For constructing one object as a copy of another</span></code></pre>

<blockquote>
  <p>Note: Every class comes with:</p>
  
  <ul>
  <li>default ctor (default constructs all fields that are objects) <br>
  <ul><li>copy ctor (just copies all the fields)</li>
  <li>copy assignment operator</li>
  <li>destructor</li>
  <li>move ctor</li>
  <li>move assignment operator</li></ul></li>
  </ul>
</blockquote>

<p>Building your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns,mt,final;
    Student(...) {...}
    Student(<span class="hljs-keyword">const</span> Student &amp;other): assns {assns}, mt {mt}, final {final} {}
}; <span class="hljs-comment">//equiv. to built in</span></code></pre>

<p>When is the built-in copy ctor not correct?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next
    Node(<span class="hljs-keyword">int</span> data, Node *next): data {data}, next{next} {}
    ...
};
Node *n = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
Node m = *n;
Node *p =<span class="hljs-keyword">new</span> Node{*n};</code></pre>

<p><img src="http://amyqiu.me/Notes/pointer.png"> <br>
Simple copy of fields -&gt; only the first node is actually copied (<em>shallow copy</em>) <br>
If you want a <em>deep copy</em> (copies the whole list),  must write your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(<span class="hljs-keyword">const</span> Node &amp;other): data{other.data}, next{ other.next? <span class="hljs-keyword">new</span> Node (*other.next) : <span class="hljs-keyword">nullptr</span>}{}
} <span class="hljs-comment">//we have some sneaky recursion going on here. This recursively invokes the copy ctor + copies the rest of the list</span></code></pre>

<p>The copy ctor is called:</p>

<ol>
<li>When an object initializes another object</li>
<li>When an object is passed by value</li>
<li>When an object is returned by value (* - not always)</li>
</ol>

<blockquote>
  <p>Note: Careful with ctors that can take ONE parameter:</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};</code></pre>

<p>single-arg ctors create implicit conversions. <br>
Eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">4</span>};
<span class="hljs-comment">// - also I can call:</span>
Node n =<span class="hljs-number">4</span>; <span class="hljs-comment">//- implicit conversion from int to node.</span>
<span class="hljs-keyword">int</span> f(Node n){...}
f(<span class="hljs-number">4</span>); <span class="hljs-comment">//works -4 is implicitly converted to Node</span></code></pre>

<blockquote>
  <p>Danger - accidentally passing an int to a f’n expecting a Node. Compiler will not signal an error. <br>
  Good idea - disable the implicit conversion - make the ctor explicit</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};
Node n{<span class="hljs-number">4</span>}; <span class="hljs-comment">//ok</span>
Node n = <span class="hljs-number">4</span>; <span class="hljs-comment">//error</span></code></pre>



<h3 id="destructors">Destructors</h3>

<p>When an object is destroyed (stack-allocated: goes out of scope, heap-allocated: is deleted) a method called the destructor runs. Classes comes with a dtor (just calls dtor on all fields that are objects) <br>
When an object is destroyed:</p>

<ol>
<li>The dtor body runs</li>
<li>field’s dtors invoked in reverse declaration order</li>
<li>space deallocated</li>
</ol>

<p>When do we need to write one?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span> <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};</code></pre>

<p>If np goes out of scope - the pointer is reclaimed (stack-allocated). The entire list is leaked. <br>
If we say <code>delete np;</code> then the 2 &amp; 3 nodes are leaked</p>

<p>Write a dtor to ensure the whole list is freed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;} <span class="hljs-comment">//&lt;- recursively calls next's dtor - frees the whole list.</span>
};</code></pre>

<p>Now - <code>delete np;</code> -frees the whole list</p>



<h3 id="copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane = billy; <span class="hljs-comment">//copy ctor</span>
Student mary; <span class="hljs-comment">//default ctor</span>
mary = billy; <span class="hljs-comment">//copy, but not construction. copy assignment operator is `=` - uses compiler-supplied default</span></code></pre>

<p>May need to write your own:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-comment">//So that cascading works your return itself. Eg. a=b=c=4; returns a = b = c; (c=4 now), a=b, (b=4 as well now), and then a=4;</span>
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        data=other.data;
        <span class="hljs-keyword">delete</span> next; <span class="hljs-comment">//the existing node might have other nodes so we need to delete those.</span>
        next=other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        <span class="hljs-comment">//THIS IS DANGEROUS</span>
    }
}</code></pre>

<p>Why?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
n=n; <span class="hljs-comment">//deletes n + then tries to copy n to n. undefined behaviour</span>
*p = *q;
a[i] = a[j];</code></pre>

<p>When writing operator=, ALWAYS be wary of self-assignment:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        data = other.data;
        <span class="hljs-keyword">delete</span> next;
        next = other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};</code></pre>

<p>Better:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp=next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data=other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }</code></pre>

<p>//if new fails, Node is still in a valid state.</p>



<h2 id="lecture-10">Lecture 10</h2>



<pre class="prettyprint"><code class="language-cpp hljs ">Node&amp; operators=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp = next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data = other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>
}</code></pre>

<p>Alternative: copy + swap idiom &lt;3</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;utility&gt;</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">void</span> swap(Node &amp;other){
        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
        swap(data,other.data);
        swap(next, other.next);
    }
}

Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    Node tmp = other; <span class="hljs-comment">//tmp = copy of other</span>
    swap(tmp); <span class="hljs-comment">//me = copy of other. tmp = my old fields</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//my old data deleted when tmp goes out of scope</span>
}</code></pre>



<h3 id="rvalues-rvalue-references">Rvalues + Rvalue References</h3>

<blockquote>
  <p>Recall: - an lvalue is anything with an address. -an lvalue reference (&amp;) is like a const pointer with automatic dereferencing. -always initialized to a lvalue.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node m=n; <span class="hljs-comment">//copy ctor;</span>
Node m2;
m2=n; <span class="hljs-comment">//copy assignment operator</span>

Node plusOne(Node n){
    <span class="hljs-keyword">for</span>(Node *p=&amp;n;p;p=p-&gt;next){
        ++p-&gt;data;
    }
    <span class="hljs-keyword">return</span> n;
}
Node m3 = plusOne(n); <span class="hljs-comment">//copy ctor. What is "other" here? Reference to what?</span></code></pre>

<ul>
<li>Compiler creates a <code>temporary</code> object to hold the result of plusOne</li>
<li>Other is a reference to this temporary - copy ctor deep-copies data from this temporary. <br>
<em>But:</em> - the temporary is just going to be discarded anyway, as soon as the stmt <code>Node m3 = plusOne(n);</code> is done</li>
<li>wasteful to copy from the temp. Why not just steal it instead? - save the cost of a copy. <br>
-Need to be able to tell whether the other is a reference to a temporary or a standalone object <br>
C++ - rvalue reference -&gt; Node &amp;&amp; is a reference to a temporary object (rvalue) of type Node.</li>
</ul>

<p>Version of the ctor that takes Node &amp;&amp;.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(Node &amp;&amp; other): <span class="hljs-comment">//called a move ctor</span>
    <span class="hljs-comment">// what should the move ctor do? Should steal other's data.</span>
        data{other.data},
        next{other.next} {
            other.next=<span class="hljs-keyword">nullptr</span>; <span class="hljs-comment">//else the list is destroyed when other is destroyed. This ctor is constant time.</span>
        }
}</code></pre>

<p>Similarly:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node m;
m=plusOne(n); <span class="hljs-comment">//Assignment from temporary</span>
<span class="hljs-comment">//More assignment operator:</span>
<span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(Node &amp;&amp;other){
        swap(other); <span class="hljs-comment">//steal other's data</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//destroy my old data. swap without copy</span>
    }
}</code></pre>

<p>If you don’t define move ctor/assignment, the copy versions will be used. If the move ctor/assignment is defined, it will replace all calls to copy ctor/assignment when the argument is a temporary (rvalue).</p>



<h3 id="copymove-elision">Copy/Move Elision</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec makeAVec(){
    <span class="hljs-keyword">return</span> {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}; <span class="hljs-comment">//invokes a basic ctor</span>
}
Vec v=makeAVec(); <span class="hljs-comment">//what runs? Not Sure! When compiled in g++, there's the basic ctor (no move/copy ctor).</span></code></pre>

<p>In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn’t have to) <br>
In this example: makeAVec writes it’s result ({0,0}) directly into the space occupied by v in the caller, rather than copy or move it later. <br>
Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> doSomething(vec v)<span class="hljs-comment">//&lt;- pass-by-value copy/move ctor</span>
{...}
doSomething(makeAVec()); <span class="hljs-comment">//-result of makeAVec is written directly into the parameter. There is no copy or move. This is allowed even if dropping ctor calls would change the behaviour of the program. eg. if the ctors print something.</span></code></pre>

<p>You are not expected to know exactly when move/copy elision is allowed, just that it is possible.</p>

<p>If you need all of the ctors to run: <code>g++14 -fno-elide-constructors</code> runs all constructors. But this can slow down your program considerably</p>

<p>In Summary: Rule of 5 (Big 5)</p>

<ul>
<li>If you need a custom version of any one of: <br>
<ul><li>copy ctor</li>
<li>copy assignment</li>
<li>dtor</li>
<li>move ctor</li>
<li>move assignment <br>
Then you usually need a custom version of all five. (The circumstances that require you to need one, usually require you to need all of them)</li></ul></li>
</ul>

<blockquote>
  <p>Notice: <br>
  <code>operator=</code> is a member function, not a standalone function <br>
  When an operator is a member, <code>this</code> is the first arguement</p>
  
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
  <span class="hljs-keyword">int</span> x,y;
  ...
  Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec&amp;other){
     <span class="hljs-keyword">return</span>{x+other.x, y+other.y};
  }
  Vec <span class="hljs-keyword">operator</span>*{<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k}{ <span class="hljs-comment">//implements v*k</span>
     <span class="hljs-keyword">return</span> {x*k, y*k};
  }
  <span class="hljs-comment">//How do we implement k*v? Can't be a member -first arg not Vec. -Write it as a standalone:</span>
}
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
  <span class="hljs-keyword">return</span> v*k;
}</code></pre>
</blockquote>

<p>I/O operators:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    ...
    ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out){
        <span class="hljs-keyword">return</span> out &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; y;
    }
};
<span class="hljs-comment">//what's wrong? Make Vec the first arg. -&gt; Use as vec&lt;&lt;cout;</span></code></pre>

<p>So define &lt;&lt;. &gt;&gt; as standalone fns.  <br>
Certain operators <strong>must</strong> be members:</p>

<ul>
<li>operator=</li>
<li>operator[]</li>
<li>operator()</li>
<li>operator T (where T is a type)</li>
</ul>



<h2 id="lecture-10-1">Lecture - 10</h2>



<h3 id="separate-compilation-for-classes">Separate Compilation for Classes</h3>

<p>Node.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor"># ...</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data, Node*next=<span class="hljs-keyword">nullptr</span>);
    <span class="hljs-keyword">bool</span> hasNext();
};</code></pre>

<p>Node.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "node.h"</span>
Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next} {} <span class="hljs-comment">//compiler will yell at you for this. No return type and can't use init for f'ns.</span>
Node::Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next}{} <span class="hljs-comment">//tells compiler that it belongs to a class</span>

<span class="hljs-keyword">bool</span> hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;} <span class="hljs-comment">//will yell and say that you're using an undeclared variable</span>
<span class="hljs-keyword">bool</span> Node::hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;}<span class="hljs-comment">//better</span></code></pre>

<p><code>::</code> - scope resolution operator <br>
<code>Node:: ____</code> means <code>____</code> within class node <br>
<code>::</code> like <code>.</code> where LHS is a class or namespace, not an object</p>



<h3 id="arrays-of-objects">Arrays of Objects</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y): x{x}, y{y} {}
};
Vec *vp = <span class="hljs-keyword">new</span> Vec[<span class="hljs-number">5</span>]; <span class="hljs-comment">// X</span>
Vec moreVecs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// X</span>
<span class="hljs-comment">//there want to call the default ctor on each item. Can't init array elements - no default ctor.</span></code></pre>

<p>Options</p>

<ol>
<li>Provide a default ctor</li>
<li>For stack arrays: <br>
<code>Vec moreVecs[] = {{0,0}, {1,3}, {2,4}};</code></li>
<li>For heap arrays: -create an array of ptrs</li>
</ol>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec **vp = <span class="hljs-keyword">new</span> Vec*[<span class="hljs-number">5</span>];
vp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> Vec {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
vp[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> Vec[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>;++i){
    <span class="hljs-keyword">delete</span> vp[i];
}
<span class="hljs-keyword">delete</span>[] vp;</code></pre>



<h3 id="const-objects">Const Objects</h3>

<p>Const objects arise often</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(<span class="hljs-keyword">const</span> Node &amp;n) {...}</code></pre>

<p>What is a const object? Can’t change fields <br>
Question: Can we call methods on a const object? <br>
<em>Issue:</em> <br>
The method may modify fields, violate const <br>
Answer: Yes - we can call methods that promise not to change fields</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>; <span class="hljs-comment">//this method will not change fields</span>
};</code></pre>

<p>Compiler checks that const methods don’t modify fields. Only const methods can be called on const objects.</p>

<p>Now consider: want to collect usage stats on student objects</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">int</span> numMethodCalls=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodcalls; <span class="hljs-comment">//method isn't const anymore. If you take const out, can't call grade on const students</span>
        <span class="hljs-keyword">return</span> ...
    }
};</code></pre>

<p>But mutating numMethodCalls affects only the <strong>physical constness</strong> of student objects, not the <strong>logical constness</strong></p>

<p>Want to be able to update numMethodCalls, even if the object is const - declare the field <code>mutable</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodCalls;
        <span class="hljs-keyword">return</span> ...;
    }
};</code></pre>

<p>mutable fields can be changed, even if the object is const.</p>



<h3 id="static-fields-methods">Static Fields + Methods</h3>

<p><code>numMethodCalls</code> tracked # of method calls for each particular Student <br>
What if we want to track method calls over all Students? <br>
Or what if we want to know how many Students were created? <br>
<strong>Static members</strong> - associated with the class itself, not with any specified instance (object).</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstances;
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final): assns{assns}, mt{mt}, final{final} {
        ++numInstances;
    }
};

<span class="hljs-keyword">int</span> Student::numInstances=<span class="hljs-number">0</span>; <span class="hljs-comment">//in .cc file</span></code></pre>

<p>static fields must be defined, external to the class</p>



<h3 id="static-member-functions">Static Member Functions</h3>

<ul>
<li>Don’t depend on a specific instance (no <code>this</code> param)</li>
<li>Can only access static fields + call other static methods</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstance;
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> printNumInstances(){
        <span class="hljs-built_in">cout</span> &lt;&lt; numInstances &lt;&lt; endl;
    }
};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane{<span class="hljs-number">70</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>};
Student::printNumInstances(); <span class="hljs-comment">//2</span></code></pre>



<h3 id="invariants-encapsulation">Invariants + Encapsulation</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(<span class="hljs-keyword">int</span> data, Node*next);
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;}
};
Node n1 {<span class="hljs-number">1</span>, newNode {<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node n2 {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>};
Node n3 {<span class="hljs-number">4</span>, &amp;n2};</code></pre>

<p>What happens when these go out of scope?</p>

<ul>
<li>n1: dtor runs, whole list is deleted OK</li>
<li>n2, n3 go out of scope - n3’s dtor attempts to delete n2 but n2 is on the stack, not the heap! Undefined behaviour!</li>
</ul>

<p>Class Node relies on an assumption for its proper operation - next is either <code>nullptr</code> or allocated by <code>new</code>.</p>

<p>This is an <strong>invariant</strong> - statement that holds true, upon which Node relies. <br>
But we can’t guarantee this invariant - can’t trust the user to use Node properly.  <br>
Can’t enforce any invariants - user can interfere with our data.</p>

<blockquote>
  <p>Eg. - Stack : Invariant -&gt; last item pushed is first item popped. <br>
  but not if the client can rearrange the underlying data. </p>
</blockquote>

<p>Hard to reason about programs if you can’t rely on invariants. <br>
To enforce invariants - we introduce <code>encapsulation</code>  - we can’t clients to treat our objects as black boxes - capsules.</p>

<ul>
<li>implementation details sealed away</li>
<li>can only interact via provided methods</li>
<li>abstraction - regains control over our objects</li>
</ul>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs ">strut Vec{
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y); <span class="hljs-comment">//public by default</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">//can't be accessed outside the struct Vec.</span>
    <span class="hljs-keyword">public</span>:
        Vec <span class="hljs-keyword">operator</span>+(...);<span class="hljs-comment">//anyone can access</span>
        ...
};</code></pre>

<p>In general: want fields to be private - only methods should be public.  <br>
Better to have default visibility to be private. <br>
Switch from struct to class. <br>
THIS IS THE ONLY DIFFERENCE BETWEEN STRUCT AND CLASS -&gt; default visibility. Public in <code>struct</code>. Private in <code>class</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x,y);
    Vec <span class="hljs-keyword">operator</span>+(...);
    ...
};</code></pre>



<h2 id="cs-246-tut-5">CS 246 TUT 5</h2>

<blockquote>
  <p>Summary: Rvalues &amp; Lvalues <br>
  Move Copy/Assignment <br>
  Rule of Five <br>
  Member Operators</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> value;
    Node *next;
};

Node add(Node n, <span class="hljs-keyword">int</span> inc){ <span class="hljs-comment">//copy ctor runs</span>
    <span class="hljs-keyword">for</span>(Node *m=&amp;n; m != <span class="hljs-keyword">nullptr</span>; m = m-&gt;next){
        m-&gt;value += inc;
    }
    <span class="hljs-keyword">return</span> n;
}

Node n1{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
Node n2 = add(n1,<span class="hljs-number">3</span>); <span class="hljs-comment">//move ctor</span>
n2 = add(n1, <span class="hljs-number">4</span>); <span class="hljs-comment">//move assign</span>

Node(Node &amp;&amp;other): <span class="hljs-comment">//impl of the move ctor</span>
value{other.value}, next{other.next} {
    other.next = <span class="hljs-keyword">nullptr</span>;
}</code></pre>

<p>Node &amp;operator=(Node &amp;&amp;other){ <br>
    swap(value, other.value); <br>
    swap(next, other.next); <br>
    return *this; <br>
}</p>

<p>lvalue -&gt; with address <br>
rvalue -&gt; without address</p>



<h2 id="lecture-12">Lecture 12</h2>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
        <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);
        Vec <span class="hljs-keyword">operator</span>+(...);
        ...
};</code></pre>

<p>Fix our linked list class: <br>
list.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node; <span class="hljs-comment">//private nested class. Only accessible within list.</span>
    Node *theList = <span class="hljs-keyword">nullptr</span>;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> addToFront(<span class="hljs-keyword">int</span> n);
        <span class="hljs-keyword">int</span> ith(<span class="hljs-keyword">int</span> n) <span class="hljs-keyword">const</span>;
        ~List(){<span class="hljs-keyword">delete</span> theList;}
};</code></pre>

<p>list.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "list.h"</span>
<span class="hljs-keyword">struct</span> List::Node{ <span class="hljs-comment">// Nested class</span>
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(...): ... {}
    ~Node() {<span class="hljs-keyword">delete</span> next;}
};

<span class="hljs-keyword">void</span> List::addToFront(<span class="hljs-keyword">int</span> n){
    theList = <span class="hljs-keyword">new</span> Node {n, theList};
}

<span class="hljs-keyword">int</span> List::ith(<span class="hljs-keyword">int</span> i)<span class="hljs-keyword">const</span>{
    Node *cur = theList;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n &lt; i &amp;&amp; cur; ++n; curr=cur-&gt;next);
    <span class="hljs-keyword">return</span> cur-&gt; data;
}</code></pre>

<p>Only List can create/manipulate Node objects <br>
<script type="math/tex" id="MathJax-Element-323">\therefore</script> Can guarantee the invariant that next is either nullptr or allocated by new.</p>

<p>pause</p>

<hr>

<p>But - Now we can’t traverse the list from front node to node, as would a linked list.  <br>
Repeatedly calling ith - <script type="math/tex" id="MathJax-Element-324">O(n^2)</script> time. <br>
But we can’t expose the nodes, or we lose encapsulation</p>



<h3 id="se-topic-design-patterns">SE Topic: Design Patterns</h3>

<ul>
<li>certain problems arise frequently</li>
<li>keep track of good solutions, use in similar situations</li>
</ul>

<dl>
<dt>Design Pattern</dt>
<dd>If you have problem X, solution Y will fix it.</dd>
</dl>

<blockquote>
  <p>Book Rec: Design Patterns (by the gang of four)</p>
</blockquote>

<hr>

<p>resume</p>

<p>Solution: Create a class that manages access to nodes <br>
- Create a class that manages access to nodes <br>
- abstraction of a ptr <br>
- walk the list without exposing the actual ptrs.</p>

<p>Inspiration:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *p=a; p! = a+n ; ++p){
    ... *p ...
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    Node *theList;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">explicit</span> Iterator(Node *p):p{p}{}
                <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> p-&gt;data;} <span class="hljs-comment">// returns p-&gt;data ITSELF. allows the user to update it themselves. (eg. Iterator it ... ; *it = 7;)</span>
                Iterator &amp;<span class="hljs-keyword">operator</span>++(){p=p-&gt;next; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Iterator &amp;other){ <span class="hljs-keyword">return</span> p==other.p;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Iterator &amp;other){
                    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>==other);
                }
        };
        Iterator begin(){<span class="hljs-keyword">return</span> Iterator{theList};}
        Iterator end(){<span class="hljs-keyword">return</span> Iterator{<span class="hljs-keyword">nullptr</span>};}
        ...<span class="hljs-comment">//other methods like ith</span>
        ... 
};</code></pre>

<p>Client:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    List l;
    l.addToFront(<span class="hljs-number">1</span>);
    l.addToFront(<span class="hljs-number">2</span>);
    l.addToFront(<span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span>(List::Iterator it=l.begin(); it!=l.end();++it){
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;endl;
    }
}</code></pre>

<blockquote>
  <p>Shortcut: automatic type deduction - <code>auto x = y;</code> . <code>auto</code> automatically gives x the same type as y.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = l.begin(); it!=l.end(); ++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}</code></pre>

<blockquote>
  <p>Shorter cut: range-based for loop</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:l){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}</code></pre>

<p>Available for any class with:</p>

<ul>
<li>methods begin + end that produces iterators</li>
<li>iterators must support !=, prefix ++, unary *</li>
</ul>

<p>If you want to modify the list items (or save copying):</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;n: l){
    ++n;
}</code></pre>

<p>Iterators shall return later.</p>

<p>Encapsulation ctd.</p>

<p>List  Client can create iterators directly :o</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> it = List::Iterator{<span class="hljs-keyword">nullptr</span>}; <span class="hljs-comment">//well, they only can make a nullptr iterator. But still. Bad form.</span></code></pre>

<ul>
<li>violate encapsulation - client should be using begin/end.</li>
</ul>

<p>We could make Iterator’s ctor private. Then client can’t call <code>List::Iterator(...)</code> . But then neither can List.</p>

<p>Solution: Give List privileged access to Iterator. Make it a <code>friend</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">explicit</span> Iterator(Node *p); <span class="hljs-comment">//private</span>
            <span class="hljs-keyword">public</span>:
                ...
                <span class="hljs-keyword">friend</span> clas List; <span class="hljs-comment">// List has access to all members of Iterator.</span>
        };
    ...
};</code></pre>

<p>Now List can still create iterators, but client can only create them by calling <code>begin()</code> and <code>end()</code>.</p>

<p>Advice: give your classes as few friends as possible. weakens encapsulation. <br>
Once again: keep fields private. What if you want to give access to fields? use accessor + mutator methods.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> getX()<span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> x;} <span class="hljs-comment">//accessor</span>
        <span class="hljs-keyword">void</span> setY(<span class="hljs-keyword">int</span> newY){y=newY;} <span class="hljs-comment">//mutator</span>
};</code></pre>

<hr>

<p>what about operator &lt;&lt; - needs x+y, can’t be a member <br>
If no getX, getY - make operator &lt;&lt; a friend function</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v);
}

<span class="hljs-comment">//.cc</span>
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> out &lt;&lt; v.x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v.y;
}</code></pre>



<h3 id="tools-topic-make">Tools topic: make</h3>

<p>Separate compilation: <code>g++14 -c list.cc</code> , <code>g++14 -c node.cc</code>, <code>g++14 -c iter.cc</code>, <code>g++14 -c main.cc</code>, <code>g++14 list.o node.o iter.o main.o -o myprog</code> <br>
Why do we do this? So we don’t have to recompile files that haven’t changed.</p>

<p>How do you keep track of what’s changed? <br>
Let Linux help you - with make.</p>

<p>Create a Makefile that says which files depend on which other files. <br>
myprog: main.o list.o node.o iter.o //myprog depends on these <br>
[   ] (MUST be a TAB) g++-5 -std=c++14 main.o list.o node.o iter.o -o myprog (&lt;- how to rebuild)</p>



<h2 id="lecture-13">Lecture 13</h2>



<h3 id="makefile">Makefile</h3>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">myprog:</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>==++<span class="hljs-number">14</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span> -o myprog
<span class="hljs-label">list.o:</span> list<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>=c++<span class="hljs-number">14</span> -c list<span class="hljs-preprocessor">.cc</span>
etc</code></pre>

<p>What does myprogram depend on? <br>
- Recursively build these, if necessary <br>
iter.cc changes: - now newer than iter.o (by last modified date). <script type="math/tex" id="MathJax-Element-325">\therefore</script> rebuilt iter.o <br>
- now iter.o newer than myprogram. <script type="math/tex" id="MathJax-Element-326">\therefore</script> rebuild myprogram <br>
- To do a full rebuild, make clean, make</p>

<p>Generalize with variables</p>



<pre class="prettyprint"><code class=" hljs lasso">CXX <span class="hljs-subst">=</span> g<span class="hljs-subst">++-</span><span class="hljs-number">5</span> <span class="hljs-comment">//compiler's name</span>
CXXFLAGS <span class="hljs-subst">=</span> <span class="hljs-attribute">-std</span><span class="hljs-subst">=</span>c<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-Wall</span> <span class="hljs-comment">//(Wall turns on warnings)</span></code></pre>

<p>eg. </p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> iter<span class="hljs-preprocessor">.h</span>
    ${CXX} ${CXXFLAGS} -c iter<span class="hljs-preprocessor">.cc</span></code></pre>

<p>Shortcut: for any rule of the form</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">x.o:</span> <span class="hljs-built_in">x</span><span class="hljs-preprocessor">.cc</span> a<span class="hljs-preprocessor">.h</span> b<span class="hljs-preprocessor">.h</span></code></pre>

<p>-can leave out the build command <br>
- make guesses that you want</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-variable">${CXX}</span> <span class="hljs-variable">${CXXFLAGS}</span> -c x.cc -o x.o</code></pre>

<p>Biggest problem with writing Makefiles <br>
-working out dependencies <br>
and maintaining them if they change.</p>

<p>Can get help from g++</p>



<pre class="prettyprint"><code class=" hljs lasso">g<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-MMD</span> <span class="hljs-attribute">-c</span> iter<span class="hljs-built_in">.</span>cc</code></pre>

<p>-creates iter.o and iter.d <br>
iter.d</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span></code></pre>

<p>Now just include this in the Makefile</p>



<pre class="prettyprint"><code class=" hljs r">CXXFLAGS= -std=c++<span class="hljs-number">14</span> -Wall -MMD
<span class="hljs-keyword">...</span>
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS: .o=.d}
<span class="hljs-keyword">...</span></code></pre>

<p>-include ${DEPENDS}</p>



<h3 id="system-modelling">System Modelling</h3>

<p>building an 00 system: <br>
- identify abstractions <br>
- formalize relationships among them <br>
Helpful to map these out <br>
popular standard: UML (Unified Modelling Language) <br>
Modelling a Class</p>

<table>
<thead>
<tr>
  <th>Name</th>
  <th>Vec</th>
</tr>
</thead>
<tbody><tr>
  <td>Fields(optional)</td>
  <td>-x:Integer, -y:Integer</td>
</tr>
<tr>
  <td>Methods(optional)</td>
  <td>+getx: Integer, +getY:Integer</td>
</tr>
</tbody></table>


<p>Visibility: <code>-</code> -&gt; private, <code>+</code> -&gt; public <br>
Relationship: Composition of Classes</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);
};
<span class="hljs-comment">//Two vecs define a basis</span>
<span class="hljs-keyword">class</span> Basis{
    Vec v1,v2;
};
Basis b; <span class="hljs-comment">//XXX can't initialize v1, v2 - no default ctor for Vec.</span></code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Basis{
    Vec v1, v2;
    <span class="hljs-keyword">public</span>:
        Basis(): v1{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}, v2 {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>} {}
};</code></pre>

<p>Embedding one obj.(Vec) inside another (Basis) called <strong>Composition</strong> <br>
Relationship between Basis + Vec is called “owns-a” - A Basis “owns” the two Vec objects.</p>

<p>If A “owns-a” B then typically -</p>

<ul>
<li>B has no identity outside A (B is a part of A)</li>
<li>If A is destroyed, B is destroyed</li>
<li>If A is copied, B is copied (deep copy) <br>
E.g: A car owns y wheels - a wheel is a part of a car <br>
-destroy the car -&gt; destroy the wheels <br>
-copy the car -&gt; copy the wheels</li>
</ul>

<p>Implement: usually as composition of classes <br>
Modelling <br>
<img src="http://amyqiu.me/Notes/ownsa.png"> <br>
More details: links on course website</p>



<h3 id="aggegation">Aggegation</h3>

<p>Compare car parts in a car (“owns a”) vs car parts in a catalogue. <br>
The catalogue contains parts, but the parts exists on their own. “has-a” relationship (aggregation)</p>

<p>If A “has a” B, then typically</p>

<ul>
<li>B has an existence outside of its association with A</li>
<li>If A is destroyed, B lives on</li>
<li>If A is copied, B is not (shallow copies) <br>
<ul><li>copies of A share the same B</li></ul></li>
</ul>

<p>e.g.: Ducks in a pond <br>
<img src="http://amyqiu.me/Notes/hasa.png"> <br>
Typical Implementation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Pond {
    Duck *ducks[maxDucks];
};</code></pre>



<h3 id="inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</h3>

<p>Suppose you want to track your collection of books</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    ...
};

<span class="hljs-keyword">class</span> Text{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> topic;
    ...
};

<span class="hljs-keyword">class</span> Comic{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> hero;
    ...
};</code></pre>

<p>-Doesn’t affress relationship among these classes. <br>
-How would we create an array or list containing a mixture of these? <br>
Observe that Texts + comics are KINDS of books. Books with extra features <br>
In c++ - inheritance</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{ <span class="hljs-comment">//Base class or superclass</span>
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        Book(...);
        ...
};

<span class="hljs-comment">//Derived classes or subclasses</span>
<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(...);
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> hero;
    <span class="hljs-keyword">public</span>:
        Comic(...);
};</code></pre>

<p>Derived classes inherit fields + methods from the base class. <br>
So Text, Comic have title author, numPages. <br>
Any method that can be called on Book can be called on Text, Comic. <br>
Who can see these members? <br>
title, author, numPages are private in Book. - outsiders can’t see them. <br>
Can Text, Comic see them? <br>
No. Even subclasses can’t see them!</p>

<p>How do we initialize Text?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): title{title}, author{author}, numPages{numPages}, topic{topic}{} <span class="hljs-comment">//WRONG. DOESN'T WORK HAHA</span>
};</code></pre>

<p>Wrong for 2 reasons:</p>

<ul>
<li>title, author, numPages not accessible in Text</li>
<li>when an object is created: <br>
<ol><li>space is allocated</li>
<li><strong>superclass part is constructed</strong> (in this case, Book doesn’t have a default ctor. Can’t do this)</li>
<li>fields are constructed</li>
<li>ctor body runs</li></ol></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p; <span class="hljs-comment">//read right to left. p is a constant pointer to an int.</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//p is a pointer to an int that is constant</span></code></pre>



<h2 id="lecture-14">Lecture 14</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
      Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): Book {title, author, numPages}, topic{topic}{}
};</code></pre>

<p>If the superclass has no default ctor, the subclass MUST invoke a superclass ctor in its Member Initialization List.</p>

<p>If you want to give the subclass access to certain superclass members, use <strong>protected</strong> visibility.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-keyword">protected</span>:
      <span class="hljs-built_in">string</span> title, author;
      <span class="hljs-keyword">int</span> numPages;
      ...
};

<span class="hljs-keyword">class</span> Topic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
      ...
      <span class="hljs-keyword">void</span> addAuthor(<span class="hljs-built_in">string</span> auth) {author+=auth;} <span class="hljs-comment">//ok since we protected author</span>
};</code></pre>

<p>Not a good idea to give subclasses unlimited access to fields. Breaks encapsulation and invariant. -&gt; eg. if you really don’t want Book to have the author Robert Munch, but you can’t guarantee that all subclasses will follow that rule and since they can change fields, breaks invariant.</p>

<p>Better: make fields private and provide protected access.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-built_in">string</span> getTitle() <span class="hljs-keyword">const</span>;
        <span class="hljs-keyword">void</span> setAuthor(<span class="hljs-built_in">string</span> auth);
        ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span>;
    ...
};</code></pre>

<p>Relationship among Text, Comic, Book is called “is-a” <br>
- a Text is a Book <br>
- a Comic is a Book <br>
- protected: #</p>

<p><img src="amyqiu.me/Notes/TextComic.png"></p>

<p>Method isItHeavy - when is a book heavy? <br>
- for ordinary Books - &gt; 200 pgs <br>
- for Text - &gt; 500 pages <br>
- for Comics - &gt; 30 pages</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">200</span>;}
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">30</span>;}
};

<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">500</span>;}
};

Book b{<span class="hljs-string">"A small book"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">50</span>};
Comic c{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; b.isItHeavy() <span class="hljs-comment">//false</span>
     &lt;&lt; c.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>Since a Comic “is a” Book, we can do this:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};</code></pre>

<p>Q: Is b heavy? <br>
Which isItHeavy runs: Book::isItHeavy, or Comic:isItHeavy ? <br>
A: NO - b is not heavy. Book::isItHeavy runs. <br>
Why? <br>
<img src="amyqiu.me/Notes/ComicvsBook.png"> <br>
Since I’ve allocated only enough space for a Book and Comic is bigger, I must treat b as a book no matter what.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{...};
<span class="hljs-comment">//tries to fit a Comic object where there is only space for a Book object. What happens? - slicing occurs - c++ makes comic fit by chopping off bits. Hero field is chopped off so comic is coerced into a Book.</span></code></pre>

<p>So this converts the comic into a Book and Book::isItHeavy runs.</p>

<p>When accessing objects through ptrs, slicing is unnecessary and doesn’t happen.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Comic *pc = &amp;c;
<span class="hljs-built_in">cout</span> &lt;&lt;  pc -&gt; isItHeavy(); <span class="hljs-comment">//true</span>
     &lt;&lt; pb -&gt; isItHeavy(); <span class="hljs-comment">//not heavy</span></code></pre>

<p>still Book:isItHeavy runs when we access pb-&gt;isItHeavy(). <br>
Same object behaves differently, depending on what kind of ptr points at it. <br>
Compiler uses the type of the pointer (or reference) to determine which isItHeavy to run. - does not consider the actual type of the object <br>
Means a comic is only a comic when pointed at by a comic ptr -proabably not what we want.</p>

<p>How do we make comic act like a Comic, even when pointed at by a Book ptr? <br>
Declare the method <strong>virtual</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {...};
        ...
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Comic(...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> override{...}
        ...
};

Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Book &amp;rb = c;
Comic *pc = &amp;;

<span class="hljs-built_in">cout</span> &lt;&lt; pc-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; pb-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; rb.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>E.g. <br>
My Book Collection:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *myBooks[<span class="hljs-number">20</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span> ; ++i){
    <span class="hljs-built_in">cout</span> &lt;&lt; myBooks[i] -&gt;isItHeavy() &lt;&lt; endl; <span class="hljs-comment">// uses the right isItHeavy for corresponding types. :D</span>
}</code></pre>

<p>Accommadates multiple types under one abstraction <br>
-polymorphism (“many forms”)</p>

<hr>



<h3 id="destructor-revisited">Destructor Revisited</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    <span class="hljs-keyword">int</span> *x;
    <span class="hljs-keyword">public</span>:
        X(<span class="hljs-keyword">int</span> n): x{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]}{}
        ~X(){<span class="hljs-keyword">delete</span> [] x;}
};

<span class="hljs-keyword">class</span> Y: <span class="hljs-keyword">public</span> X{
    <span class="hljs-keyword">int</span> *y;
    <span class="hljs-keyword">public</span>:
        Y(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n): X{n}, y{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m]}{}
        ~Y(){<span class="hljs-keyword">delete</span> [] y};
};</code></pre>

<p>You don’t have to delete X. X’s dtor will run after Y automatically since it’s the superclass.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">X *myX = <span class="hljs-keyword">new</span> Y{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>};
<span class="hljs-keyword">delete</span> myX; <span class="hljs-comment">//- leaks, why? X's dtor ran, but myX points to a Y. Y's dtor never runs here.</span></code></pre>

<p>So only x, but not y is freed. <br>
How can we ensure that deletion through superclass ptr will call subclass dtor? <br>
- declare the dtor virtual</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">virtual</span> ~X(){
            <span class="hljs-keyword">delete</span> x;
        }
};</code></pre>

<p>ALWAYS - make the dtor virtual in classes that are meant to have subclasses <br>
-even if the dtor doesn’t do anything <br>
If a subclass is NOT meant to have subclasses, declare it <code>final</code>:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Y final: <span class="hljs-keyword">public</span> X{
    ...
};</code></pre></body>
</html>
-->