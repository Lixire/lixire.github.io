<!--
1: Using prettify
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CS 246</title>

<link rel="stylesheet" type="text/css" href="https://www.dropbox.com/s/atz4kqwayz4hlhk/markDown.css?raw=1">

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>

</head>
<body><h1 id="cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</h1>

<blockquote>
  <p>Brad Lushman <br>
  Office: DC 3110 <br>
  Email: bmlushma <br>
  <a href="http://www.student.cs.uwaterloo.ca/~cs246">http://www.student.cs.uwaterloo.ca/~cs246</a> <br>
  Linux is required! Ripperino</p>
</blockquote>

<p><div class="toc">
<ul>
<li><a href="#cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</a><ul>
<li><a href="#lecture-1">Lecture 1</a><ul>
<li><a href="#linux-please">Linux, Please</a></li>
<li><a href="#module-1-linux-shell">Module 1 - Linux Shell</a></li>
<li><a href="#linux-file-system">Linux File System</a></li>
<li><a href="#pipes">Pipes</a></li>
</ul>
</li>
<li><a href="#lecture-2">Lecture 2</a><ul>
<li><a href="#pipes-cont">Pipes Cont.</a></li>
<li><a href="#pattern-matching-in-text-files">Pattern-Matching in Text Files</a></li>
<li><a href="#permissions">Permissions</a></li>
</ul>
</li>
<li><a href="#lecture-3">Lecture 3</a><ul>
<li><a href="#shell-scripts">Shell Scripts</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#loops">Loops</a></li>
</ul>
</li>
<li><a href="#lecture-4">Lecture - 4</a><ul>
<li><a href="#se-topic-testing">SE Topic: Testing</a></li>
<li><a href="#module-2-c">Module 2: C++</a></li>
<li><a href="#compiling-c-programs">Compiling C++ programs</a></li>
<li><a href="#inputoutput">Input/Output</a></li>
</ul>
</li>
<li><a href="#lecture-5">Lecture 5</a><ul>
<li><a href="#reading-strings">Reading Strings</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#string-operations">String Operations:</a></li>
<li><a href="#default-fn-params">Default f’n Params</a></li>
<li><a href="#overloading">Overloading</a></li>
</ul>
</li>
<li><a href="#lecture-6">Lecture 6</a><ul>
<li><a href="#structs">Structs</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#parameter-passing">Parameter Passing</a></li>
<li><a href="#references">References</a></li>
<li><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
</ul>
</li>
<li><a href="#lecture-7">Lecture 7</a><ul>
<li><a href="#operator-overloading">Operator Overloading</a></li>
<li><a href="#overloading-and">Overloading &lt;&lt; and &gt;&gt;</a></li>
<li><a href="#the-preprocessor">The Preprocessor</a></li>
<li><a href="#separate-compilation">Separate Compilation</a></li>
<li><a href="#compiling-separately">Compiling Separately</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</a><ul>
<li><a href="#lecture-8">Lecture 8</a><ul>
<li><a href="#classes">Classes</a></li>
</ul>
</li>
<li><a href="#lecture-9">Lecture 9</a><ul>
<li><a href="#uniform-initialization">Uniform Initialization</a></li>
<li><a href="#destructors">Destructors</a></li>
<li><a href="#copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</a></li>
</ul>
</li>
<li><a href="#lecture-10">Lecture 10</a><ul>
<li><a href="#rvalues-rvalue-references">Rvalues + Rvalue References</a></li>
<li><a href="#copymove-elision">Copy/Move Elision</a></li>
</ul>
</li>
<li><a href="#lecture-11">Lecture - 11</a><ul>
<li><a href="#separate-compilation-for-classes">Separate Compilation for Classes</a></li>
<li><a href="#arrays-of-objects">Arrays of Objects</a></li>
<li><a href="#const-objects">Const Objects</a></li>
<li><a href="#static-fields-methods">Static Fields + Methods</a></li>
<li><a href="#static-member-functions">Static Member Functions</a></li>
<li><a href="#invariants-encapsulation">Invariants + Encapsulation</a></li>
</ul>
</li>
<li><a href="#cs-246-tut-5">CS 246 TUT 5</a></li>
<li><a href="#lecture-12">Lecture 12</a><ul>
<li><a href="#se-topic-design-patterns">SE Topic: Design Patterns</a></li>
<li><a href="#tools-topic-make">Tools topic: make</a></li>
</ul>
</li>
<li><a href="#lecture-13">Lecture 13</a><ul>
<li><a href="#makefile">Makefile</a></li>
<li><a href="#system-modelling">System Modelling</a></li>
<li><a href="#aggegation">Aggegation</a></li>
<li><a href="#inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</a></li>
</ul>
</li>
<li><a href="#lecture-14">Lecture 14</a><ul>
<li><a href="#destructor-revisited">Destructor Revisited</a></li>
</ul>
</li>
<li><a href="#lecture-15">Lecture 15</a><ul>
<li><a href="#pure-virtual-methods-abstract-classes">Pure Virtual Methods + Abstract Classes</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#the-standard-template-library-stl">The Standard Template Library (STL)</a></li>
</ul>
</li>
<li><a href="#lecture-16">Lecture 16</a><ul>
<li><a href="#design-patterns-ctd">Design Patterns Ct’d</a></li>
<li><a href="#observer-pattern">Observer Pattern</a></li>
</ul>
</li>
<li><a href="#lecture-17">Lecture 17</a><ul>
<li><a href="#decorator-pattern">Decorator Pattern</a></li>
<li><a href="#inheritance-and-copymove">Inheritance and Copy/Move</a></li>
</ul>
</li>
<li><a href="#lecture-18">Lecture 18</a><ul>
<li><a href="#factory-method-pattern">Factory Method Pattern</a></li>
<li><a href="#template-method-pattern">Template Method Pattern</a></li>
<li><a href="#stl-maps-for-creating-dictionaries">STL Maps - for creating Dictionaries</a></li>
</ul>
</li>
<li><a href="#lecture-19">Lecture 19</a><ul>
<li><a href="#visitor-pattern">Visitor Pattern</a></li>
<li><a href="#pimpl-idiom-pointer-to-implementation">Pimpl idiom (“Pointer to implementation”)</a></li>
</ul>
</li>
<li><a href="#lecture-20">Lecture 20</a><ul>
<li><a href="#measures-of-design-quality">Measures of Design Quality</a></li>
<li><a href="#decoupling-the-interface-mvc">Decoupling the Interface (MVC)</a></li>
<li><a href="#single-responsibility-principle">Single Responsibility Principle</a></li>
<li><a href="#pattern-model-view-controller-mvc">Pattern: Model-View-Controller (MVC)</a></li>
<li><a href="#exception-safety">Exception Safety</a></li>
<li><a href="#c-idiom-raii-resource-acquisition-is-initialization-might-appear-on-final-exam-what-does-it-stand-for">C++ idiom : RAII - Resource Acquisition Is Initialization (**Might appear on final exam. What does it stand for?)</a></li>
</ul>
</li>
<li><a href="#lecture-21">Lecture 21</a><ul>
<li><a href="#exn-safety-the-stl-vectors">Exn Safety + the STL: vectors</a></li>
</ul>
</li>
<li><a href="#lecture-22">Lecture 22</a><ul>
<li><a href="#exception-safety-the-stl-continued">Exception Safety + the STL continued</a></li>
<li><a href="#casting">Casting</a><ul>
<li><a href="#staticcast-sensible-casts">static_cast - “sensible” casts</a></li>
<li><a href="#reinterpretcast-unsafe-implementation-specific-weird-casts">reinterpret_cast - Unsafe, implementation-specific, “weird” casts.</a></li>
<li><a href="#constcast-for-converting-between-const-non-const">const_cast - For converting between const + non-const</a></li>
<li><a href="#dynamiccast-is-it-safe-to-convert-a-book-to-a-text">dynamic_cast - Is it safe to convert a Book * to a Text * ?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-23">Lecture 23</a></li>
<li><a href="#lecture-24">Lecture 24</a><ul>
<li><a href="#template-functions">Template Functions</a></li>
<li><a href="#stl-algorithm-library">STL <algorithm> library</algorithm></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>



<h2 id="lecture-1">Lecture 1</h2>



<h3 id="linux-please">Linux, Please</h3>

<blockquote>
  <p>Options: <br>
  1. Lab, computers <br>
  2. Install Linux on your machine <br>
  3. ssh into school machines (recommended) (Windows: download putty.exe, winscp for file transfer) <br>
  4. Cygwin - ewwwwwww <br>
  Also - install an xwindows server. eg. XMing</p>
</blockquote>

<p>Modules:  <br>
1 - Linux Shell (2 weeks) <br>
2 - C++ (10 weeks) <br>
3 - Tools (interspersed) <br>
4 - Software engineering (interspersed)</p>

<p>Homework: Print Linux handout from Piazza, and bring it to class</p>



<h3 id="module-1-linux-shell">Module 1 - Linux Shell</h3>

<blockquote>
  <p>Shell - interface to OS - get the OS to do things - run programs, manage files - graphical shell (clicking with mouse/ touch interface) - command line - type commands at a prompt - more versatile</p>
</blockquote>

<p>This course: bash</p>

<p>Make sure you are using bash! - Log in + type echo $0 <br>
- should say bash</p>



<h3 id="linux-file-system">Linux File System</h3>

<p>Working with files <br>
- cat - displays the contents of a file <br>
- cat /usr/share/dict/words <br>
- general format: root (top) directory/ directories (contains files)/ file</p>

<blockquote>
  <p>In Linux, a directory is considered a kind of file</p>
</blockquote>

<p><code>^C</code> to stop a program <br>
ls : list files in current dir (non-hidden files) <br>
ls -a : gives all files (even hidden ones) <br>
hidden files start with a dot <br>
pwd - prints current directory</p>

<p>What happens if you type cat? <br>
- waits for input <br>
- prints everything you type <br>
Useful? - if we can capture input in file. <br>
Observe: </p>

<p><code>cat &gt; output.txt</code></p>

<p>To stop: Ctrl - D (^D) at the beginning of a line sends an end of file signal <br>
In general: command args &gt; file ; executes command args + captures the output in file <br>
- called <strong><em>output redirection</em></strong></p>

<p>Can also redirect input:</p>

<p><code>cat &lt; inputfile.txt</code></p>

<ul>
<li>takes input from inputfile.txt instead of keyboard</li>
<li>displays inputfile.txt</li>
<li>seems equal to cat inputfile.txt</li>
</ul>

<p>What’s the difference?</p>

<p><code>cat inputfile.txt</code></p>

<p>passes the name <code>inputfile.txt</code> as an arg to cat. cat opens the file and displays it</p>

<p><code>cat &lt; inputfile.txt</code></p>

<p>SHELL opens <code>inputfile.txt</code> and passes the contents to cat in place of keyboard or input</p>

<p>Observe:</p>



<pre class="prettyprint"><code class=" hljs avrasm">wc output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span> output<span class="hljs-preprocessor">.txt</span>

wc &lt; output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span></code></pre>

<p>Also: <code>cat *.txt</code> &lt;- globbing pattern <br>
(* means match any sequence of chars) <br>
- shell finds all files in the current dir that matches the pattern + substitutes on the cmd line.  <br>
(eg. <code>cat a.txt, b.txt, c.txt</code> - opens all 3 and displays)</p>

<p>More globbing patterns - Linux Sheet <br>
Many, but not all programs accept input either on the command line or by redirection</p>

<p>Can do both redirections <br>
<code>cat &lt; in.txt &gt; out.txt</code></p>

<p>Every process is attached to 3 streams: stdin, stderr, stdout</p>

<dl>
<dt>By default</dt>
<dd>stdin = keyboard - redirect with &lt;</dd>

<dd>stdout, stderr = screen (redirect with &gt;)</dd>

<dt>stderr</dt>
<dd>separate output stream - for error messages</dd>

<dd>so that output + error messages can go to different places</dd>

<dd>so that error msgs don’t clutter output file + corrupt formatting <br>
Also: stdout may be buffered - system may wait to accumulate output before actually printing it ( flushing the buffer)</dd>
</dl>

<p>stderr - never buffered - get errror msgs immediately</p>



<h3 id="pipes">Pipes</h3>

<p>Use output from one program as the input of another</p>

<blockquote>
  <p><strong>Example: How many words occur in the first 20 lines of myfile.txt?</strong> <br>
  Tools (sheet): <br>
  <code>head -n file</code> gives the first n lines of the file <br>
  <code>wc</code> counts words, lines, characters <br>
  <code>wc -w</code> gives just words <br>
  Soln: head -20 myfile.txt | wc -w <br>
  the | is a pipe</p>
</blockquote>



<h2 id="lecture-2">Lecture 2</h2>



<h3 id="pipes-cont">Pipes Cont.</h3>

<p>How many words occur in the first 20 lines of myfile.txt? <br>
Sol’n <code>head -20 myfile.txt | wc -w</code> or <code>cat myfile.txt | head -20 | wc -w</code></p>

<p>Eg. Suppose words1.txt, words2.txt, etc. contain lists of words, one per line. Print a duplicate-free list of all words that occur in any of these lines.</p>

<blockquote>
  <p><strong>uniq</strong> - removes CONSECUTIVE duplicate entries -if entries are sorted, then it removes <em>all</em> duplicates <br>
  <strong>sort</strong> - sorts lines</p>
</blockquote>

<p><code>cat words*.txt | sort | uniq</code></p>

<p>Can we use the output of one program as param of another? (yes)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> <span class="hljs-string">"Today is <span class="hljs-variable">$(date)</span> and I am <span class="hljs-variable">$(whoami)</span>"</span>
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Shell executes date + whoami + substitues the result into the command line <br>
The quotations make it into only ONE arg. Also, whitespace here is used.</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> Today is $(date) and I am           $(whoami)
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Here, echo is given 7 arguments. Whitespace is ignored</p>

<blockquote>
  <p>Careful: </p>
  
  <pre class="prettyprint"><code class=" hljs applescript">echo 'Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)'
&gt; Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)</code></pre>
  
  <p>Single quotes does not make any substitutions.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs delphi">echo *
echo <span class="hljs-string">'*'</span> #outputs the same <span class="hljs-comment">(*)
echo "*" #outputs the same (*)</span></code></pre>



<h3 id="pattern-matching-in-text-files">Pattern-Matching in Text Files</h3>

<dl>
<dt>egrep (“extended global regular expression print”)</dt>
<dd>egrep pattern file - prints every line in a file that contains a match to pattern</dd>
</dl>

<p>eg. Print every line in index.html that contains cs246.</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep cs246 index.html</code></pre>

<p>How many lines in index.html contain cs246 or CS246?</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"cs246|CS246"</span> index.html | wc <span class="hljs-operator">-l</span> //the quotes are really important here since bash thinks | is a pipe otherwise</code></pre>

<p>Alt soln:</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"(cs|CS)246"</span> index.html | wc <span class="hljs-operator">-l</span></code></pre>

<p>Available patterns - called regular expressions (different from globbing patterns)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-string">"(c|C)(s|S)246"</span> -also matches cS246, Cs246
<span class="hljs-string">"[cC][sS]246"</span></code></pre>

<p>[..] - any one char between [ and ] <br>
[<script type="math/tex" id="MathJax-Element-1">\text{^}</script> .. ] - any one char except</p>

<p>Add optional space:  <code>"[cC][sS] ?246"</code> <br>
? = 0 or 1 of the preceding expression (0 or 1 space in this case) <br>
* = 0 or more of preceding </p>



<pre class="prettyprint"><code class=" hljs r"><span class="hljs-string">"(cs)*246"</span>
&gt; <span class="hljs-number">246</span>, cs246, cscs246 <span class="hljs-keyword">...</span></code></pre>

<p>. = any single character <br>
.* = anything</p>



<pre class="prettyprint"><code class=" hljs perl">egrep <span class="hljs-string">"cs.<span class="hljs-variable">*246</span>"</span> <span class="hljs-keyword">index</span>.html</code></pre>

<ul>
<li>lines containing cs(anything) 246</li>
<li>^, $ - beginning + end of a line <br>
<code>"^cs246"</code> - lines that start with 246 <br>
<code>"^cs246$"</code> - lines that are exactly 246 <br>
+ = 1 or more occurrences of preceding pattern <br>
.+ - non-empty.</li>
</ul>

<p>Eg lines of even length</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-string">"^(..)*$"</span></code></pre>

<p>Files in the current dir whose names contain exactly one a.</p>



<pre class="prettyprint"><code class=" hljs 1c">ls <span class="hljs-string">| egrep "</span>[^a]*a[^a]*<span class="hljs-string">"</span></code></pre>

<p>All words in the global dictionary that start with e and have 5 characters</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">egrep <span class="hljs-string">"^e....$"</span> /usr/share/dict/<span class="hljs-keyword">words</span></code></pre>



<h3 id="permissions">Permissions</h3>

<p><code>ls - l</code> - “long form” listening</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-attribute">-rw</span><span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span> <span class="hljs-number">1</span> j2smith j2smith <span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span> abc<span class="hljs-built_in">.</span>txt
(<span class="hljs-subst">-</span>)<span class="hljs-keyword">type</span><span class="hljs-subst">|</span>(rw<span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span>)permissions<span class="hljs-subst">|</span>(<span class="hljs-number">1</span>)<span class="hljs-variable">#of</span> links<span class="hljs-subst">|</span> (j2smith) owner<span class="hljs-subst">|</span> (j2smith) <span class="hljs-keyword">group</span><span class="hljs-subst">|</span> (<span class="hljs-number">25</span>) size <span class="hljs-subst">|</span> (<span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>) last modified <span class="hljs-subst">|</span> (abc<span class="hljs-built_in">.</span>txt) name</code></pre>

<dl>
<dt>groups</dt>
<dd>a user can belong to one or more groups</dd>

<dd>a file can be associated with one group</dd>

<dt>type</dt>
<dd><code>-</code> an ordinary file</dd>

<dd><code>d</code> directory</dd>

<dt>permissions</dt>
<dd><code>rwxrwxrwx</code> -&gt; 1st rwx bits are “user bits”, then next 3 are “group bits”, last is “other bits” <br>
<strong>Apply to:</strong> <br>
- user bits: file’s owner <br>
- group bits: members of the file’s group other than the owner <br>
- other bits: everyone else <br>
<code>r</code> - read bit <br>
<code>w</code> - write bit <br>
<code>x</code> - execute bit</dd>
</dl>

<table>
<thead>
<tr>
  <th>Bit</th>
  <th>Meaning for Ordinary Files</th>
  <th>Meaning for directories</th>
</tr>
</thead>
<tbody><tr>
  <td>r</td>
  <td><code>files contents can be read</code></td>
  <td><code>directory's contents can be read (eg. ls works, globbing, tab completion)</code></td>
</tr>
<tr>
  <td>w</td>
  <td><code>files contents can be modified</code></td>
  <td><code>directory's contents can be modified</code></td>
</tr>
<tr>
  <td>x</td>
  <td><code>file can be executed as a program</code></td>
  <td><code>directory can be navigated (i.e. can cd into the dir)</code></td>
</tr>
</tbody></table>


<blockquote>
  <p>dir’s exec. bit not set = no access at all to the dir, nor to any subdir, nor to any file within it. <br>
  Changing permissions: <code>chmod mode file</code></p>
</blockquote>

<p>Mode:</p>

<table>
<thead>
<tr>
  <th></th>
  <th></th>
  <th></th>
</tr>
</thead>
<tbody><tr>
  <td>u - user</td>
  <td><ul>
add perm
</ul></td>
  <td>r read</td>
</tr>
<tr>
  <td>g - group</td>
  <td><ul>
remove perm
</ul></td>
  <td>w write</td>
</tr>
<tr>
  <td>o - other</td>
  <td>= set perm</td>
  <td>x execute</td>
</tr>
<tr>
  <td>a- all</td>
  <td></td>
  <td></td>
</tr>
</tbody></table>


<p>eg.  <br>
give others read permission: chmod o+r file  <br>
make everyone’s permission rx: a = rx <br>
give owner full control: u = rwx or u+rwx</p>

<blockquote>
  <p>Changing permissions - &gt; exclusive right of the owner</p>
</blockquote>



<h2 id="lecture-3">Lecture 3</h2>



<h3 id="shell-scripts">Shell Scripts</h3>

<blockquote>
  <p>files containing sequences of shell commands, executed as programs</p>
</blockquote>

<p>eg. Print date, current user, current dir</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-comment">#!/bin/bash //"shebang" line - executes this file as a bash script</span>
date
whoami
<span class="hljs-built_in">pwd</span></code></pre>

<blockquote>
  <p>Note: the script does not have the execute bit turned on. Give the file execute permission: <code>chmod u+x myscript</code> <br>
  Run the file: <code>./myscript</code></p>
</blockquote>



<h3 id="variables">Variables</h3>

<p><code>x=1</code> (NO spaces)</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
&gt; <span class="hljs-number">1</span></code></pre>

<blockquote>
  <p>Note: use <script type="math/tex" id="MathJax-Element-2"> when fetching the value of a var  
  No </script> when setting a var. <br>
  Good practice: <script type="math/tex" id="MathJax-Element-3">{x}  
  All vars contain STRINGS. x is the string 1  
  Eg. dir=~cs246  
  echo </script>{dir}</p>
</blockquote>

<p>Some “global” vars available: <br>
Important: PATH - list of dirs; When you type a command, the shell searches these directories in order for a program with that name</p>

<blockquote>
  <p>Eg. Check whether a word is in the directory <br>
  eg. <code>./isItAWord hello</code></p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/shar/dict/words</code></pre>

<blockquote>
  <p>Prints nothing if word not found <br>
  Prints the word if found</p>
</blockquote>

<p>Eg. - a good password should not be in the dictionary <br>
answer whether a word is a good password</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/share/dict/words &gt; /dev/null //(suppresses output)
<span class="hljs-keyword">if</span> [ $? <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> ]; <span class="hljs-keyword">then</span> //the ; here allows you to put the <span class="hljs-keyword">then</span> on the same line
    <span class="hljs-built_in">echo</span> Bad password
<span class="hljs-keyword">else</span> 
    <span class="hljs-built_in">echo</span> Maybe a good password
<span class="hljs-keyword">fi</span> //ends the <span class="hljs-keyword">if</span>?</code></pre>

<p>Note: every program returns a status code when finished <br>
egrep: returns 0 if found, 1 if not found (In Linux: 0 is success, non-0 is fail)</p>

<p>$? = status of the most recently executed command</p>

<p>Verify # of args ; print error msg if wrong</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">usage</span></span>(){
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> password"</span> &gt;&amp;<span class="hljs-number">2</span>
}
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> <span class="hljs-operator">-ne</span> <span class="hljs-number">1</span>]; <span class="hljs-keyword">then</span>
    usage
    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">fi</span>
...(as before)</code></pre>



<pre class="prettyprint"><code class=" hljs r">If stmt: //comparisons + other conditions handout
    <span class="hljs-keyword">if</span> [ cond ]; then
        <span class="hljs-keyword">...</span>
    elif [ cond ]; then
        <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">...</span>
fi</code></pre>



<h3 id="loops">Loops</h3>

<p>Print #’s from 1 to $1</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
x=<span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> [ <span class="hljs-variable">$x</span> -le <span class="hljs-variable">$1</span>]; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
    x=<span class="hljs-variable">$x</span>+<span class="hljs-number">1</span>
<span class="hljs-keyword">done</span></code></pre>

<p>This gives you “1+1” literally if x=1 <br>
you want $((…)) for arithmetic instead</p>

<p>Looping over a list <br>
eg. Rename all .cpp files to .cc</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *.cpp; <span class="hljs-keyword">do</span>
    mv <span class="hljs-variable">${name}</span> <span class="hljs-variable">${name%cpp}</span>cc
<span class="hljs-keyword">done</span></code></pre>

<blockquote>
  <p>note: <br>
  *.cpp -&gt; glob - replaced with all matching files  <br>
  name%cpp is the val of name, without the trailing cpp.</p>
</blockquote>

<p>How many times does word <script type="math/tex" id="MathJax-Element-4">1 appear in file </script>2?</p>



<pre class="prettyprint"><code class=" hljs bash">x=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$2</span>); <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span> = <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]; <span class="hljs-keyword">then</span>
        x=$((x+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span></code></pre>

<blockquote>
  <p>Payday is the last Friday of the month. When is this month’s payday? <br>
  2 tasks: Compute date <br>
               Report answer</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">answer</span></span>(){
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month is the 31st"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month: the <span class="hljs-variable">${1}</span>th"</span>
}<span class="hljs-keyword">fi</span>
answer $(cal | awk <span class="hljs-string">'{print $6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<p>Generalize to any month. <code>cal October 2016</code> -gives Oct’s calendar <br>
let payday October 2016 give october’s payday</p>

<p>ALL OF THESE ARE IN THE REPO</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-function"><span class="hljs-title">answer</span></span>(){
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$2</span> ]; <span class="hljs-keyword">then</span>
        preamble=<span class="hljs-variable">$2</span>
    <span class="hljs-keyword">else</span>
        preamble = <span class="hljs-string">"This month"</span>
    <span class="hljs-keyword">fi</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble}</span>: the 31st"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble: the ${1}</span>th}"</span>
    <span class="hljs-keyword">fi</span>
}
answer $(cal <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> | awk <span class="hljs-string">'{print #6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<blockquote>
  <p>note: no such thing as scope. You can reference from anywhere. if the var doesn’t exist, you get a blank.</p>
</blockquote>



<h2 id="lecture-4">Lecture - 4</h2>



<h3 id="se-topic-testing">SE Topic: Testing</h3>

<ul>
<li>essential part of program development</li>
<li>on going  <br>
<ul><li>not just at the end</li>
<li>Begins <strong>before</strong> you start coding</li>
<li>Test suites - expected behaviour <br>
<script type="math/tex" id="MathJax-Element-5">\neq</script> debugging - cannot debug without first testing</li></ul></li>
<li>cannot guarantee correctness - cannot prove wrongness</li>
<li>ideally, developer + tester should be different people</li>
</ul>

<p>Human testing </p>

<ul>
<li>humans look over code, find flaws</li>
<li>code inspections, walk throughs</li>
<li>not on your assignments</li>
</ul>

<p>Machine testing</p>

<ul>
<li>run program on selected input, check against spec</li>
<li>can’t check everything <br>
<ul><li>choose test cases carefully</li></ul></li>
</ul>

<p>Black/White/Grey Box Testing</p>

<ul>
<li>no/full/some knowledge of implementation</li>
</ul>

<p>Start with black box, supplement with white box</p>

<p>Black box:</p>

<ul>
<li>various classes of input <br>
<ul><li>numeric ranges</li>
<li>positive vs. negative</li></ul></li>
<li>boundaries of valid ranges (edge cases)</li>
<li>multiple simultaneous boundaries (corner cases)</li>
<li>intuition/experience - guess at likely errors</li>
<li>extreme cases</li>
</ul>

<p>White box:</p>

<ul>
<li>execute all logical paths through the program</li>
<li>make sure every f’n runs</li>
</ul>

<p>Performance testing - is the program efficient enough? <br>
Regression testing</p>

<ul>
<li>make sure new changes to program don’t break old test caes</li>
<li>test suites, testing scripts</li>
</ul>



<h3 id="module-2-c">Module 2: C++</h3>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">//Hello world in C:</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Hello world in C++:</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hello world"</span> &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>Notes: main <strong>must</strong> return int in C++ (if no return in main, 0 is implied)</p>
</blockquote>

<ul>
<li><code>stdio.h</code> , <code>printf</code> still available in c++</li>
<li>preferred C++ <code>I/O</code> header <code>&lt;iostream&gt;</code></li>
</ul>

<p>Output: <br>
std::cout &lt;&lt; ___ &lt;&lt; ___ &lt;&lt; ___ (___ is data) <br>
std::endl = end of line</p>

<ul>
<li>using namespace std: <br>
<ul><li>lets you say cout/endl instead of std::cout/std::endl</li></ul></li>
</ul>



<h3 id="compiling-c-programs">Compiling C++ programs</h3>

<p><code>g++-5 -std=c++14 program.cc &lt;-o program&gt; (name of the excutable(by default, a.out))</code></p>

<p>OR</p>

<p><code>g++14 program.cc -o program</code> <br>
<code>./program</code></p>



<h3 id="inputoutput">Input/Output</h3>

<p>3 I/O streams: </p>

<ul>
<li>cin - for reading from stdin</li>
<li>cout, cerr - for printing to stdout, stderr</li>
</ul>

<p>I/O operators:</p>

<ul>
<li>&lt;&lt; “put to” (output)</li>
<li>&gt;&gt; “get from” (input)</li>
<li>cerr &lt;&lt; x;</li>
<li>cin &gt;&gt; x; <br>


<blockquote>
  <p>operator points in the direction of information flow</p></blockquote></li>
  </ul> <br>
  E.g. Add 2#’s







<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> nanospace <span class="hljs-built_in">std</span>
<span class="hljs-comment">//above two lines are usually there even if teach doesn't write it (omit from now on)</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;
    <span class="hljs-built_in">cout</span> &lt;&lt; x + y &lt;&lt; endl;
}</code></pre>




<blockquote>
  <p>notes: <code>cin &gt;&gt; ignores whitespace</code> <br>
  what if input doesn’t contain an int? -statement fails, value of var is undefined</p>
</blockquote>

What if the input is exhausted before we get two ints?

<ul>
<li>same as before</li>
</ul>

<hr>

<p>If the read failed: <code>cin.fail()</code> will be true <br>
If EOF: <code>cin.eof()</code> and <code>cin.fail()</code> will both be true</p>

<ul>
<li>but not until attempted read fails</li>
</ul>

<p>Ex: read all ints from stdin, echo them and per line to std out. Stop on any failure.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &gt;&gt; i;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.fail()) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: Here is an implicit conversion from cin to bool</p>
  
  <ul>
  <li>cin can be used as a condition - true if success, false if failed</li>
  </ul>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v2.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &lt;&lt; i;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cin</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: &gt;&gt; is c’s right bitshift operator. <code>a &gt;&gt; b</code> shifts  a’s bits to the right by b spots. <br>
  E.g. 21 &gt;&gt; 3 -&gt; 21 = 10101 shifted 3 =<script type="math/tex" id="MathJax-Element-6">10_{\text(binary)}</script> = 2 <br>
  But when LHS is cin, &gt;&gt; is “get from”</p>
</blockquote>

<p>operator &gt;&gt;: </p>

<ul>
<li>inputs: cin (stream), data (variety of types)</li>
<li>output? - returns cin (istream)</li>
</ul>

<p>This is why we can write <code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</code> the &gt;&gt; returns cin as each &gt;&gt; is calculated, which allows y and z to also be read in.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v3.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v4.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; i){
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<h2 id="lecture-5">Lecture 5</h2>

<p>Ex: Read ints + echo to stdout until EOF. Skip all non-int input</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)){
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.eof()) <span class="hljs-keyword">break</span>;
            <span class="hljs-built_in">cin</span>.clear(); <span class="hljs-comment">//clears the fail bit</span>
            <span class="hljs-built_in">cin</span>.ignore(); <span class="hljs-comment">//skips the next char (because the char causing this to fail is still there)</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt;i &lt;&lt; endl;
    }
}</code></pre>



<h3 id="reading-strings">Reading Strings</h3>

<p><code>type std::string (#include &lt;string&gt;)</code></p>

<ul>
<li>more details later</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s; <span class="hljs-comment">//skip leading whitespace (stop at whitespace)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">//(therefore only reads one word)</span>
}</code></pre>

<p>If we want the whitespace: <code>getline(cin, s);</code></p>

<ul>
<li>reads from current position to next newline into s.</li>
</ul>

<p><code>cout &lt;&lt; 95 &lt;&lt; endl;</code></p>

<p>What if we want to print a # in hexadecimal?</p>

<p><code>cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; endl; \\prints 5f</code></p>

<blockquote>
  <p>hex : I/O manipulator - all subsequent ints printed in hex</p>
</blockquote>

<p><code>cout &lt;&lt; dec</code> to go back to decimal</p>

<p>Other manipulators - notes <code>#include &lt;iomanip&gt;</code></p>

<p>Stream abstraction applies to other sources of data</p>

<p>Files </p>

<ul>
<li>Read from a file instead of stdin</li>
<li>std::ifstream - read from a file</li>
<li>std::ofstream - write to a file</li>
</ul>

<p>File access in C:</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">char</span> s[<span class="hljs-number">256</span>];
    FILE *file = fopen(<span class="hljs-string">"myfile.txt"</span>,<span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">"%255s"</span>, s);
        <span class="hljs-keyword">if</span>(feof(file)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    }
    fclose(file);
}</code></pre>

<p>C++:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    ifstream file{<span class="hljs-string">"myfile.txt"</span>}; <span class="hljs-comment">// Initialization syntax. Declaring an ifstream opens the file</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(file &gt;&gt; s){
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
    } <span class="hljs-comment">// file is closed automatically as soon as the ifstream (file) goes out of scope :o woah</span>
}</code></pre>

<blockquote>
  <p>note: This is the same as reading from cin in c++ except we use file in the while loop.</p>
</blockquote>

<p>Anything you can do with cin/cout, you can also do with an ifstream/ofstream.</p>

<p>Example - strings - attach a stream to a string var + read from/write to it</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include&lt;sstream&gt;</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span>
<span class="hljs-comment">//-read from/write to a string</span>
<span class="hljs-keyword">int</span> lo = _____, hi = _____;
<span class="hljs-built_in">ostringstream</span> ss;
ss &lt;&lt; <span class="hljs-string">"Enter a # btwn "</span> &lt;&lt; lo &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; hi;
<span class="hljs-built_in">string</span> s = ss.str();</code></pre>

<p>Eg - convert string to #</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter a # "</span> &lt;&lt;endl;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s;
    (<span class="hljs-built_in">string</span> stream ss {s}); <span class="hljs-comment">// {s} &lt;- initialization</span>
    <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"I said, "</span>;
}
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"You entered "</span> &lt;&lt; n &lt;&lt; endl;</code></pre>

<p>Example revisited: Echo #’s, skip non-#’s</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; s){
        <span class="hljs-built_in">istringstream</span> ss {s};
        <span class="hljs-keyword">int</span> n;
        <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
    }
}</code></pre>



<h3 id="strings">Strings</h3>

<p>In C: </p>

<ul>
<li>array of char (char* or char[]) terminated by ‘\0’</li>
<li>explicitly manage memory - allocate more as strings get larger</li>
<li>easy to overwrite \0 and corrupt memory</li>
</ul>

<p>C++ strings:</p>

<ul>
<li>grow as needed (no memory management)</li>
<li>safer to manipulate</li>
</ul>

<p>Eg: string s = “Hello”; // still a c-style string (char array with \0)</p>

<blockquote>
  <p>s  -  c++ string created from the c string on initialization</p>
</blockquote>



<h3 id="string-operations">String Operations:</h3>

<p>Equality - s1 == s2, s1 != s2 <br>
Comparison - s1 &lt;= s2 (lexicographic) <br>
Get individual chars - s[0] , s[1], … etc <br>
Concat: s3 = s1 + s2;   s3 += s4</p>



<h3 id="default-fn-params">Default f’n Params</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> printWordsInFile(<span class="hljs-built_in">string</span> name = <span class="hljs-string">"suite.txt"</span>){
    ifstream file {name};
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (file &gt;&gt; s) <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
}
printWordsInFile(<span class="hljs-string">"suite2.txt"</span>);
printWordsInFile(); <span class="hljs-comment">//uses stuite.txt</span></code></pre>

<blockquote>
  <p>Note: Optional parameters must be LAST</p>
</blockquote>



<h3 id="overloading">Overloading</h3>

<p>C:</p>

<ul>
<li><code>int negInt(int n) {return -n;}</code></li>
<li><code>bool negBool(bool b) {return !b;}</code></li>
</ul>

<p>C++</p>

<p>F’ns with different param lists can share the same name <br>
<code>int neg(int n) {return -n;}</code> <br>
<code>bool neg(bool b) {return !b;}</code></p>

<p>Compiler uses # + type of args to decide which neg is being called <br>
Overloads must differ in # or types of args - may not differ on just return type</p>



<h2 id="lecture-6">Lecture 6</h2>



<h3 id="structs">Structs</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node next; <span class="hljs-comment">//what's wrong? This makes the struct have no finite size since</span>
    <span class="hljs-comment">// this contains a node in a node in a node ... etc which has no calculable size</span>
};</code></pre>



<h3 id="constants">Constants</h3>

<p><code>const int maxGrade = 100; // must be initialized</code></p>

<p><code>Node n1 = {5, nullptr}; \\syntax for a null ptr. Do not say NULL or 0 in this class</code></p>

<p><code>const Node n2=n1</code></p>

<ul>
<li>immutable copy of n1</li>
<li>can’t change n2’s fields</li>
</ul>



<h3 id="parameter-passing">Parameter Passing</h3>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> n){++n;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 5</span></code></pre>

<p>call-by-value-inc gets a copy of x, increments the copy, original unchanged</p>

<p>If a function needs to modify an arg - pass a ptr</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc(<span class="hljs-keyword">int</span> *n){(*n)++;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(&amp;x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 6</span></code></pre>

<blockquote>
  <p>Q: why cin &gt;&gt; x and not cin &gt;&gt; &amp;x ? <br>
  A: C++ has another ptr-like type: references</p>
</blockquote>



<h3 id="references">References</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> &amp;z = y; <span class="hljs-comment">//z is an lvalue reference to y. Like a const ptr.</span>
<span class="hljs-comment">//similar to int *const z = &amp;y;</span></code></pre>

<p>References are like constant ptrs with automatic de-referencing  <br>
z -&gt; y [10]</p>



<pre class="prettyprint"><code class="language-cpp hljs ">z = <span class="hljs-number">12</span>; <span class="hljs-comment">//(NOT *z = 12)</span>
<span class="hljs-comment">//(now, y == 12)</span>

<span class="hljs-keyword">int</span> *p = &amp;z; <span class="hljs-comment">// gives the address of y</span></code></pre>

<p>In all cases, z behaves exactly like y.</p>

<p>z is an alias (“another name”) for y</p>

<p><strong>Things you can’t do with lvalue references:</strong></p>

<ol>
<li>Leave them uninitialized. eg int &amp;x; <br>
<ul><li>Must be initialized to something that has an address (an lvalue), since refs are ptrs: <code>int &amp;x = 3;</code> X , <code>int &amp;x = y + z;</code> X , <code>int &amp;x = y;</code> Is okay</li></ul></li>
<li>Create a ptr to a reference: <br>
<ul><li><code>int &amp;*x;</code>- for c, always start at var and then go left. So x is a pointer to a ref of an int.</li>
<li>ref to ptr OK: <code>int *&amp;x = ... ;</code></li></ul></li>
<li>Create a reference to a reference <br>
<ul><li><code>int &amp;&amp;x = ... ;</code> - this means something difference (we’ll talk about this later)</li></ul></li>
<li>Create an array of references: <code>int &amp;r[3] = {n,n,n};</code> X</li>
</ol>

<p>What <em>can</em> you do? pass as f’n params:</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> &amp;n){++n;} <span class="hljs-comment">// notice that there's no ptr deref and &amp;n is a const. ptr to the arg.</span>
<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 6</span></code></pre>

<blockquote>
  <p>So why does cin &gt;&gt; x work? - takes x by reference</p>
</blockquote>

<p><code>istream &amp; operator &gt;&gt; (istream &amp;in, int&amp;data)</code></p>

<p>Pass-by-value. eg: <code>int f(int n) { ... } copies the arguement</code></p>

<ul>
<li>if the arg is big, copying can be expensive <br>
eg: <code>struct Really Big { ... }</code>,</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(ReallyBig rb){ ... }; <span class="hljs-comment">// really slow</span>
<span class="hljs-keyword">int</span> g(ReallyBig &amp;rb){ ... }; <span class="hljs-comment">// &amp;rb is now an alias - fast. Downside is that rb can be changed by the f'n. You don't know.</span>
<span class="hljs-keyword">int</span> h(<span class="hljs-keyword">const</span> ReallyBig &amp;rb) { ... }; <span class="hljs-comment">// really fast and param can't be changed. woah</span></code></pre>

<p>Advice: prefer pass-by-const-ref over pass-by-value for anything larger than a ptr - unless the f’n needs to make a copy anyway. Then, maybe pass-by-value.</p>

<p>Also: <code>int f(int &amp;n) { ... }</code>      <code>int g(const int &amp;n) { ... }</code></p>



<pre class="prettyprint"><code class="language-cpp hljs ">f(<span class="hljs-number">5</span>); <span class="hljs-comment">// won't compile. can't initialize an lvalue ref (n) to a literal value. if n changes, can't change the literal 5.</span>
g(<span class="hljs-number">5</span>); <span class="hljs-comment">//is a-OK since n can never be changed. Compiler allows this. How? compiler creates a temp location to hold the 5, so the reference n has something to point to.</span></code></pre>



<h3 id="dynamic-memory-allocation">Dynamic Memory Allocation</h3>

<p>C: </p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>( ... *<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
...
<span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//DON'T USE THESE IN C++</span></code></pre>

<blockquote>
  <p>Instead: new/delete - type aware and less error-prone</p>
</blockquote>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};

Node *np = <span class="hljs-keyword">new</span> Node;
...
<span class="hljs-keyword">delete</span> np;</code></pre>

<ul>
<li>all local vars reside on the stack - vars are deallocated when they go out of scope (stack is popped).</li>
<li>allocated memory resides on the heap.</li>
<li>remains allocated until delete is called</li>
<li>if you don’t delete all allocated memory - memory leak</li>
<li>program will eventually fail - incorrect behaviour</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">10</span>];
...
<span class="hljs-keyword">delete</span> [np];</code></pre>



<pre class="prettyprint"><code class=" hljs coffeescript">Node getMeANode(){ <span class="hljs-regexp">//</span><span class="hljs-keyword">return</span>-<span class="hljs-keyword">by</span>-value = copy. expensive?
    Node n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-regexp">//</span>-<span class="hljs-keyword">return</span> <span class="hljs-keyword">by</span> ptr(ret) instead?
Node *getMeANode(){
    Node n;
    <span class="hljs-keyword">return</span> &amp;n;
    <span class="hljs-regexp">//</span>BAD - returns a ptr to stack - allocated data which <span class="hljs-keyword">is</span> dead <span class="hljs-literal">on</span> <span class="hljs-keyword">return</span>
}

Node *getMeANode(){ <span class="hljs-regexp">//</span>Ok - returns a ptr to Heap data - still alive - but don<span class="hljs-string">'t forget to delete it!
    return new Node;
}</span></code></pre>



<h2 id="lecture-7">Lecture 7</h2>



<h3 id="operator-overloading">Operator Overloading</h3>

<p>Give meanings to c++ operators for our own types <br>
eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    Vec v={v1.x + v2.x , v1.y + v2.y};
    <span class="hljs-keyword">return</span> v;
}

Vec <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> {k*v.x, k*v.y} <span class="hljs-comment">//okay since compiler knows that it's a vec based on the return type</span>
}
<span class="hljs-comment">// this only works when scalar is on the left (eg. k*v). To get v*k, we need to make another function.</span>
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Vec &amp;v, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k){
    <span class="hljs-keyword">return</span> k*v;
}</code></pre>



<h3 id="overloading-and">Overloading &lt;&lt; and &gt;&gt;</h3>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Grade{
    <span class="hljs-keyword">int</span> theGrade;
};

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Grade &amp;g){
    out &lt;&lt; g.theGrade &lt;&lt; <span class="hljs-string">'%'</span>;
    <span class="hljs-keyword">return</span> out
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, Grade &amp;g){
    in &gt;&gt; g.theGrade;
    <span class="hljs-keyword">if</span>(g.theGrade &lt; <span class="hljs-number">0</span>) g.theGrade=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(g.theGrade&gt;<span class="hljs-number">100</span>) g.theGrade=<span class="hljs-number">100</span>;
    <span class="hljs-keyword">return</span> in;
}</code></pre>



<h3 id="the-preprocessor">The Preprocessor</h3>

<p>Transforms the program before the compiler sees it. #<script type="math/tex" id="MathJax-Element-7">\text{_____}</script> = preprocessor directive</p>

<p>eg.<code>#include</code> <br>
Including old C headers - new naming convention <br>
eg. Instead of <code>#include &lt;stdio.h&gt;, use #include&lt;cstdio&gt;</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define VAR VALUE <span class="hljs-comment">//- sets a preprocessor variable, then all occurrences of VAR in the source file are replaced with VALUE</span></span>
<span class="hljs-preprocessor">#define MAX 10</span>
<span class="hljs-keyword">int</span> x[MAX] <span class="hljs-comment">//transformed to int x[10]. Was a cheap way of const from the old days (1970s) before const was a thing</span>

<span class="hljs-preprocessor">#define FLAG <span class="hljs-comment">//sets the variable FLAG; Value is the empty string</span></span></code></pre>

<p>Defined constants are useful for conditional compilation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define IOS 1</span>
<span class="hljs-preprocessor">#define BBOS 2</span>
<span class="hljs-preprocessor">#define OS IOS <span class="hljs-comment">//(or BBOS)</span></span>
<span class="hljs-preprocessor">#if OS==IOS</span>
    <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//Removed if OS!=IOS</span>
<span class="hljs-preprocessor">#elif OS==BBOS</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//this code is removed if OS!=BBOS</span>
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>Special Case</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#if 0 <span class="hljs-comment">//never true - all inner text is removed before it gets to the compiler</span></span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-comment">//heavy-duty "comment out"</span></code></pre>

<p>Can also define symbols via compiler arguments</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class="language-bash hljs ">g++<span class="hljs-number">14</span> -DX=<span class="hljs-number">15</span> define.cc -o define</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifdef NAME <span class="hljs-comment">//true if NAME has been defined</span></span>
<span class="hljs-preprocessor">#ifndef NAME <span class="hljs-comment">//true if NAME HAS NOT been defined</span></span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-preprocessor">#ifdef DEBUG</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"setting x=1"</span> &lt;&lt;endl;
    <span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(x&lt;<span class="hljs-number">10</span>){
        ++x;
        <span class="hljs-preprocessor">#ifdef DEBUG</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x is now"</span> &lt;&lt; endl;
        <span class="hljs-preprocessor">#endif</span>
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class=" hljs lua">gc++<span class="hljs-number">14</span> -DDEBUG <span class="hljs-built_in">debug</span>.cc -o <span class="hljs-built_in">debug</span>
//enables <span class="hljs-built_in">debug</span> output</code></pre>



<h3 id="separate-compilation">Separate Compilation</h3>

<p>Split program into composable modules, with</p>

<dl>
<dt>Interface</dt>
<dd>type definitions, prototypes for functions - .h file</dd>

<dt>Implementation</dt>
<dd>full definitions of functions - .cc file</dd>

<dt><em>Recall</em>: declaration</dt>
<dd>asserts existence</dd>

<dd>def’n - full details - allocates space (for vars/f’ns)</dd>
</dl>

<p>E.g. Interface (vec.h)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}
Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> main(){
    Vec v = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
    v = v+v;
    ...
}
<span class="hljs-comment">//implied vec.cc</span>

<span class="hljs-preprocessor">#include "vec.h" <span class="hljs-comment">//we include vec.h here because we don't know what a vec is.</span></span>
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
     ...
     ...
     ...
}</code></pre>

<blockquote>
  <p>Recall: an entity can be declared many times, but defined at most once</p>
</blockquote>



<h3 id="compiling-separately">Compiling Separately</h3>



<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">vec</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span>
<span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">main</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span></code></pre>

<blockquote>
  <p><code>-c</code> -&gt; means compile only, do not link, do not build the executable. Produces an object file.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs avrasm">g++<span class="hljs-number">14</span> vec<span class="hljs-preprocessor">.o</span> main<span class="hljs-preprocessor">.o</span> -o main</code></pre>



<h1 id="never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</h1>

<p>Global var: <code>int globalNum;</code></p>



<h2 id="lecture-8">Lecture 8</h2>

<p>vec.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
};
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> globalVar;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);</code></pre>

<p>vec.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> global Num;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    ...
}</code></pre>

<p>Let’s write a linear algebra module <br>
linalg.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>linalg.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>The above won’t compile:</p>

<ul>
<li>main.cc, linalg.cc include linalg.h, vec.h, linalg.h includes vec,h</li>
<li>main.cc, linalg.cc get 2 copies of vec.h therefore struct vec defined twice. x</li>
</ul>

<blockquote>
  <p>Need to prevent files from being included twice</p>
</blockquote>

<p>Sol’n: “include guard:” <br>
vec.h </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifndef VEC_H</span>
<span class="hljs-preprocessor">#define VEC_H</span>
... file contents
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>first time vec.h is included. Symbol VEC_H is not defined so file is included. After that, symbol is defined so vec.h is never included twice.</p>

<p>Always - put include guards in .h files <br>
Never - include .cc files - many many different functions. Included .cc file, you defined everything again and again and again.</p>

<p>Never - put using namespace std in header files. This directive would be forced on any client that includes this file <br>
- inside header files, always say std::cin, std::string etc.</p>



<h3 id="classes">Classes</h3>

<ul>
<li>can put functions inside of structs</li>
</ul>

<p>eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> assns*<span class="hljs-number">0.4</span> + mt*<span class="hljs-number">0.2</span> + final*<span class="hljs-number">0.4</span>;
    }
};
Student s{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; s.grade() &lt;&lt; endl;</code></pre>

<p>class </p>

<ul>
<li>a struct type that can contain f’ns</li>
<li>c++ has a class keyword - we will use it later</li>
</ul>

<p>object</p>

<ul>
<li>an instance of a class</li>
</ul>

<p>eg: <code>Student</code> - class, <code>s</code> - object, <code>{60, 70, 80}</code></p>

<p>The function grade - called a member function (or method) <br>
What doe assns, mt, final inside of grade ( ) {…} mean? <br>
- they are fields of the current object upon which grade was invoked</p>

<p>e.g. </p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>};
billy.grade(); \\method call uses billy<span class="hljs-string">'s assns, mt, final</span></code></pre>

<p>Formally: methods take a hidden extra parameter called this - ptr to the object on which the method was invoked. eg. billy.grade() &lt;- (this) == &amp;billy <br>
can write</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;assns *<span class="hljs-number">0.4</span> + <span class="hljs-keyword">this</span>-&gt;mt*<span class="hljs-number">0.2</span> + <span class="hljs-keyword">this</span>-&gt;final*<span class="hljs-number">0.4</span>;
    }
};</code></pre>

<p>Initializing Objects</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//ok, but limited</span></code></pre>

<p>Better: Write a method that does initialization: a constructor (ctor)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){...}
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final){
        <span class="hljs-keyword">this</span>-&gt;assns = assns;
        <span class="hljs-keyword">this</span>-&gt;mt = mt;
        <span class="hljs-keyword">this</span>-&gt;final = final;
    }
}

Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//better. Even though this looks the same as above, this calls a ctor if it has been defined. IF no ctor has been defined, these initialize the individual fields of student.</span></code></pre>

<p>Head allocation:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student xpBilly = <span class="hljs-keyword">new</span> Student{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Advantages  of ctors: default params, overloading, sanity checks</p>

<p>eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    Student(in assns = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> mt=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> final=<span class="hljs-number">0</span>){
        <span class="hljs-keyword">this</span>.assns = assns;
        <span class="hljs-keyword">this</span>.mt = mt;
        <span class="hljs-keyword">this</span>.final =final;
    }
}</code></pre>

<blockquote>
  <p>Note: Every class comes with a default (ie no-arg) ctor (which just default constructs all fields that are objects). <br>
  eg.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec v; <span class="hljs-comment">//default ctor (does nothing in this case, the fields aren't objects)</span></code></pre>

<p>But the built-in default ctor goes away if you provide a ctor <br>
E.g.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y){
        <span class="hljs-keyword">this</span>-&gt;x=x;
        <span class="hljs-keyword">this</span>-&gt;y=y;
    }
}
Vec v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}; OK
Vec v; XXXX</code></pre>

<p>What if a struct contains consts or refs?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> MyStruct{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst; <span class="hljs-comment">//these two have to be initialized</span>
    <span class="hljs-keyword">int</span> &amp;myRef;
};

<span class="hljs-keyword">int</span> z;
<span class="hljs-keyword">struct</span> MyStuct {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst = <span class="hljs-number">5</span>; 
    <span class="hljs-keyword">int</span> &amp;myRef=z;
}; <span class="hljs-comment">//this is kind of bad since not every MyStruct wants the same val. Compiles, though</span></code></pre>

<p>But does every instance of student need the same value of myConst, etc?</p>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//const (doesn't change) but not the same for all students.</span>
}</code></pre>

<p>Where do we initialize? ctor body? TOO LATE!</p>

<p>Where do we initialize? ctor body? - too late - fields must be fully constructed by then.</p>

<p>What happens when an object is created:</p>

<ol>
<li>space is allocated</li>
<li>fields are constructed //need to put our initializations here</li>
<li>ctor body runs</li>
</ol>

<p>How? - member initialization list (MIL)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">int</span> assns, mt, final;
    Student(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final):
        id{id}, assns{assns}, mt{mt}, final{final} {}
}</code></pre>

<blockquote>
  <p>Here: id - field, {id} - params <br>
  Note: can initialize any field this way, not just const + refs <br>
  Note: Fields initialized in the order in which they are declared in the class, even if the MIL orders them differently <br>
  Note: MIL sometimes more efficient than setting fields in the body. (o/w - run default ctor, then reassign in the body) EMBRACE THE MIL! ALL HAIL. PRAISE BE.</p>
</blockquote>

<p>what if a field is initialized inline AND in the MIL?</p>



<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">vec</span>(<span class="hljs-keyword">int</span> x); x{x} {}
};</code></pre>

<p>MIL takes precedence</p>



<h2 id="lecture-9">Lecture 9</h2>



<h3 id="uniform-initialization">Uniform Initialization</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> x(<span class="hljs-number">5</span>);
<span class="hljs-built_in">string</span> s = <span class="hljs-string">"hello"</span>;
<span class="hljs-built_in">string</span> s(<span class="hljs-string">"hello"</span>);
Student billy(<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>);
<span class="hljs-comment">//preferred (cs246 doesn't care which init you use though). This was updated as of a few years ago.</span>
<span class="hljs-keyword">int</span> x{<span class="hljs-number">5</span>};
<span class="hljs-built_in">string</span> s{<span class="hljs-string">"hello"</span>};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Now consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student bobby = billy; <span class="hljs-comment">//-how does this init happen? the COPY CONSTRUCTOR. For constructing one object as a copy of another</span></code></pre>

<blockquote>
  <p>Note: Every class comes with:</p>
  
  <ul>
  <li>default ctor (default constructs all fields that are objects) <br>
  <ul><li>copy ctor (just copies all the fields)</li>
  <li>copy assignment operator</li>
  <li>destructor</li>
  <li>move ctor</li>
  <li>move assignment operator</li></ul></li>
  </ul>
</blockquote>

<p>Building your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns,mt,final;
    Student(...) {...}
    Student(<span class="hljs-keyword">const</span> Student &amp;other): assns {assns}, mt {mt}, final {final} {}
}; <span class="hljs-comment">//equiv. to built in</span></code></pre>

<p>When is the built-in copy ctor not correct?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next
    Node(<span class="hljs-keyword">int</span> data, Node *next): data {data}, next{next} {}
    ...
};
Node *n = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
Node m = *n;
Node *p =<span class="hljs-keyword">new</span> Node{*n};</code></pre>

<p><img src="http://amyqiu.me/Notes/pointer.png"> <br>
Simple copy of fields -&gt; only the first node is actually copied (<em>shallow copy</em>) <br>
If you want a <em>deep copy</em> (copies the whole list),  must write your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(<span class="hljs-keyword">const</span> Node &amp;other): data{other.data}, next{ other.next? <span class="hljs-keyword">new</span> Node (*other.next) : <span class="hljs-keyword">nullptr</span>}{}
} <span class="hljs-comment">//we have some sneaky recursion going on here. This recursively invokes the copy ctor + copies the rest of the list</span></code></pre>

<p>The copy ctor is called:</p>

<ol>
<li>When an object initializes another object</li>
<li>When an object is passed by value</li>
<li>When an object is returned by value (* - not always)</li>
</ol>

<blockquote>
  <p>Note: Careful with ctors that can take ONE parameter:</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};</code></pre>

<p>single-arg ctors create implicit conversions. <br>
Eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">4</span>};
<span class="hljs-comment">// - also I can call:</span>
Node n =<span class="hljs-number">4</span>; <span class="hljs-comment">//- implicit conversion from int to node.</span>
<span class="hljs-keyword">int</span> f(Node n){...}
f(<span class="hljs-number">4</span>); <span class="hljs-comment">//works -4 is implicitly converted to Node</span></code></pre>

<blockquote>
  <p>Danger - accidentally passing an int to a f’n expecting a Node. Compiler will not signal an error. <br>
  Good idea - disable the implicit conversion - make the ctor explicit</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};
Node n{<span class="hljs-number">4</span>}; <span class="hljs-comment">//ok</span>
Node n = <span class="hljs-number">4</span>; <span class="hljs-comment">//error</span></code></pre>



<h3 id="destructors">Destructors</h3>

<p>When an object is destroyed (stack-allocated: goes out of scope, heap-allocated: is deleted) a method called the destructor runs. Classes comes with a dtor (just calls dtor on all fields that are objects) <br>
When an object is destroyed:</p>

<ol>
<li>The dtor body runs</li>
<li>field’s dtors invoked in reverse declaration order</li>
<li>space deallocated</li>
</ol>

<p>When do we need to write one?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span> <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};</code></pre>

<p>If np goes out of scope - the pointer is reclaimed (stack-allocated). The entire list is leaked. <br>
If we say <code>delete np;</code> then the 2 &amp; 3 nodes are leaked</p>

<p>Write a dtor to ensure the whole list is freed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;} <span class="hljs-comment">//&lt;- recursively calls next's dtor - frees the whole list.</span>
};</code></pre>

<p>Now - <code>delete np;</code> -frees the whole list</p>



<h3 id="copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane = billy; <span class="hljs-comment">//copy ctor</span>
Student mary; <span class="hljs-comment">//default ctor</span>
mary = billy; <span class="hljs-comment">//copy, but not construction. copy assignment operator is `=` - uses compiler-supplied default</span></code></pre>

<p>May need to write your own:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-comment">//So that cascading works your return itself. Eg. a=b=c=4; returns a = b = c; (c=4 now), a=b, (b=4 as well now), and then a=4;</span>
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        data=other.data;
        <span class="hljs-keyword">delete</span> next; <span class="hljs-comment">//the existing node might have other nodes so we need to delete those.</span>
        next=other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        <span class="hljs-comment">//THIS IS DANGEROUS</span>
    }
}</code></pre>

<p>Why?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
n=n; <span class="hljs-comment">//deletes n + then tries to copy n to n. undefined behaviour</span>
*p = *q;
a[i] = a[j];</code></pre>

<p>When writing operator=, ALWAYS be wary of self-assignment:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        data = other.data;
        <span class="hljs-keyword">delete</span> next;
        next = other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};</code></pre>

<p>Better:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp=next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data=other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }</code></pre>

<p>//if new fails, Node is still in a valid state.</p>



<h2 id="lecture-10">Lecture 10</h2>



<pre class="prettyprint"><code class="language-cpp hljs ">Node&amp; operators=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp = next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data = other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>
}</code></pre>

<p>Alternative: copy + swap idiom &lt;3</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;utility&gt;</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">void</span> swap(Node &amp;other){
        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
        swap(data,other.data);
        swap(next, other.next);
    }
}

Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    Node tmp = other; <span class="hljs-comment">//tmp = copy of other</span>
    swap(tmp); <span class="hljs-comment">//me = copy of other. tmp = my old fields</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//my old data deleted when tmp goes out of scope</span>
}</code></pre>



<h3 id="rvalues-rvalue-references">Rvalues + Rvalue References</h3>

<blockquote>
  <p>Recall: - an lvalue is anything with an address. -an lvalue reference (&amp;) is like a const pointer with automatic dereferencing. -always initialized to a lvalue.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node m=n; <span class="hljs-comment">//copy ctor;</span>
Node m2;
m2=n; <span class="hljs-comment">//copy assignment operator</span>

Node plusOne(Node n){
    <span class="hljs-keyword">for</span>(Node *p=&amp;n;p;p=p-&gt;next){
        ++p-&gt;data;
    }
    <span class="hljs-keyword">return</span> n;
}
Node m3 = plusOne(n); <span class="hljs-comment">//copy ctor. What is "other" here? Reference to what?</span></code></pre>

<ul>
<li>Compiler creates a <code>temporary</code> object to hold the result of plusOne</li>
<li>Other is a reference to this temporary - copy ctor deep-copies data from this temporary. <br>
<em>But:</em> - the temporary is just going to be discarded anyway, as soon as the stmt <code>Node m3 = plusOne(n);</code> is done</li>
<li>wasteful to copy from the temp. Why not just steal it instead? - save the cost of a copy. <br>
-Need to be able to tell whether the other is a reference to a temporary or a standalone object <br>
C++ - rvalue reference -&gt; Node &amp;&amp; is a reference to a temporary object (rvalue) of type Node.</li>
</ul>

<p>Version of the ctor that takes Node &amp;&amp;.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(Node &amp;&amp; other): <span class="hljs-comment">//called a move ctor</span>
    <span class="hljs-comment">// what should the move ctor do? Should steal other's data.</span>
        data{other.data},
        next{other.next} {
            other.next=<span class="hljs-keyword">nullptr</span>; <span class="hljs-comment">//else the list is destroyed when other is destroyed. This ctor is constant time.</span>
        }
}</code></pre>

<p>Similarly:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node m;
m=plusOne(n); <span class="hljs-comment">//Assignment from temporary</span>
<span class="hljs-comment">//More assignment operator:</span>
<span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(Node &amp;&amp;other){
        swap(other); <span class="hljs-comment">//steal other's data</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//destroy my old data. swap without copy</span>
    }
}</code></pre>

<p>If you don’t define move ctor/assignment, the copy versions will be used. If the move ctor/assignment is defined, it will replace all calls to copy ctor/assignment when the argument is a temporary (rvalue).</p>



<h3 id="copymove-elision">Copy/Move Elision</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec makeAVec(){
    <span class="hljs-keyword">return</span> {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}; <span class="hljs-comment">//invokes a basic ctor</span>
}
Vec v=makeAVec(); <span class="hljs-comment">//what runs? Not Sure! When compiled in g++, there's the basic ctor (no move/copy ctor).</span></code></pre>

<p>In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn’t have to) <br>
In this example: makeAVec writes it’s result ({0,0}) directly into the space occupied by v in the caller, rather than copy or move it later. <br>
Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> doSomething(vec v)<span class="hljs-comment">//&lt;- pass-by-value copy/move ctor</span>
{...}
doSomething(makeAVec()); <span class="hljs-comment">//-result of makeAVec is written directly into the parameter. There is no copy or move. This is allowed even if dropping ctor calls would change the behaviour of the program. eg. if the ctors print something.</span></code></pre>

<p>You are not expected to know exactly when move/copy elision is allowed, just that it is possible.</p>

<p>If you need all of the ctors to run: <code>g++14 -fno-elide-constructors</code> runs all constructors. But this can slow down your program considerably</p>

<p>In Summary: Rule of 5 (Big 5)</p>

<ul>
<li>If you need a custom version of any one of: <br>
<ul><li>copy ctor</li>
<li>copy assignment</li>
<li>dtor</li>
<li>move ctor</li>
<li>move assignment <br>
Then you usually need a custom version of all five. (The circumstances that require you to need one, usually require you to need all of them)</li></ul></li>
</ul>

<blockquote>
  <p>Notice: <br>
  <code>operator=</code> is a member function, not a standalone function <br>
  When an operator is a member, <code>this</code> is the first arguement</p>
  
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
  <span class="hljs-keyword">int</span> x,y;
  ...
  Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec&amp;other){
     <span class="hljs-keyword">return</span>{x+other.x, y+other.y};
  }
  Vec <span class="hljs-keyword">operator</span>*{<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k}{ <span class="hljs-comment">//implements v*k</span>
     <span class="hljs-keyword">return</span> {x*k, y*k};
  }
  <span class="hljs-comment">//How do we implement k*v? Can't be a member -first arg not Vec. -Write it as a standalone:</span>
}
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
  <span class="hljs-keyword">return</span> v*k;
}</code></pre>
</blockquote>

<p>I/O operators:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    ...
    ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out){
        <span class="hljs-keyword">return</span> out &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; y;
    }
};
<span class="hljs-comment">//what's wrong? Make Vec the first arg. -&gt; Use as vec&lt;&lt;cout;</span></code></pre>

<p>So define &lt;&lt;. &gt;&gt; as standalone fns.  <br>
Certain operators <strong>must</strong> be members:</p>

<ul>
<li>operator=</li>
<li>operator[]</li>
<li>operator()</li>
<li>operator T (where T is a type)</li>
</ul>



<h2 id="lecture-11">Lecture - 11</h2>



<h3 id="separate-compilation-for-classes">Separate Compilation for Classes</h3>

<p>Node.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor"># ...</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data, Node*next=<span class="hljs-keyword">nullptr</span>);
    <span class="hljs-keyword">bool</span> hasNext();
};</code></pre>

<p>Node.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "node.h"</span>
Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next} {} <span class="hljs-comment">//compiler will yell at you for this. No return type and can't use init for f'ns.</span>
Node::Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next}{} <span class="hljs-comment">//tells compiler that it belongs to a class</span>

<span class="hljs-keyword">bool</span> hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;} <span class="hljs-comment">//will yell and say that you're using an undeclared variable</span>
<span class="hljs-keyword">bool</span> Node::hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;}<span class="hljs-comment">//better</span></code></pre>

<p><code>::</code> - scope resolution operator <br>
<code>Node:: ____</code> means <code>____</code> within class node <br>
<code>::</code> like <code>.</code> where LHS is a class or namespace, not an object</p>



<h3 id="arrays-of-objects">Arrays of Objects</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y): x{x}, y{y} {}
};
Vec *vp = <span class="hljs-keyword">new</span> Vec[<span class="hljs-number">5</span>]; <span class="hljs-comment">// X</span>
Vec moreVecs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// X</span>
<span class="hljs-comment">//there want to call the default ctor on each item. Can't init array elements - no default ctor.</span></code></pre>

<p>Options</p>

<ol>
<li>Provide a default ctor</li>
<li>For stack arrays: <br>
<code>Vec moreVecs[] = {{0,0}, {1,3}, {2,4}};</code></li>
<li>For heap arrays: -create an array of ptrs</li>
</ol>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec **vp = <span class="hljs-keyword">new</span> Vec*[<span class="hljs-number">5</span>];
vp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> Vec {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
vp[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> Vec[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>;++i){
    <span class="hljs-keyword">delete</span> vp[i];
}
<span class="hljs-keyword">delete</span>[] vp;</code></pre>



<h3 id="const-objects">Const Objects</h3>

<p>Const objects arise often</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(<span class="hljs-keyword">const</span> Node &amp;n) {...}</code></pre>

<p>What is a const object? Can’t change fields <br>
Question: Can we call methods on a const object? <br>
<em>Issue:</em> <br>
The method may modify fields, violate const <br>
Answer: Yes - we can call methods that promise not to change fields</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>; <span class="hljs-comment">//this method will not change fields</span>
};</code></pre>

<p>Compiler checks that const methods don’t modify fields. Only const methods can be called on const objects.</p>

<p>Now consider: want to collect usage stats on student objects</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">int</span> numMethodCalls=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodcalls; <span class="hljs-comment">//method isn't const anymore. If you take const out, can't call grade on const students</span>
        <span class="hljs-keyword">return</span> ...
    }
};</code></pre>

<p>But mutating numMethodCalls affects only the <strong>physical constness</strong> of student objects, not the <strong>logical constness</strong></p>

<p>Want to be able to update numMethodCalls, even if the object is const - declare the field <code>mutable</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodCalls;
        <span class="hljs-keyword">return</span> ...;
    }
};</code></pre>

<p>mutable fields can be changed, even if the object is const.</p>



<h3 id="static-fields-methods">Static Fields + Methods</h3>

<p><code>numMethodCalls</code> tracked # of method calls for each particular Student <br>
What if we want to track method calls over all Students? <br>
Or what if we want to know how many Students were created? <br>
<strong>Static members</strong> - associated with the class itself, not with any specified instance (object).</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstances;
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final): assns{assns}, mt{mt}, final{final} {
        ++numInstances;
    }
};

<span class="hljs-keyword">int</span> Student::numInstances=<span class="hljs-number">0</span>; <span class="hljs-comment">//in .cc file</span></code></pre>

<p>static fields must be defined, external to the class</p>



<h3 id="static-member-functions">Static Member Functions</h3>

<ul>
<li>Don’t depend on a specific instance (no <code>this</code> param)</li>
<li>Can only access static fields + call other static methods</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstance;
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> printNumInstances(){
        <span class="hljs-built_in">cout</span> &lt;&lt; numInstances &lt;&lt; endl;
    }
};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane{<span class="hljs-number">70</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>};
Student::printNumInstances(); <span class="hljs-comment">//2</span></code></pre>



<h3 id="invariants-encapsulation">Invariants + Encapsulation</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(<span class="hljs-keyword">int</span> data, Node*next);
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;}
};
Node n1 {<span class="hljs-number">1</span>, newNode {<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node n2 {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>};
Node n3 {<span class="hljs-number">4</span>, &amp;n2};</code></pre>

<p>What happens when these go out of scope?</p>

<ul>
<li>n1: dtor runs, whole list is deleted OK</li>
<li>n2, n3 go out of scope - n3’s dtor attempts to delete n2 but n2 is on the stack, not the heap! Undefined behaviour!</li>
</ul>

<p>Class Node relies on an assumption for its proper operation - next is either <code>nullptr</code> or allocated by <code>new</code>.</p>

<p>This is an <strong>invariant</strong> - statement that holds true, upon which Node relies. <br>
But we can’t guarantee this invariant - can’t trust the user to use Node properly.  <br>
Can’t enforce any invariants - user can interfere with our data.</p>

<blockquote>
  <p>Eg. - Stack : Invariant -&gt; last item pushed is first item popped. <br>
  but not if the client can rearrange the underlying data. </p>
</blockquote>

<p>Hard to reason about programs if you can’t rely on invariants. <br>
To enforce invariants - we introduce <code>encapsulation</code>  - we can’t clients to treat our objects as black boxes - capsules.</p>

<ul>
<li>implementation details sealed away</li>
<li>can only interact via provided methods</li>
<li>abstraction - regains control over our objects</li>
</ul>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs ">strut Vec{
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y); <span class="hljs-comment">//public by default</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">//can't be accessed outside the struct Vec.</span>
    <span class="hljs-keyword">public</span>:
        Vec <span class="hljs-keyword">operator</span>+(...);<span class="hljs-comment">//anyone can access</span>
        ...
};</code></pre>

<p>In general: want fields to be private - only methods should be public.  <br>
Better to have default visibility to be private. <br>
Switch from struct to class. <br>
THIS IS THE ONLY DIFFERENCE BETWEEN STRUCT AND CLASS -&gt; default visibility. Public in <code>struct</code>. Private in <code>class</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x,y);
    Vec <span class="hljs-keyword">operator</span>+(...);
    ...
};</code></pre>



<h2 id="cs-246-tut-5">CS 246 TUT 5</h2>

<blockquote>
  <p>Summary: Rvalues &amp; Lvalues <br>
  Move Copy/Assignment <br>
  Rule of Five <br>
  Member Operators</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> value;
    Node *next;
};

Node add(Node n, <span class="hljs-keyword">int</span> inc){ <span class="hljs-comment">//copy ctor runs</span>
    <span class="hljs-keyword">for</span>(Node *m=&amp;n; m != <span class="hljs-keyword">nullptr</span>; m = m-&gt;next){
        m-&gt;value += inc;
    }
    <span class="hljs-keyword">return</span> n;
}

Node n1{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
Node n2 = add(n1,<span class="hljs-number">3</span>); <span class="hljs-comment">//move ctor</span>
n2 = add(n1, <span class="hljs-number">4</span>); <span class="hljs-comment">//move assign</span>

Node(Node &amp;&amp;other): <span class="hljs-comment">//impl of the move ctor</span>
value{other.value}, next{other.next} {
    other.next = <span class="hljs-keyword">nullptr</span>;
}</code></pre>

<p>Node &amp;operator=(Node &amp;&amp;other){ <br>
    swap(value, other.value); <br>
    swap(next, other.next); <br>
    return *this; <br>
}</p>

<p>lvalue -&gt; with address <br>
rvalue -&gt; without address</p>



<h2 id="lecture-12">Lecture 12</h2>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
        <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);
        Vec <span class="hljs-keyword">operator</span>+(...);
        ...
};</code></pre>

<p>Fix our linked list class: <br>
list.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node; <span class="hljs-comment">//private nested class. Only accessible within list.</span>
    Node *theList = <span class="hljs-keyword">nullptr</span>;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> addToFront(<span class="hljs-keyword">int</span> n);
        <span class="hljs-keyword">int</span> ith(<span class="hljs-keyword">int</span> n) <span class="hljs-keyword">const</span>;
        ~List(){<span class="hljs-keyword">delete</span> theList;}
};</code></pre>

<p>list.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "list.h"</span>
<span class="hljs-keyword">struct</span> List::Node{ <span class="hljs-comment">// Nested class</span>
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(...): ... {}
    ~Node() {<span class="hljs-keyword">delete</span> next;}
};

<span class="hljs-keyword">void</span> List::addToFront(<span class="hljs-keyword">int</span> n){
    theList = <span class="hljs-keyword">new</span> Node {n, theList};
}

<span class="hljs-keyword">int</span> List::ith(<span class="hljs-keyword">int</span> i)<span class="hljs-keyword">const</span>{
    Node *cur = theList;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n &lt; i &amp;&amp; cur; ++n; curr=cur-&gt;next);
    <span class="hljs-keyword">return</span> cur-&gt; data;
}</code></pre>

<p>Only List can create/manipulate Node objects <br>
<script type="math/tex" id="MathJax-Element-8">\therefore</script> Can guarantee the invariant that next is either nullptr or allocated by new.</p>

<p>pause</p>

<hr>

<p>But - Now we can’t traverse the list from front node to node, as would a linked list.  <br>
Repeatedly calling ith - <script type="math/tex" id="MathJax-Element-9">O(n^2)</script> time. <br>
But we can’t expose the nodes, or we lose encapsulation</p>



<h3 id="se-topic-design-patterns">SE Topic: Design Patterns</h3>

<ul>
<li>certain problems arise frequently</li>
<li>keep track of good solutions, use in similar situations</li>
</ul>

<dl>
<dt>Design Pattern</dt>
<dd>If you have problem X, solution Y will fix it.</dd>
</dl>

<blockquote>
  <p>Book Rec: Design Patterns (by the gang of four)</p>
</blockquote>

<hr>

<p>resume</p>

<p>Solution: Create a class that manages access to nodes <br>
- Create a class that manages access to nodes <br>
- abstraction of a ptr <br>
- walk the list without exposing the actual ptrs.</p>

<p>Inspiration:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *p=a; p! = a+n ; ++p){
    ... *p ...
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    Node *theList;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">explicit</span> Iterator(Node *p):p{p}{}
                <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> p-&gt;data;} <span class="hljs-comment">// returns p-&gt;data ITSELF. allows the user to update it themselves. (eg. Iterator it ... ; *it = 7;)</span>
                Iterator &amp;<span class="hljs-keyword">operator</span>++(){p=p-&gt;next; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Iterator &amp;other){ <span class="hljs-keyword">return</span> p==other.p;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Iterator &amp;other){
                    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>==other);
                }
        };
        Iterator begin(){<span class="hljs-keyword">return</span> Iterator{theList};}
        Iterator end(){<span class="hljs-keyword">return</span> Iterator{<span class="hljs-keyword">nullptr</span>};}
        ...<span class="hljs-comment">//other methods like ith</span>
        ... 
};</code></pre>

<p>Client:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    List l;
    l.addToFront(<span class="hljs-number">1</span>);
    l.addToFront(<span class="hljs-number">2</span>);
    l.addToFront(<span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span>(List::Iterator it=l.begin(); it!=l.end();++it){
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;endl;
    }
}</code></pre>

<blockquote>
  <p>Shortcut: automatic type deduction - <code>auto x = y;</code> . <code>auto</code> automatically gives x the same type as y.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = l.begin(); it!=l.end(); ++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}</code></pre>

<blockquote>
  <p>Shorter cut: range-based for loop</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:l){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}</code></pre>

<p>Available for any class with:</p>

<ul>
<li>methods begin + end that produces iterators</li>
<li>iterators must support !=, prefix ++, unary *</li>
</ul>

<p>If you want to modify the list items (or save copying):</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;n: l){
    ++n;
}</code></pre>

<p>Iterators shall return later.</p>

<p>Encapsulation ctd.</p>

<p>List  Client can create iterators directly :o</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> it = List::Iterator{<span class="hljs-keyword">nullptr</span>}; <span class="hljs-comment">//well, they only can make a nullptr iterator. But still. Bad form.</span></code></pre>

<ul>
<li>violate encapsulation - client should be using begin/end.</li>
</ul>

<p>We could make Iterator’s ctor private. Then client can’t call <code>List::Iterator(...)</code> . But then neither can List.</p>

<p>Solution: Give List privileged access to Iterator. Make it a <code>friend</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">explicit</span> Iterator(Node *p); <span class="hljs-comment">//private</span>
            <span class="hljs-keyword">public</span>:
                ...
                <span class="hljs-keyword">friend</span> clas List; <span class="hljs-comment">// List has access to all members of Iterator.</span>
        };
    ...
};</code></pre>

<p>Now List can still create iterators, but client can only create them by calling <code>begin()</code> and <code>end()</code>.</p>

<p>Advice: give your classes as few friends as possible. weakens encapsulation. <br>
Once again: keep fields private. What if you want to give access to fields? use accessor + mutator methods.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> getX()<span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> x;} <span class="hljs-comment">//accessor</span>
        <span class="hljs-keyword">void</span> setY(<span class="hljs-keyword">int</span> newY){y=newY;} <span class="hljs-comment">//mutator</span>
};</code></pre>

<hr>

<p>what about operator &lt;&lt; - needs x+y, can’t be a member <br>
If no getX, getY - make operator &lt;&lt; a friend function</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v);
}

<span class="hljs-comment">//.cc</span>
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> out &lt;&lt; v.x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v.y;
}</code></pre>



<h3 id="tools-topic-make">Tools topic: make</h3>

<p>Separate compilation: <code>g++14 -c list.cc</code> , <code>g++14 -c node.cc</code>, <code>g++14 -c iter.cc</code>, <code>g++14 -c main.cc</code>, <code>g++14 list.o node.o iter.o main.o -o myprog</code> <br>
Why do we do this? So we don’t have to recompile files that haven’t changed.</p>

<p>How do you keep track of what’s changed? <br>
Let Linux help you - with make.</p>

<p>Create a Makefile that says which files depend on which other files. <br>
myprog: main.o list.o node.o iter.o //myprog depends on these <br>
[   ] (MUST be a TAB) g++-5 -std=c++14 main.o list.o node.o iter.o -o myprog (&lt;- how to rebuild)</p>



<h2 id="lecture-13">Lecture 13</h2>



<h3 id="makefile">Makefile</h3>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">myprog:</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>==++<span class="hljs-number">14</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span> -o myprog
<span class="hljs-label">list.o:</span> list<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>=c++<span class="hljs-number">14</span> -c list<span class="hljs-preprocessor">.cc</span>
etc</code></pre>

<p>What does myprogram depend on? <br>
- Recursively build these, if necessary <br>
iter.cc changes: - now newer than iter.o (by last modified date). <script type="math/tex" id="MathJax-Element-10">\therefore</script> rebuilt iter.o <br>
- now iter.o newer than myprogram. <script type="math/tex" id="MathJax-Element-11">\therefore</script> rebuild myprogram <br>
- To do a full rebuild, make clean, make</p>

<p>Generalize with variables</p>



<pre class="prettyprint"><code class=" hljs lasso">CXX <span class="hljs-subst">=</span> g<span class="hljs-subst">++-</span><span class="hljs-number">5</span> <span class="hljs-comment">//compiler's name</span>
CXXFLAGS <span class="hljs-subst">=</span> <span class="hljs-attribute">-std</span><span class="hljs-subst">=</span>c<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-Wall</span> <span class="hljs-comment">//(Wall turns on warnings)</span></code></pre>

<p>eg. </p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> iter<span class="hljs-preprocessor">.h</span>
    ${CXX} ${CXXFLAGS} -c iter<span class="hljs-preprocessor">.cc</span></code></pre>

<p>Shortcut: for any rule of the form</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">x.o:</span> <span class="hljs-built_in">x</span><span class="hljs-preprocessor">.cc</span> a<span class="hljs-preprocessor">.h</span> b<span class="hljs-preprocessor">.h</span></code></pre>

<p>-can leave out the build command <br>
- make guesses that you want</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-variable">${CXX}</span> <span class="hljs-variable">${CXXFLAGS}</span> -c x.cc -o x.o</code></pre>

<p>Biggest problem with writing Makefiles <br>
-working out dependencies <br>
and maintaining them if they change.</p>

<p>Can get help from g++</p>



<pre class="prettyprint"><code class=" hljs lasso">g<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-MMD</span> <span class="hljs-attribute">-c</span> iter<span class="hljs-built_in">.</span>cc</code></pre>

<p>-creates iter.o and iter.d <br>
iter.d</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span></code></pre>

<p>Now just include this in the Makefile</p>



<pre class="prettyprint"><code class=" hljs r">CXXFLAGS= -std=c++<span class="hljs-number">14</span> -Wall -MMD
<span class="hljs-keyword">...</span>
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS: .o=.d}
<span class="hljs-keyword">...</span></code></pre>

<p>-include ${DEPENDS}</p>



<h3 id="system-modelling">System Modelling</h3>

<p>building an 00 system: <br>
- identify abstractions <br>
- formalize relationships among them <br>
Helpful to map these out <br>
popular standard: UML (Unified Modelling Language) <br>
Modelling a Class</p>

<table>
<thead>
<tr>
  <th>Name</th>
  <th>Vec</th>
</tr>
</thead>
<tbody><tr>
  <td>Fields(optional)</td>
  <td>-x:Integer, -y:Integer</td>
</tr>
<tr>
  <td>Methods(optional)</td>
  <td>+getx: Integer, +getY:Integer</td>
</tr>
</tbody></table>


<p>Visibility: <code>-</code> -&gt; private, <code>+</code> -&gt; public <br>
Relationship: Composition of Classes</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);
};
<span class="hljs-comment">//Two vecs define a basis</span>
<span class="hljs-keyword">class</span> Basis{
    Vec v1,v2;
};
Basis b; <span class="hljs-comment">//XXX can't initialize v1, v2 - no default ctor for Vec.</span></code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Basis{
    Vec v1, v2;
    <span class="hljs-keyword">public</span>:
        Basis(): v1{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}, v2 {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>} {}
};</code></pre>

<p>Embedding one obj.(Vec) inside another (Basis) called <strong>Composition</strong> <br>
Relationship between Basis + Vec is called “owns-a” - A Basis “owns” the two Vec objects.</p>

<p>If A “owns-a” B then typically -</p>

<ul>
<li>B has no identity outside A (B is a part of A)</li>
<li>If A is destroyed, B is destroyed</li>
<li>If A is copied, B is copied (deep copy) <br>
E.g: A car owns y wheels - a wheel is a part of a car <br>
-destroy the car -&gt; destroy the wheels <br>
-copy the car -&gt; copy the wheels</li>
</ul>

<p>Implement: usually as composition of classes <br>
Modelling <br>
<img src="http://amyqiu.me/Notes/ownsa.png"> <br>
More details: links on course website</p>



<h3 id="aggegation">Aggegation</h3>

<p>Compare car parts in a car (“owns a”) vs car parts in a catalogue. <br>
The catalogue contains parts, but the parts exists on their own. “has-a” relationship (aggregation)</p>

<p>If A “has a” B, then typically</p>

<ul>
<li>B has an existence outside of its association with A</li>
<li>If A is destroyed, B lives on</li>
<li>If A is copied, B is not (shallow copies) <br>
<ul><li>copies of A share the same B</li></ul></li>
</ul>

<p>e.g.: Ducks in a pond <br>
<img src="http://amyqiu.me/Notes/hasa.png"> <br>
Typical Implementation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Pond {
    Duck *ducks[maxDucks];
};</code></pre>



<h3 id="inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</h3>

<p>Suppose you want to track your collection of books</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    ...
};

<span class="hljs-keyword">class</span> Text{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> topic;
    ...
};

<span class="hljs-keyword">class</span> Comic{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> hero;
    ...
};</code></pre>

<p>-Doesn’t affress relationship among these classes. <br>
-How would we create an array or list containing a mixture of these? <br>
Observe that Texts + comics are KINDS of books. Books with extra features <br>
In c++ - inheritance</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{ <span class="hljs-comment">//Base class or superclass</span>
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        Book(...);
        ...
};

<span class="hljs-comment">//Derived classes or subclasses</span>
<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(...);
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> hero;
    <span class="hljs-keyword">public</span>:
        Comic(...);
};</code></pre>

<p>Derived classes inherit fields + methods from the base class. <br>
So Text, Comic have title author, numPages. <br>
Any method that can be called on Book can be called on Text, Comic. <br>
Who can see these members? <br>
title, author, numPages are private in Book. - outsiders can’t see them. <br>
Can Text, Comic see them? <br>
No. Even subclasses can’t see them!</p>

<p>How do we initialize Text?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): title{title}, author{author}, numPages{numPages}, topic{topic}{} <span class="hljs-comment">//WRONG. DOESN'T WORK HAHA</span>
};</code></pre>

<p>Wrong for 2 reasons:</p>

<ul>
<li>title, author, numPages not accessible in Text</li>
<li>when an object is created: <br>
<ol><li>space is allocated</li>
<li><strong>superclass part is constructed</strong> (in this case, Book doesn’t have a default ctor. Can’t do this)</li>
<li>fields are constructed</li>
<li>ctor body runs</li></ol></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p; <span class="hljs-comment">//read right to left. p is a constant pointer to an int.</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//p is a pointer to an int that is constant</span></code></pre>



<h2 id="lecture-14">Lecture 14</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
      Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): Book {title, author, numPages}, topic{topic}{}
};</code></pre>

<p>If the superclass has no default ctor, the subclass MUST invoke a superclass ctor in its Member Initialization List.</p>

<p>If you want to give the subclass access to certain superclass members, use <strong>protected</strong> visibility.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-keyword">protected</span>:
      <span class="hljs-built_in">string</span> title, author;
      <span class="hljs-keyword">int</span> numPages;
      ...
};

<span class="hljs-keyword">class</span> Topic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
      ...
      <span class="hljs-keyword">void</span> addAuthor(<span class="hljs-built_in">string</span> auth) {author+=auth;} <span class="hljs-comment">//ok since we protected author</span>
};</code></pre>

<p>Not a good idea to give subclasses unlimited access to fields. Breaks encapsulation and invariant. -&gt; eg. if you really don’t want Book to have the author Robert Munch, but you can’t guarantee that all subclasses will follow that rule and since they can change fields, breaks invariant.</p>

<p>Better: make fields private and provide protected access.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-built_in">string</span> getTitle() <span class="hljs-keyword">const</span>;
        <span class="hljs-keyword">void</span> setAuthor(<span class="hljs-built_in">string</span> auth);
        ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span>;
    ...
};</code></pre>

<p>Relationship among Text, Comic, Book is called “is-a” <br>
- a Text is a Book <br>
- a Comic is a Book <br>
- protected: #</p>

<p><img src="http://amyqiu.me/Notes/TextComic.png"></p>

<p>Method isItHeavy - when is a book heavy? <br>
- for ordinary Books - &gt; 200 pgs <br>
- for Text - &gt; 500 pages <br>
- for Comics - &gt; 30 pages</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">200</span>;}
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">30</span>;}
};

<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">500</span>;}
};

Book b{<span class="hljs-string">"A small book"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">50</span>};
Comic c{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; b.isItHeavy() <span class="hljs-comment">//false</span>
     &lt;&lt; c.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>Since a Comic “is a” Book, we can do this:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};</code></pre>

<p>Q: Is b heavy? <br>
Which isItHeavy runs: Book::isItHeavy, or Comic:isItHeavy ? <br>
A: NO - b is not heavy. Book::isItHeavy runs. <br>
Why?</p>

<p><img src="http://amyqiu.me/Notes/ComcvsBook.png"></p>

<p>Since I’ve allocated only enough space for a Book and Comic is bigger, I must treat b as a book no matter what.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{...};
<span class="hljs-comment">//tries to fit a Comic object where there is only space for a Book object. What happens? - slicing occurs - c++ makes comic fit by chopping off bits. Hero field is chopped off so comic is coerced into a Book.</span></code></pre>

<p>So this converts the comic into a Book and Book::isItHeavy runs.</p>

<p>When accessing objects through ptrs, slicing is unnecessary and doesn’t happen.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Comic *pc = &amp;c;
<span class="hljs-built_in">cout</span> &lt;&lt;  pc -&gt; isItHeavy(); <span class="hljs-comment">//true</span>
     &lt;&lt; pb -&gt; isItHeavy(); <span class="hljs-comment">//not heavy</span></code></pre>

<p>still Book:isItHeavy runs when we access pb-&gt;isItHeavy(). <br>
Same object behaves differently, depending on what kind of ptr points at it. <br>
Compiler uses the type of the pointer (or reference) to determine which isItHeavy to run. - does not consider the actual type of the object <br>
Means a comic is only a comic when pointed at by a comic ptr -proabably not what we want.</p>

<p>How do we make comic act like a Comic, even when pointed at by a Book ptr? <br>
Declare the method <strong>virtual</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {...};
        ...
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Comic(...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> override{...}
        ...
};

Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Book &amp;rb = c;
Comic *pc = &amp;;

<span class="hljs-built_in">cout</span> &lt;&lt; pc-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; pb-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; rb.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>E.g. <br>
My Book Collection:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *myBooks[<span class="hljs-number">20</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span> ; ++i){
    <span class="hljs-built_in">cout</span> &lt;&lt; myBooks[i] -&gt;isItHeavy() &lt;&lt; endl; <span class="hljs-comment">// uses the right isItHeavy for corresponding types. :D</span>
}</code></pre>

<p>Accommadates multiple types under one abstraction <br>
-polymorphism (“many forms”)</p>

<hr>



<h3 id="destructor-revisited">Destructor Revisited</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    <span class="hljs-keyword">int</span> *x;
    <span class="hljs-keyword">public</span>:
        X(<span class="hljs-keyword">int</span> n): x{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]}{}
        ~X(){<span class="hljs-keyword">delete</span> [] x;}
};

<span class="hljs-keyword">class</span> Y: <span class="hljs-keyword">public</span> X{
    <span class="hljs-keyword">int</span> *y;
    <span class="hljs-keyword">public</span>:
        Y(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n): X{n}, y{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m]}{}
        ~Y(){<span class="hljs-keyword">delete</span> [] y};
};</code></pre>

<p>You don’t have to delete X. X’s dtor will run after Y automatically since it’s the superclass.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">X *myX = <span class="hljs-keyword">new</span> Y{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>};
<span class="hljs-keyword">delete</span> myX; <span class="hljs-comment">//- leaks, why? X's dtor ran, but myX points to a Y. Y's dtor never runs here.</span></code></pre>

<p>So only x, but not y is freed. <br>
How can we ensure that deletion through superclass ptr will call subclass dtor? <br>
- declare the dtor virtual</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">virtual</span> ~X(){
            <span class="hljs-keyword">delete</span> x;
        }
};</code></pre>

<p>ALWAYS - make the dtor virtual in classes that are meant to have subclasses <br>
-even if the dtor doesn’t do anything <br>
If a subclass is NOT meant to have subclasses, declare it <code>final</code>:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Y final: <span class="hljs-keyword">public</span> X{
    ...
};</code></pre>



<h2 id="lecture-15">Lecture 15</h2>



<h3 id="pure-virtual-methods-abstract-classes">Pure Virtual Methods + Abstract Classes</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Student{
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-keyword">int</span> numCourses;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> fees();
};</code></pre>

<p>2 Kinds of Student: Regular + Co-op</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Regular: <span class="hljs-keyword">public</span> Student{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> fees() override; <span class="hljs-comment">//reg student fees</span>
};

<span class="hljs-keyword">class</span> Coop: <span class="hljs-keyword">public</span> Student{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> fees() override; <span class="hljs-comment">//coop student fees</span>
};</code></pre>

<p>What should we put for Student fees? <br>
Not sure - every student should be regular or co-op</p>

<p>Can explicitly give NO implementation to Student::fees()</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Student{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> fees()=<span class="hljs-number">0</span>; <span class="hljs-comment">//this syntactically tells that this method has no implementation(***). no, 1,2,3 ... etc doesn't work. Called a pure virtual method</span>
}</code></pre>

<p>A class with pure virtual methods cannot be instantiated.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student s; X</code></pre>

<p>-called an <code>abstract class</code> <br>
Purpose of an abstract class is to organize subclasses.</p>

<p>Subclasses of an abstract class are also abstract unless they implement the pure virtual methods. <br>
If a class is not abstract, then it is <strong>concrete</strong></p>

<dl>
<dt>UML</dt>
<dd>Virtual + pure methods: italics <br>
Abstract classes: class name in italics <br>
Static - underline</dd>
</dl>



<h3 id="templates">Templates</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    Node *theList;
    ...
}
<span class="hljs-keyword">struct</span> List::Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    ...
}</code></pre>

<p>What if you want to store something else? <br>
Whole new class? <br>
OR a <strong>template</strong> : A class parameterized by a <strong>type</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> Stack{
    <span class="hljs-keyword">int</span> size;
    <span class="hljs-keyword">int</span> cap;
    T *contents;
    <span class="hljs-keyword">public</span>:
        Stack(){...}
        <span class="hljs-keyword">void</span> push(T x){...}
        T top(){...}
        <span class="hljs-keyword">void</span> pop(){...}
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node{
        T data;
        Node *next;
    };
    Node *theList;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">explicit</span> Iterator(Node *p):p{p}{}
            <span class="hljs-keyword">public</span>:
                T &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> p-&gt;data;}
                ...
        };
        ...
        T ith(<span class="hljs-keyword">int</span> i){...};
        <span class="hljs-keyword">void</span> addToFront(T n){...}
};
<span class="hljs-comment">//Client:</span>
List &lt;<span class="hljs-keyword">int</span>&gt; l1;
List&lt;List&lt;<span class="hljs-keyword">int</span>&gt;&gt; l2;
l1.addToFront(<span class="hljs-number">3</span>);
l2.addToFront(l1);

<span class="hljs-keyword">for</span>(List&lt;<span class="hljs-keyword">int</span>&gt;::Iterator it=l1.begin();it!=l1.end();++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}</code></pre>

<p>or indeed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:l1){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}</code></pre>



<h3 id="the-standard-template-library-stl">The Standard Template Library (STL)</h3>

<p>Large # of useful templates: <br>
Eg: dynamic-length arrays : <strong>vectors</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include&lt;vector&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">4</span>,<span class="hljs-number">5</span>}; <span class="hljs-comment">// [4, 5]</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;</span> v1(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// [5, 5, 5, 5]</span>
<span class="hljs-comment">//oh no!</span>

v.emplace-back(<span class="hljs-number">6</span>);
vemplace.back(<span class="hljs-number">7</span>); <span class="hljs-comment">//4,5,6,7</span></code></pre>

<p>Looping:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v.size();++i){
    <span class="hljs-built_in">cout</span> &lt;&lt;v[i]&lt;&lt;endl;
}

<span class="hljs-comment">//CAN REPLACE vector&lt;int&gt;::reverse.iterator WITH AUTO FOR ALL OCCURRENCES</span>
<span class="hljs-keyword">for</span>(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator it=v.begin();it!=v.end();++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;endl;
}
<span class="hljs-comment">//OR</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:v){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}

<span class="hljs-comment">//To iterate in revers:</span>
<span class="hljs-keyword">for</span>(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::reverse.iterator it=v.rbegin(); it!=v.rend(); ++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}
v.pop.back() <span class="hljs-comment">//remove last element</span></code></pre>

<p>use iterators to remove from inside a vector</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> it = v.erase(v.begin()); <span class="hljs-comment">//erases the first element</span>
<span class="hljs-keyword">auto</span> it = v.erase(v.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//erases item 3</span>
<span class="hljs-keyword">auto</span> it = v.erase(it); <span class="hljs-comment">//erases item pointed at by it. returns an iterator to item past the item just removed.</span>
<span class="hljs-keyword">auto</span> it = v.erase(v.end()-<span class="hljs-number">1</span>);
v[i] <span class="hljs-comment">//- returns ith element of v; it's unchecked so if you go out of bounds.</span>
<span class="hljs-comment">// it's undefined behaviour. </span>
v.at(i) <span class="hljs-comment">//- checked version of v[i] . What happens when you go out of bounds?</span></code></pre>

<p>What should happen?</p>

<dl>
<dt>Problem</dt>
<dd>Vector’s code can detect the error, but doesn’t know what to do about it. <br>
Client can respond, but can’t detect the error.</dd>

<dt>C solution</dt>
<dd>functions return a status code, or set the global variable errno <br>
Leads to awkward programming. Lots of if statements <br>
Encourages programming to ignore error checks</dd>

<dt>C++</dt>
<dd>When an arror condition arises, the function raises an exception <br>
What happens? By default, execution stops</dd>
</dl>

<p>But we can write handlers to catch ex’ns + deal with them. <br>
<code>vector&lt;T&gt;::at</code> raises the exn <code>std::out_of_range</code> when it fails <br>
We can handle it as follows:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;stdexcept&gt;</span>
...
<span class="hljs-keyword">try</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; v.at(<span class="hljs-number">1000</span>) &lt;&lt;endl; <span class="hljs-comment">//out of range</span>
}
<span class="hljs-keyword">catch</span>(out_of_range r){
    <span class="hljs-built_in">cerr</span> &lt;&lt;<span class="hljs-string">"Range error "</span> &lt;&lt; r.what() &lt;&lt;endl;
}</code></pre>

<p>From midterm</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> y{x};
y+x;
<span class="hljs-built_in">cin</span> &lt;&lt; x;
<span class="hljs-comment">//here, {x}, {x, x}, {x, y}, {cin, x, cin&lt;&lt;x} are lvalues.</span>
<span class="hljs-comment">// y+x is rvalue;</span></code></pre>



<h2 id="lecture-16">Lecture 16</h2>

<p>Now consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-keyword">throw</span> out_of_range{<span class="hljs-string">"f"</span>}; <span class="hljs-comment">//raise an exception. "f" is displayed in .what()</span>
}

<span class="hljs-keyword">void</span> g() {f();}
<span class="hljs-keyword">void</span> h() {g();}
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">try</span>{
        h();
    }
    <span class="hljs-keyword">catch</span> (out_of_range r){...}
}</code></pre>

<dl>
<dt>What happens:</dt>
<dd>main calls h <br>
h calls g <br>
g calls f <br>
f throws out_of_range <br>
g has no handler for out_of_range <br>
- control goes back through the call chain (unwinds the stack) until a handler is found <br>
- control goes all the way back to main and main handles the exception <br>
- if no handler in the entire call chain, program terminates</dd>
</dl>

<p>What is out_of_range? - A class.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">throw</span> out_of_range{<span class="hljs-string">"f"</span>} <span class="hljs-comment">//ctor call, create an out_of_range object and throw it</span></code></pre>

<p>A handler can do part of the recovery job - execute some corrective code + raise another exn:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">try</span>{...}
<span class="hljs-keyword">catch</span>(SomeErrorType s){
    ...
    <span class="hljs-keyword">throw</span> SomeOtherError{<span class="hljs-string">"..."</span>};
}</code></pre>

<p>or throw the same ex’n</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">try</span>{...}
<span class="hljs-keyword">catch</span>(SomeErrorType s){
    ...
    <span class="hljs-keyword">throw</span>;
}</code></pre>

<p><code>throw;</code> vs <code>throw s;</code></p>

<p><strong>throw s;</strong> <br>
Throw s; -&gt; s may be a subtype of SomeErrorType. throws a new exn of type SomeErrorType</p>



<div class="flow-chart"><svg height="133" version="1.1" width="141.046875" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="overflow: hidden; position: relative; top: -0.109375px;"><desc style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">Created with Raphaël 2.1.2</desc><defs style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path><marker id="raphael-marker-endblock33-obj4" markerHeight="3" markerWidth="3" orient="auto" refX="1.5" refY="1.5" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#raphael-marker-block" transform="rotate(180 1.5 1.5) scale(0.6,0.6)" stroke-width="1.6667" fill="black" stroke="none" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></use></marker></defs><rect x="0" y="0" width="135.046875" height="36.5" rx="20" ry="20" fill="#ffffff" stroke="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" stroke-width="2" class="flowchart" id="e" transform="matrix(1,0,0,1,4,4)"></rect><text x="10" y="18.25" text-anchor="start" font-family="sans-serif" font-size="14px" stroke="none" fill="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); text-anchor: start; font-family: sans-serif; font-size: 14px; font-weight: normal;" id="et" class="flowchartt" font-weight="normal" transform="matrix(1,0,0,1,4,4)"><tspan style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" dy="5.25">SpecialErrorType</tspan></text><rect x="0" y="0" width="125.03125" height="36.5" rx="20" ry="20" fill="#ffffff" stroke="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" stroke-width="2" class="flowchart" id="st" transform="matrix(1,0,0,1,9.0078,94.5)"></rect><text x="10" y="18.25" text-anchor="start" font-family="sans-serif" font-size="14px" stroke="none" fill="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); text-anchor: start; font-family: sans-serif; font-size: 14px; font-weight: normal;" id="stt" class="flowchartt" font-weight="normal" transform="matrix(1,0,0,1,9.0078,94.5)"><tspan style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" dy="5.25">SomeErrorType</tspan></text><path fill="none" stroke="#000000" d="M71.5234375,40.5C71.5234375,40.5,71.5234375,80.15409994125366,71.5234375,91.50043908460066" stroke-width="2" marker-end="url(#raphael-marker-endblock33-obj4)" font-family="sans-serif" font-weight="normal" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); font-family: sans-serif; font-weight: normal;"></path></svg></div>

<p><strong>throw;</strong> <br>
actual type of s is retained</p>

<p>A handler can act as a catch-all:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">try</span>{...}
<span class="hljs-keyword">catch</span>(...){ <span class="hljs-comment">//here, we LITERALLY PUT "..." to catch ALL exceptions</span>
    ...
}</code></pre>

<p>You can throw anything you want - don’t have to throw objects</p>

<p>Define your own exception classes (or use appropriate existing ones) for your errors:</p>

<p>eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> BadInput{};
<span class="hljs-keyword">try</span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span> &gt;&gt; n)) <span class="hljs-keyword">throw</span> BadInput{};
}
<span class="hljs-keyword">catch</span>(BadInput &amp;s){ <span class="hljs-comment">//in general: catch by reference</span>
    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"input not well-formed"</span> &lt;&lt;endl;
}</code></pre>

<dl>
<dt>Some standard exceptions</dt>
<dd>length_error : attempt to resize strings/vectors that are too long</dd>

<dd>bad_alloc : new fails</dd>
</dl>

<p>Much more on exns later</p>



<h3 id="design-patterns-ctd">Design Patterns Ct’d</h3>

<p>Guiding Principle: Program to the interface, not the implementation</p>

<ul>
<li>abstract base class to define the interface.</li>
<li>work with pointers or references to abstract base classes + call their methods.</li>
<li>concrete subclasses can be swapped in and out</li>
<li>abstraction over a variety of behaviours</li>
</ul>

<p>eg. Iterator Pattern</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> AbstractIterator{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp;<span class="hljs-keyword">operator</span>*()=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> AbstractIterator &amp;<span class="hljs-keyword">operator</span>++()=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> AbstractIterator &amp;other)=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> ~AbstractIterator();
};

<span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator: <span class="hljs-keyword">public</span> AbstractIterator{
            ...
        };
    ...
};

<span class="hljs-keyword">class</span> Set{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator: <span class="hljs-keyword">public</span> AbstractIterator{
            ...
        };
    ...
};</code></pre>

<p>Then you can write code that operates over Iterators:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> foreach(AbstractIterator start, AbstractIterator end, <span class="hljs-keyword">void</span>(*f)(<span class="hljs-keyword">int</span>)){
    <span class="hljs-keyword">while</span>(start!=end){
        f(*start);
        ++start;
    } <span class="hljs-comment">//-works over Lists and Sets.</span>
}</code></pre>



<h3 id="observer-pattern">Observer Pattern</h3>

<dl>
<dt>Publish -subscribe mode 1.</dt>
<dd>One class: publisher/subject - generates data</dd>

<dd>One or more subscriber/observer classes - receive data and react to it</dd>
</dl>

<p>Eg: Publisher = spreadsheet cells. Observers = graphs. When cells change, graphs update.</p>

<p>Can have many different observer objects. <br>
- subject should not need to know all the details.</p>

<p>Observer pattern: <br>
<img src="http://amyqiu.me/Notes/observerpattern.png"></p>

<p>Sequence of method calls:</p>

<ol>
<li>Subject’s state is updated</li>
<li>Subject::notifyObservers() -calls each observer’s notify</li>
<li>Each observer calls ConcretSubject::getState tp query the state and react accordingly.</li>
</ol>

<p>Example: Horse races <br>
Subject - publishes winners <br>
Observers - individual bettors </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Subject{
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Observer *&gt;</span> observers;
    <span class="hljs-keyword">public</span>:
        Subject();
        <span class="hljs-keyword">bool</span> attach(Observer *o){observers.emplace.back(o);}
        <span class="hljs-keyword">void</span> detach(Observer *o){observers.remove(o);}
        <span class="hljs-keyword">void</span> notifyObservers(){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ob:observers) ob-&gt;notify();
        }
        <span class="hljs-keyword">virtual</span> ~Subject()=<span class="hljs-number">0</span>;
};
<span class="hljs-comment">//IMPORTANT</span>
Subject::~Subject(){}
<span class="hljs-comment">/*
virtual destructor must ALWAYS be implemented, even if it is pure virtual.
*/</span></code></pre>



<h2 id="lecture-17">Lecture 17</h2>

<p><img src="http://amyqiu.me/Notes/a1.png"></p>

<p>From last class</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Subject{
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Observer *&gt;</span> observers;
    <span class="hljs-keyword">public</span>:
        Subject();
        <span class="hljs-keyword">bool</span> attach(Observer *o){observers.emplace.back(o);}
        <span class="hljs-keyword">void</span> detach(Observer *o){observers.remove(o);}
        <span class="hljs-keyword">void</span> notifyObservers(){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ob:observers) ob-&gt;notify();
        }
        <span class="hljs-keyword">virtual</span> ~Subject()=<span class="hljs-number">0</span>;
};
Subject::~Subject(){}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Observer{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> notify()=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> ~Observer();
};

Observer::~Observer(){}

<span class="hljs-keyword">class</span> Horserace: <span class="hljs-keyword">public</span> Subject{
    ifstream in; <span class="hljs-comment">//source of data</span>
    <span class="hljs-built_in">string</span> lastwinner;
    <span class="hljs-keyword">public</span>:
        HorseRace(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;source): in{source}{}
        <span class="hljs-keyword">bool</span> runRace(); <span class="hljs-comment">//set lastwinner. Returns false if no winners left</span>
        <span class="hljs-built_in">string</span> getState() {<span class="hljs-keyword">return</span> lastwinner;}
};

<span class="hljs-keyword">class</span> Bettor: <span class="hljs-keyword">public</span> Observer{
    HorseRace *subject;
    <span class="hljs-built_in">string</span> name, myHorse;
    <span class="hljs-keyword">public</span>:
        Bettor(...)...{
            subject-&gt;attach(<span class="hljs-keyword">this</span>);
        }
        ~Bettor(){subject-&gt;detach(<span class="hljs-keyword">this</span>);}
        <span class="hljs-keyword">void</span> notify(){
            <span class="hljs-built_in">string</span> winner = subject-&gt;getState();
            <span class="hljs-keyword">if</span>(winner == myHorse){
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Yay!"</span> &lt;&lt; endl;
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Double or nothing"</span> &lt;&lt; endl;
            }
        }
};
<span class="hljs-comment">//main.cc</span>

HorseRace hr;
Bettor Larry(&amp;hr, <span class="hljs-string">"Larry"</span>, <span class="hljs-string">"RunsLikeACow"</span>);
...
<span class="hljs-keyword">while</span>(hr.runRace()){
    hr.notifyObservers();
}</code></pre>



<h3 id="decorator-pattern">Decorator Pattern</h3>

<p>Want to enhance an object at run-time-add functionality/features <br>
E.g. Windowing system: -start with a basic window. -add scrollbar. -add menu. <br>
Want to choose these enhancements at runtime. <br>
<img src="http://amyqiu.me/Notes/a2.png"></p>

<dl>
<dt>Class Component</dt>
<dd>defines the interface</dd>

<dd>operations your objects will provide</dd>

<dt>Concrete Component</dt>
<dd>implements the interface</dd>

<dt>Decorators</dt>
<dd>all inherit from Decorator, which inherits from component</dd>
</dl>

<p>Therefore, Every Decorator IS a component, AND every Decorator HAS a component</p>

<p>E.g. Window with scrollbar is a kind of window, and has a pointer to the underlying plain window</p>

<p>Window with scrollbar + menu IS a window, has a ptr to window w/ scrollbar, which has a ptr to a plain window.</p>

<p>All inherit from Abstract Window class, so window methods can be used polymorphically on all of them.</p>

<p>E.g Pizza <br>
<img src="http://amyqiu.me/Notes/a3.png"></p>

<p>Basic Pizza is crust and sauce</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Pizza{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> price()<span class="hljs-keyword">const</span>=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> desc()<span class="hljs-keyword">const</span>=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span>~Pizza();
};

<span class="hljs-keyword">class</span> CrustAndSauce:<span class="hljs-keyword">public</span> Pizza{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">float</span> price() <span class="hljs-keyword">const</span> override{<span class="hljs-keyword">return</span> <span class="hljs-number">5.99</span>;}
        <span class="hljs-built_in">string</span> desc() <span class="hljs-keyword">const</span> override{<span class="hljs-keyword">return</span> <span class="hljs-string">"Pizza"</span>;}
};

<span class="hljs-keyword">class</span> Decorator: <span class="hljs-keyword">public</span> Pizza{
    <span class="hljs-keyword">protected</span>:
        Pizza *component;
    <span class="hljs-keyword">public</span>:
        Decorator(Pizza *p): component{p}{}
        <span class="hljs-keyword">virtual</span> ~Decorator{<span class="hljs-keyword">delete</span> component;} <span class="hljs-comment">//what happens in delete component here is the whole pizza is thrown away. Uh, this is the choice we made to keep things simple</span>
};

<span class="hljs-keyword">class</span> StuffedCrust: <span class="hljs-keyword">public</span> Decorator{
    <span class="hljs-keyword">public</span>:
        StuffedCrust(Pizza *p): Decorator {p}{}
        <span class="hljs-keyword">float</span> price() <span class="hljs-keyword">const</span> override{
            <span class="hljs-keyword">return</span> component-&gt;price() + <span class="hljs-number">2.69</span>;
        }
        <span class="hljs-built_in">string</span> desc() <span class="hljs-keyword">const</span> override{
            <span class="hljs-keyword">return</span> component-&gt;desc() + <span class="hljs-string">" with stuffed crust"</span>;
        }
};</code></pre>

<p>Use:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Pizza *p1= <span class="hljs-keyword">new</span> CrustAndSauce;
p1 = <span class="hljs-keyword">new</span> Topping (<span class="hljs-string">"Cheese"</span>, p1);
p1 = <span class="hljs-keyword">new</span> Topping(<span class="hljs-string">"Jelly Beans"</span>, p1);
p1 = <span class="hljs-keyword">new</span> StuffedCrust(p1);
<span class="hljs-built_in">cout</span> &lt;&lt; p1-&gt;desc() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; p1-&gt;price();
<span class="hljs-keyword">delete</span> p1;</code></pre>



<h3 id="inheritance-and-copymove">Inheritance and Copy/Move</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-comment">//Defines copy/move ctor, copy/move operator=</span>
};
<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">//does not define copy/move operations</span>
};
Text t{<span class="hljs-string">"Algorithms"</span>, <span class="hljs-string">"CLRS"</span>, <span class="hljs-string">"500"</span>, <span class="hljs-string">"CS"</span>};
Text t2=t; <span class="hljs-comment">//No copy ctor in Text - what happens?</span></code></pre>

<p>-calls Book’s copy ctor <br>
-then goes field-by-field (ie default behaviour) for Text part <br>
-same for other operations</p>

<p>To write your own operations:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Text::Text(<span class="hljs-keyword">const</span> Text &amp;other): Book{other},topic{other.topic}{}
Text &amp;Text::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Text &amp;other){
    Book::<span class="hljs-keyword">operator</span>=(&amp;other);
    topic=other.topic;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">//other points at an rvalue, but IS ITSELF an lvalue</span>
Text::Text(Text &amp;&amp;other):Book{other}, topic{other.topic}{}
<span class="hljs-comment">//HERE, Book{other} is a copy ctor because other is an lvalue. It exists and has a name within this function</span>

<span class="hljs-comment">//Better but still not correct: move treats other as an rvalue.</span>
Text::Text(Text &amp;&amp;other):Book{<span class="hljs-built_in">std</span>::move(other)}, topic{other.topic}{}
<span class="hljs-comment">//HERE, other.topic is ALSO an lvalue.</span>

<span class="hljs-comment">//Final:</span>
Text::Text(Text &amp;&amp;other):Book{<span class="hljs-built_in">std</span>::move(other)}, topic{<span class="hljs-built_in">std</span>::move(other.topic)}{}

Text&amp;Text::<span class="hljs-keyword">operator</span>=(Text &amp;&amp;other){
    Book::<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::move(other));
    topic=<span class="hljs-built_in">std</span>::move(other.topic);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre>

<blockquote>
  <p>Note: Even though other “points” at an rvalue, other itself is an lvalue (so is other.topic). <br>
  std::move(x) forces an lvalue x to be treated as an rvaluem so that “move” versions of the operations run. What we did above is equivalent to DEFAULT behaviour</p>
</blockquote>



<h2 id="lecture-18">Lecture 18</h2>



<pre class="prettyprint"><code class="language-cpp hljs ">Text t1 {...}, t2{...};
Book *pb1=&amp;t1, *pb2=&amp;t2;</code></pre>

<p>What if we do *pb1 = *pb2; <br>
Partial assignment - copies only the Book part. <br>
- only Book::operator= ran.</p>

<p>How can we fix this? Try making operator= virtual.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> Book &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book &amp;other){...}
};

<span class="hljs-keyword">class</span> Text:<span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Text &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Text &amp;other) override {...}
        <span class="hljs-comment">//this WONT WORK. Parameters don't match</span>
};

<span class="hljs-comment">//better</span>
<span class="hljs-keyword">class</span> Text:<span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Text &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book &amp;other) override {...}
        <span class="hljs-comment">//Note: Different return types OK. (as long as you return a subtype by reference) but the parameter types must be the same or it's not an override and won't compile.</span>
};</code></pre>

<p>Params not matching =&gt; violates is-a <br>
<script type="math/tex" id="MathJax-Element-12">\therefore</script> Assignment of a book object to a text variable would be allowed</p>

<p>Allowed:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Text t{...};
Book b{...};
Text *pt=&amp;t;
Book *pb=&amp;b;
*pt=*pb; <span class="hljs-comment">//- uses a Book to assign a Text BAD (but it compiles).</span>

<span class="hljs-comment">//Also</span>
Comic c{...};
Comic *pc=&amp;c;
*pt=*pc; <span class="hljs-comment">// REALLY BAD, but compiles</span></code></pre>

<p>If operator= is non-virtual. -partial assignment through base class ptrs. <br>
If it is virtual, then the compiler allows mixed assignment</p>

<p>Recommendation - All superclasses should be ABSTRACT</p>

<p>Rewrite Book hierarchy: <br>
<img src="http://amyqiu.me/Notes/a4.png"></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> AbstractBook{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">protected</span>: <span class="hljs-comment">//prevents assignments through base class  ptrs from compiling but still makes the implementation available to subclasses.</span>
        AbstractBook &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> AbstractBook &amp;other);
    <span class="hljs-keyword">public</span>:
        AbstractBook(...);
        <span class="hljs-keyword">virtual</span> ~AbstractBook()=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> NormalBook: <span class="hljs-keyword">public</span> AbstractBook{
    <span class="hljs-keyword">public</span>:
        NormalBook(...);
        ~NormalBook();
        NormalBook &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> NormalBook &amp;other){
            AbstractBook::<span class="hljs-keyword">operator</span>=(other);
            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        }
};
<span class="hljs-comment">//other classes - exercise</span></code></pre>

<p>-Operator= is not virtual therefore no mixed assignment</p>



<pre class="prettyprint"><code class="language-cpp hljs ">NormalBook n1{...}, n1{...}
Abstract *pa1 = &amp;n1, *pa2=&amp;n2;
*pa1 = *pa2 <span class="hljs-comment">//won't compile. AbstractBook::operator= here is protected so client can't call it. No partial assignment</span></code></pre>



<h3 id="factory-method-pattern">Factory Method Pattern</h3>

<p>-Write a video game with two kinds of enemies: turtles and bullets <br>
- system randomly sends turtles and bullets, but bullets become more frequent closer to the end <br>
UML <br>
<img src="http://amyqiu.me/Notes/a5.png"></p>

<p>Never know exactly which enemy comes next, so can’t call turtle/bullet ctors directly. <br>
Instead, put a <code>factory method</code> in level that creates enemies.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Level{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> Enemy *createEnemy()=<span class="hljs-number">0</span>;
        ...
};

<span class="hljs-keyword">class</span> NormalLevel: <span class="hljs-keyword">public</span> Level{
    <span class="hljs-keyword">public</span>:
        Enemy *createEnemy() override{
            <span class="hljs-comment">//create mostly turtles</span>
        }
};

<span class="hljs-keyword">class</span> castle: <span class="hljs-keyword">public</span> Level{
    <span class="hljs-keyword">public</span>:
        Enemy *createEnemy() override{
            <span class="hljs-comment">//mostly bullets</span>
        }
};

Level *l = <span class="hljs-keyword">new</span> NormalLevel;
Enemy *e = l-&gt;createEnemy();</code></pre>



<h3 id="template-method-pattern">Template Method Pattern</h3>

<p>Want subclasses to override superclass behaviour, but some aspects must stay the same.</p>

<p>E.g. There are red turtles + green turtles</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Turtle{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> draw(){
            drawHead();
            drawShell();
            drawFeet();
        }
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">void</span> drawHead();
        <span class="hljs-keyword">void</span> drawFeet();
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> drawShell()=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> RedTurtle:<span class="hljs-keyword">public</span> Turtle{
    <span class="hljs-keyword">void</span> drawShell()override{<span class="hljs-comment">/*draw red shell */</span>}
};

<span class="hljs-keyword">class</span> GreenTurtle: <span class="hljs-keyword">public</span> Turtle{
    <span class="hljs-keyword">void</span> drawShell()override{<span class="hljs-comment">/*draw green shell */</span>}
};</code></pre>

<p>subclasses can’t change what it means to draw a turtle (ie. head, then shell, then feet) <br>
but CAN change the way the shell is drawn</p>

<p>Extension: The Non-Virtual Interface (NVI) idiom. <br>
A public virtual method is really two things:</p>

<ul>
<li>an interface to the client <br>
-indicates provided behaviour, with pre/post conditions</li>
<li><p>an interface to subclasses <br>
-a”hook” to insert specialized behaviour <br>
Hard to separate these ideas if they are tied to the same f’n</p></li>
<li><p>What if you later want to separate the customizale behaviour into 2 f’ns with some unchanging code inbetween, while still providing clients the same interface?</p></li>
<li>how could you make sure overriding f’ns conform to the pre/post conditions</li>
</ul>

<p>The NVI idiom says: </p>

<ul>
<li>All public methods should be non-virtual. </li>
<li>All virtual methods should be private or AT LEAST protected.</li>
<li>except the dtor</li>
</ul>

<p>Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> DigitalMedia{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> play()=<span class="hljs-number">0</span>;
};

<span class="hljs-comment">//instead, do this:</span>
<span class="hljs-keyword">class</span> DigitalMedia{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> play(){doPlay();} <span class="hljs-comment">//can add before/after code. eg check copyright before. Update play count after.</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> doPlay()=<span class="hljs-number">0</span>;
};</code></pre>

<p>Extends Template Method <br>
-put every virtual method inside a template method</p>



<h3 id="stl-maps-for-creating-dictionaries">STL Maps - for creating Dictionaries</h3>

<p>E.g. “arrays” that map string to int</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span> &lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;</span>m;
m[<span class="hljs-string">"abc"</span>] = <span class="hljs-number">1</span>;
m[<span class="hljs-string">"def"</span>] = <span class="hljs-number">4</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; m[<span class="hljs-string">"ghi"</span>] &lt;&lt; endl; <span class="hljs-comment">//if key is not present, it is inserted and the value is default constructed (for ints, 0)</span>
m.erase(<span class="hljs-string">"abc"</span>);
<span class="hljs-keyword">if</span>(m.count(<span class="hljs-string">"def"</span>)) ... <span class="hljs-comment">//0 if found, 1 if not found</span></code></pre>



<h2 id="lecture-19">Lecture 19</h2>

<p>Recall: <code>&lt;map&gt;</code> <br>
<code>map&lt;string, int&gt; m;</code> <br>
Iterating over a map: sorted key order</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;p:m){
    <span class="hljs-built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; p.second &lt;&lt; endl;
}</code></pre>

<p>p’s type is <code>std::pair&lt;string,int&gt;&amp;</code> (<code>&lt;utility&gt;</code>)</p>



<h3 id="visitor-pattern">Visitor Pattern</h3>

<p>For implementation, <strong>double dispatch</strong> <br>
e.g <br>
<img> <br>
-effect depends on type of Enemy and type of weapon <br>
Want something like: virtual void(Enemy, Weapon)::strike(); which is impossible <br>
If we put this method in Enemy - choose based on enemy but not on the weapon. <br>
If we put it in weapon - choose based on weapon but not enemy.</p>

<p>To get dispatch based on both (double dispatch): <br>
-combine overriding with overloading</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Enemy{
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> beStruckBy(Weapon &amp;w)=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> Turtle: <span class="hljs-keyword">public</span> Enemy{
    <span class="hljs-keyword">void</span> beStruckBy(Weapon &amp;w) override{
        w.strike(*<span class="hljs-keyword">this</span>);
    }
};
<span class="hljs-keyword">class</span> Bullet:<span class="hljs-keyword">public</span> Enemy{
    <span class="hljs-keyword">void</span> beStruckBy(Weapon &amp;w) override{
        w.Strike(*<span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-keyword">class</span> Weapon{
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> strike(Turtle &amp;t)=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> strike(Bullet &amp;b)=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> Stick: <span class="hljs-keyword">public</span> Weapon{
    <span class="hljs-keyword">void</span> strike(Turtle &amp;t) override{
        <span class="hljs-comment">//strike Turtle with stick</span>
    }
    <span class="hljs-keyword">void</span> strike(Bullet &amp;b) override{
        <span class="hljs-comment">//bullet with stick</span>
    }
};

Enemy* e = <span class="hljs-keyword">new</span> Bullet{...};
Weapon*w = <span class="hljs-keyword">new</span> Rock{...};

e-&gt;beStruckBy(*w); <span class="hljs-comment">//what happens?</span>
<span class="hljs-comment">//virtual mthd of Enemy. Bullet::beStruckBy calls Weapon::strike</span>
<span class="hljs-comment">//chosen at compile-time - virtual</span>
<span class="hljs-comment">//resolves to Rock::Strike(Bullet &amp;) </span></code></pre>

<p>Visitor can be used to add functionality to existing classes, without changing or recompiling the classes themselves</p>

<p>Eg. add a visitor to the Book hierarchy:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> accept(BookVisitor &amp;v){v.visit(*<span class="hljs-keyword">this</span>);}
};

<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> accept(Book Visitor &amp;v) override{
            v.visit(*<span class="hljs-keyword">this</span>);
        }
};

<span class="hljs-keyword">class</span> BookVisitor{
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> visit(Book &amp;b) = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> visit(Text&amp;b) = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> visit(Comic &amp;b) = <span class="hljs-number">0</span>;
};</code></pre>

<p>Application: <br>
Track how many of each type of book we have: <br>
Books - by author <br>
Texts - by topic <br>
Comics - by hero <br>
Use a <code>map &lt;string, int&gt;</code> <br>
Could add virtual updateMap (…) to each class or write a visitor</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Catalogue: <span class="hljs-keyword">public</span> BookVisitor{
    <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;</span> theCatalogue;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;</span> getCatalogue(){<span class="hljs-keyword">return</span> theCatalogue;}
        <span class="hljs-keyword">void</span> visit(Book &amp;b) override{
            ++theCatalogue[b.getAuthor()];
        };
        <span class="hljs-keyword">void</span> visit(Text &amp;b) override{
            ++theCatalogue[b.getTopic()];
        };
        <span class="hljs-keyword">void</span> visit(Comic &amp;b) override{
            ++theCatalogue[b.getHero()];
        };
};</code></pre>

<p>but it won’t compile! why?</p>

<p>main -&gt; includes book - includes Book Visitor -&gt; inclodes both Text and Book <br>
-circular include dependency <br>
Text doesn’t know what Book is <br>
How many of these includes are really needed?</p>

<p>Compilation Dependencies - include vs forward declare</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Consider <span class="hljs-keyword">class</span> A{...};
<span class="hljs-comment">//B needs #includes A</span>
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
...
};
<span class="hljs-comment">//C needs #include A</span>
<span class="hljs-keyword">class</span> C{A my A;};
<span class="hljs-comment">//D doesn't need to know how big A is therefore doesn't need #include</span>
<span class="hljs-comment">//can get away with just `class A`;</span>
<span class="hljs-keyword">class</span> D{A *myAp;};
<span class="hljs-comment">//E needs #include A</span>
<span class="hljs-keyword">class</span> E{
    A f(A x)
};</code></pre>

<p>Don’t introduce unnecessary compilation dependencies with unneeded includes <br>
When A changes - only A,B,C need recompilation <br>
Now, in the implementations of D,E;</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//d.cc</span>
<span class="hljs-preprocessor">#include "A.h"</span>
<span class="hljs-keyword">void</span> D::f(){
    myAp-&gt;someMethod(); <span class="hljs-comment">//Need to know about class A here</span>
}</code></pre>

<p>Do the #include in the .cc file instead of the .h file. (will never get an include cycle because .cc is never included) where possible.</p>

<p>Now consider the XWindow class</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> XWindow{
    <span class="hljs-comment">//this is private data here. Yet we must look at it. Do we know what it means? Do we care?</span>
    Display *d;
    Window w;
    <span class="hljs-keyword">int</span> s;
    GC gc;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> colours[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">public</span>:
        ...
};</code></pre>

<p>If we add or change a private member, all clients must recompile. May be better to hide these details away.</p>

<p>Sol’n:</p>



<h3 id="pimpl-idiom-pointer-to-implementation">Pimpl idiom (“Pointer to implementation”)</h3>

<p>Create a second class XWindowImpl:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//XWindowImpl.h</span>
<span class="hljs-preprocessor">#include &lt;X11/Xlib.h&gt;</span>
<span class="hljs-keyword">struct</span> XWindowImpl{
    Display *d;
    window w;
    <span class="hljs-keyword">int</span> s;
    GC gc;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> colours[<span class="hljs-number">10</span>];
};

<span class="hljs-comment">//Window.h</span>
<span class="hljs-comment">//No need to include Xlib.h. Forward declare the impl. class</span>
<span class="hljs-keyword">class</span> XWindowImpl;
<span class="hljs-keyword">class</span> XWindow{
    XWindowImpl *pImpl;
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-comment">//no change</span>
};</code></pre>

<p>No compilation dependency on XWindowImpl. Clients also don’t depend on XWindowImpl.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Window.cc</span>
<span class="hljs-preprocessor">#include "window.h"</span>
<span class="hljs-preprocessor">#include "XWindowImpl.h"</span>
XWindow::XWindow(...): pImpl{newXWindowImpl{...}}{}</code></pre>

<p>Other methods: replace fields d,w,s, etc. <br>
with pImpl-&gt;d, pImpl-&gt;w etc</p>

<p>If all private fields are in XWindowImpl, then only window.cc needs recompiling if they change.</p>

<p>Generalization - Several possible window implementations <br>
e.g. XWindows YWindows - Then Impl struct could be a superclass <br>
<img src="http://amyqiu.me/Note/a7.png"></p>

<p>Bridge Pattern</p>



<h2 id="lecture-20">Lecture 20</h2>



<h3 id="measures-of-design-quality">Measures of Design Quality</h3>

<ul>
<li>coupling + cohesion</li>
</ul>

<dl>
<dt>coupling</dt>
<dd>the degree to which distinct program modules depend on each other</dd>

<dd>below: low to high coupling examples and degree.</dd>

<dd><strong>low</strong>: modules interact via function calls with basic params/results (lowest)</dd>

<dd><ul>
modules pass arrays/structs back + forth <br>
modules affect each other’s control flow (medium) <br>
modules share global data
</ul></dd>

<dd><strong>high</strong>: modules have access to each other’s implementation (friends) (highest)</dd>

<dt>cohesion</dt>
<dd>how closely elements of a module are related to each other</dd>

<dd><strong>low</strong>: arbitrary grouping of unrelated elements (eg <code>&lt;utility&gt;</code>)</dd>

<dd><ul>
elements share a common theme, otherwise unrelated - perhaps share some bas code  eg, <code>&lt;algorithm&gt;</code> <br>
elements manipulate state over the lifetime of an object (eg. open/read/close files) <br>
elements pass data to eachother
</ul></dd>

<dd><strong>high</strong>: elements cooperate to perform exactly one task</dd>
</dl>

<p>High coupling: changes to one module require greater changes to other modules. <br>
- harder to reuse individual modules <br>
Low cohesion: poorly organized code. Hard to understand/maintain.</p>

<p>Goal: low coupling, high cohesion</p>



<h3 id="decoupling-the-interface-mvc">Decoupling the Interface (MVC)</h3>

<p>Your primary program classes should not be printing things <br>
Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> ChessBoard{
    ...
    cou &lt;&lt; <span class="hljs-string">"Your move"</span> &lt;&lt; endl;
};</code></pre>

<p>Bad design - inhibits code reuse <br>
What if you want to reuse ChessBoard, but not have it communicate via stdout?</p>

<p>One solution: give the class stream objects where it can send it’s input/output</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> ChessBoard{
    <span class="hljs-built_in">std</span>::istream &amp;in;
    <span class="hljs-built_in">std</span>::ostream &amp;out;
    <span class="hljs-keyword">public</span>:
        ChessBoard(<span class="hljs-built_in">std</span>::istream &amp;in, <span class="hljs-built_in">std</span>::ostream &amp;out): in{in}, out{out} {...}
        ...
        out &lt;&lt; <span class="hljs-string">"Your move"</span> &lt;&lt;endl;
};</code></pre>

<p>Better - but what if we don’t want to use streams at all? Your chessboard class should not be doing any communication at all.</p>



<h3 id="single-responsibility-principle">Single Responsibility Principle</h3>

<p>“A class should have only one reason to change.”</p>

<ul>
<li>game state + communication are TWO reasons</li>
</ul>

<p>Better - Communicate with the chessboard via params/results</p>

<ul>
<li>confine user communication to outside the class</li>
</ul>

<p>Q: Should main do all of the communication and then call chessboard methods? <br>
A: No - hard to reuse code if it’s in main. Should have a class to manage interaction that is separate from the game state class.</p>



<h3 id="pattern-model-view-controller-mvc">Pattern: Model-View-Controller (MVC)</h3>

<p>Separate the distinct notions of the data (state), its presentation, and the control of the data. <br>
Model: the data (game state) <br>
View: how the model is displayed <br>
Controller: how the model is manipulated <br>
<img src="http://amyqiu.me/Notes/a8.png"> <br>
Model : </p>

<ul>
<li>can have multiple views (e.g. text + graphics)</li>
<li>doesn’t need to know their details</li>
<li>classic observer pattern (or communicate through controller)</li>
</ul>

<p>Controller </p>

<ul>
<li>mediates control flow through model + view</li>
<li>may encapsulate turn-taking, or full game rules</li>
<li>may fetch input from user (or this could be the view)</li>
</ul>

<p>By decoupling presentation + control, MVC promotes reuse</p>



<h3 id="exception-safety">Exception Safety</h3>

<p>Consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    MyClass *p = <span class="hljs-keyword">new</span> MyClass;
    MyClass mc;
    g();
    <span class="hljs-keyword">delete</span> p;
}</code></pre>

<p>No leaks - but what if g raises an exception?  <br>
What is guaranteed </p>

<ul>
<li>During stack unwinding, all stack allocated data is cleaned up - dtors run, memory reclaimed</li>
<li>so mc is cleaned up</li>
<li>heap-allocated memory is not freed</li>
</ul>

<p>So if g throws, p is leaked.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    MyClass *p = <span class="hljs-keyword">new</span> MyClass;
    MyClass mc;
    <span class="hljs-keyword">try</span> {
        g();
    }
    <span class="hljs-keyword">catch</span>(..){
        <span class="hljs-keyword">delete</span> p;
        <span class="hljs-keyword">throw</span>;
    }
    <span class="hljs-keyword">delete</span> p;
}</code></pre>

<p>This is tedious, error-prone and code duplication <br>
How else can we guarantee that something like <code>delete p</code> will happen no matter how we exit f? (normally or exn?)</p>

<p>In some languages - “finally” clauses that guarantee final actions - not in c++ <br>
Only thing you can count on in C++ <br>
- dtors for stack-allocated data will run <br>
Use stack-allocated data with dtors as much as possible <br>
Use this guarantee to your advantage</p>



<h3 id="c-idiom-raii-resource-acquisition-is-initialization-might-appear-on-final-exam-what-does-it-stand-for">C++ idiom : RAII - Resource Acquisition Is Initialization (**Might appear on final exam. What does it stand for?)</h3>

<p>Every resources should be wrapped in a stack-allocated object whose dtor frees it.</p>

<p>E.g. files:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">ifstream f{<span class="hljs-string">"name"</span>}; <span class="hljs-comment">//Acquiring the resource ("name") = initializing the object (f). File is guaranteed to be freed when f is popped from the stack because f's dtor runs.</span></code></pre>

<p>This can be done with dynamic memory</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> <span class="hljs-built_in">std</span>::unique_ptr&lt;T&gt;
<span class="hljs-comment">//- Takes a T* in the ctor</span>
<span class="hljs-comment">//- The dtor will delete the ptr.</span></code></pre>

<p>A better f()</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;();
    <span class="hljs-comment">// instead of auto, could also type, std::unique_ptr&lt;MyClass&gt;</span>
    <span class="hljs-comment">// ctor arges for myClass in ();</span>
    MyClass mc;
    g();
    <span class="hljs-comment">//no leaks, guaranteed</span>
};</code></pre>

<p>Get 4/10 bonus marks if your program doesn’t leak and doesn’t call delete</p>



<h2 id="lecture-21">Lecture 21</h2>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-keyword">auto</span> p=<span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;();
    MyClass mc;
    g();
    <span class="hljs-comment">//No leaks</span>
}</code></pre>

<p>Difficulty:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> c {...};
unique_ptr&lt;C&gt; p {<span class="hljs-keyword">new</span> C{...}};
unique_ptr&lt;C&gt; q=p; <span class="hljs-comment">//what happens here? when q/p is popped, may delete something twice :'(. X</span></code></pre>

<p>What happens when a unique_ptr is copied - don’t want to delete the same ptr twice! <br>
Instead - copying is disabled for unique_ptrs <br>
They can only be moved.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Sample implementation (repository)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> unique_ptr{
    T *ptr;
    <span class="hljs-keyword">public</span>:
        unique_ptr(T *p): ptr{p}{}
        ~unique_ptr() {<span class="hljs-keyword">delete</span> ptr;}
        unique_ptr(<span class="hljs-keyword">const</span> unique_ptr&lt;T&gt; &amp;other)=<span class="hljs-keyword">delete</span>;
        unique_ptr&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> unique_ptr&lt;T&gt; &amp;other)=<span class="hljs-keyword">delete</span>;
        unique_ptr(unique_ptr&lt;T&gt;&amp;&amp;other):ptr{other.ptr}{other.ptr=<span class="hljs-keyword">nullptr</span>;}
        unique_ptr&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(unique_ptr&lt;T&gt;&amp;&amp;other){
            <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
            swap(ptr, other.ptr);
            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        }       
        T &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> *ptr;}
};</code></pre>

<p>If you need to copy ptrs + can’t distinguish an owner - std::shared_ptr</p>



<pre class="prettyprint"><code class="language-cpp hljs ">{<span class="hljs-keyword">auto</span> p1=<span class="hljs-built_in">std</span>::make_shared&lt;MyClass&gt; ();
<span class="hljs-keyword">if</span>(...){
    <span class="hljs-keyword">auto</span> p2=p1;
} <span class="hljs-comment">//p2 is popped, ptr is not deleted</span>
}<span class="hljs-comment">//p1 is popped, ptr is deleted</span></code></pre>

<p>Shared ptrs maintain a reference count</p>

<ul>
<li>count of all shared_ptrs pointing at the same object</li>
<li>Memory is freed when the ref count hits 0</li>
</ul>



<pre class="prettyprint"><code class="language-scheme hljs clojure"><span class="hljs-list">(<span class="hljs-title">define</span> l1<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 1</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 2</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 3</span> empty)</span>)</span>)</span>)</span>
<span class="hljs-list">(<span class="hljs-title">define</span> l2<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 4</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">rest</span></span> l1)</span>)</span>)</span></code></pre>

<p>Use shared + unique ptrs as much as possible <br>
Dramatically fewer opportunities for leaks <br>
NEVER let the dtor emit an exception <br>
- if the dtor was executed during stack unwinding while dealing with another exn, you now have TWO active, unhandled exns and the program will abort immediately <br>
3 levels of exception safety for a f’n f: <br>
1. Basic guarantee - if an exn occurs, the program will be in a valid state. Nothing leaked, nothing corrupted, class invariants maintained <br>
2. Strong guarantee - if an exn is raised while executing f, the state of the program will be as it was before f was called. <br>
3. No-throw guarantee - f will never throw an ex’n and will always accomplish its task.</p>

<p>Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> A{...};
<span class="hljs-keyword">class</span> B{...};
<span class="hljs-keyword">class</span> C{
    A a;
    B b;
    <span class="hljs-keyword">void</span> f(){
        a.method1();<span class="hljs-comment">//may throw (strong guarantee)</span>
        b.method2();<span class="hljs-comment">//may throw (strong guarantee)</span>
    }
};</code></pre>

<p>Is C::f exn safe?. <br>
- if a.method1 throws, nothing has happened yet. OK <br>
- if b.method2 throws, effects of method1 would have to be undone to offer the strong guarantee. Very hard or impossible if method 1 has non-local side effects. <br>
- So no, probably not exn safe. <br>
If A’s method1 and B’s method2 do NOT have non-local side effects, can use COPY + SWAP.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> C{
    ...
    <span class="hljs-keyword">void</span> f(){
        A atemp=a; <span class="hljs-comment">// if these throws, f throws. Original A and B are still intact.</span>
        B btemp=b;
        atemp.method1();
        btemp.method2();
        a=atemp;
        b=btemp;
        <span class="hljs-comment">//If these throw, f throws, but original a + b still intact. HOWEVER, what if copy assignment throws?</span>
    }
};</code></pre>

<p>Better if the swap was nothrow. Copying ptrs can’t throw <br>
Sol’n. Use the pImpl idiom: </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> CImpl{
    A a;
    B b;
};

<span class="hljs-keyword">class</span> C{
    unique_ptr&lt;CImpl&gt; pImpl;
    ...
    <span class="hljs-keyword">void</span> f(){
        <span class="hljs-keyword">auto</span> temp = make_unique&lt;CImpl&gt;(*pImpl);
        temp-&gt;a.method1();
        temp-&gt;b.method2();
        <span class="hljs-built_in">std</span>::swap(pImpl. temp); <span class="hljs-comment">//no-throw</span>
    }
};</code></pre>

<p>If either A::method1 or B::method2 offer no exn safety guarantee, then neither can f.</p>



<h3 id="exn-safety-the-stl-vectors">Exn Safety + the STL: vectors</h3>

<p>Vectors - encapsulate a heap-allocated array <br>
-follow RAII - when a stack-allocated vector goes out of scope, the internal heap-allocated array is freed</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;MyClass&gt;</span> v;
    ...
} <span class="hljs-comment">//v goes out of scope - array is freed, MyClass dtor runs on all objects in the vector.</span></code></pre>

<p>But:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> g(){
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;MyClass *&gt;</span> v;
    ...
}<span class="hljs-comment">//array is freed but pointers don't have dtors so any objects pointed to by the pointers are not deleted (potential to leak)</span></code></pre>

<ul>
<li>v doesn’t know whether the pointers in the array own the objs they point at</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) <span class="hljs-keyword">delete</span> x;</code></pre>

<p>But:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> h(){
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;</span>&gt; v;
    ...
    <span class="hljs-comment">//array is freed, shared_ptr dtors run. So the objs ARE deleted if no other shared ptr points at them. NO explicit deallocation.</span>
}</code></pre>



<h2 id="lecture-22">Lecture 22</h2>



<h3 id="exception-safety-the-stl-continued">Exception Safety + the STL continued</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>::emplace_back</code></pre>

<ul>
<li>offers the strong guarantee</li>
<li>if the array is full (ie size = cap) <br>
<ul><li>allocate new array</li>
<li>copy objects over (copy ctor) <br>
<ul><li>if a copy ctor throws: destroy the new array. The old array is still intact. Strong guarantee</li></ul></li>
<li>delete old array</li></ul></li>
</ul>

<p>But:</p>

<ul>
<li>copying is expensive + the old data will be thrown away</li>
<li>wouldn’t moving the objs be more efficient? <br>
<ul><li>allocate new array</li>
<li>move objs over (move ctor). HOWEVER, if move ctor throws, can’t offer the strong guarantee. Original no longer intact.</li>
<li>delete old array</li></ul></li>
</ul>

<p>BUT: <br>
If the move ctor offers the nothrow guarantee, emplace_back will use the move ctor; else it will use the copy ctor, which is slower. So your move ops should provide the no-throw guarantee, and you should indicate that they do:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> MyClass{
    <span class="hljs-keyword">public</span>:
        MyClass(MyClass &amp;other) <span class="hljs-keyword">noexcept</span>{...}
        MyClass &amp;<span class="hljs-keyword">operator</span>=(MyClass &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;
};</code></pre>

<p>If you know a function will never throw or propagate an exception, declare it noexcept. This facilitates optimization.</p>

<p>At minimum: moves + swaps should be noexcept</p>



<h3 id="casting">Casting</h3>

<p>In C:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n;
<span class="hljs-keyword">int</span> *ip=(<span class="hljs-keyword">int</span> *) &amp;n; <span class="hljs-comment">//cast - forces c++ to treat a Node * as an int*</span></code></pre>

<p>C-style casts should be avoided in C++ <br>
If you must cast, use a C++-style cast:</p>

<p>4 Kinds:</p>



<h4 id="staticcast-sensible-casts">static_cast - “sensible” casts</h4>

<ul>
<li>Eg: double-&gt;int: </li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> i);
<span class="hljs-keyword">void</span> f(<span class="hljs-keyword">double</span> d);
f(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(d));</code></pre>

<ul>
<li><code>superclass ptr-&gt;subclass ptr</code></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *b = <span class="hljs-keyword">new</span> Text{...};
Text *t = <span class="hljs-keyword">static_cast</span>&lt;Text *&gt;(b);</code></pre>

<ul>
<li>you are taking responsibility that b actually points at a Text. “Trust me.”</li>
</ul>



<h4 id="reinterpretcast-unsafe-implementation-specific-weird-casts">reinterpret_cast - Unsafe, implementation-specific, “weird” casts.</h4>



<pre class="prettyprint"><code class="language-cpp hljs ">Student s;
Turtle *t = <span class="hljs-keyword">reinterpret_cast</span>&lt;Turtle *&gt; (&amp;s);</code></pre>



<h4 id="constcast-for-converting-between-const-non-const">const_cast - For converting between const + non-const</h4>

<p>The only C++ cast that can cast away const</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Won't compile if you just call g(p) since g doesn't guarantee p stays the same</span>
<span class="hljs-keyword">void</span> g(<span class="hljs-keyword">int</span> *p); <span class="hljs-comment">//given to you</span>
<span class="hljs-keyword">void</span> f(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p){ <span class="hljs-comment">// say you know that g will not modify *p - just not reflected in g's signature</span>
    ...
    g(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> *&gt;(p));
    ...
}</code></pre>



<h4 id="dynamiccast-is-it-safe-to-convert-a-book-to-a-text">dynamic_cast - Is it safe to convert a Book * to a Text * ?</h4>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *pb;
...
<span class="hljs-keyword">static_cast</span>&lt;Text *&gt; (pb)-&gt;getTopic(); <span class="hljs-comment">//safe? depends</span></code></pre>

<p>Depends on what pb actually points at. Better to do a tentative cast - try it + see if it succeeds.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *pb = ...;
Text *pt = <span class="hljs-keyword">dynamic_cast</span> &lt;Text *&gt; (pb);</code></pre>

<p>If the cast works (pb REALLY points at a Text, or at a subclass of Text), now pt points at that object. <br>
If the cast fails - pt will be nullptr</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">if</span>(pt) <span class="hljs-built_in">cout</span> &lt;&lt; pt-&gt;getTopic();
<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not a text"</span>;</code></pre>

<p>Should be using smart ptrs - can we do the same on them? <br>
Yes - <code>static_pointer_cast</code>, <code>const_pointer_cast</code>, <code>dynamic_pointer_cast</code> <br>
Cast shared_ptrs to shared_ptrs <br>
can use dynamic casting to make decisions based on an object’s RTTI(run time type information)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> whatIsIt(<span class="hljs-built_in">shared_ptr</span>&lt;Book&gt; b){
    <span class="hljs-keyword">if</span>(dynamic_pointer_cast &lt;Comic&gt;(b)) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Comic"</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dynamic_pointer_cast &lt;Text&gt;(b)) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Text"</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Normal Book"</span>;
}</code></pre>

<p>Code like this is highly coupled to the book class hierarchy and may indicate bad design. Better - use virtual methods or write a visitor.</p>

<blockquote>
  <p>Note: dynamic casting only works on classes with at least one virtual method</p>
</blockquote>



<h2 id="lecture-23">Lecture 23</h2>

<p></p>

<p>The one I missed. Uhhh refer to pdf.</p>

<h2 id="lecture-24">Lecture 24</h2>

<p><img src="http://amyqiu.me/Notes/a9.png"> <br>
Distance to base class not always the same!</p>

<ul>
<li>location of superclass is stored in the vtable</li>
</ul>

<p>Diagram doesn’t look like A,BmCmD simultaneously - but slices of it do look like A,B,C,D</p>



<pre class="prettyprint"><code class="language-cpp hljs ">D d;
A*a = &amp;d;<span class="hljs-comment">//shifts the address</span></code></pre>

<p>Therefore ptr assignment among A,B,C,D changes the address stored in the ptr.</p>

<ul>
<li>static/const/dynamic cast under multi-inheritance also chang the value of the ptr.</li>
<li>reinterpret_cast will not</li>
</ul>



<h3 id="template-functions">Template Functions</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T min(T x, T y){
    <span class="hljs-keyword">return</span> x&lt;y? x: y;
}

<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span> z=min(x,y); <span class="hljs-comment">//T=int - Don't need to say min&lt;int&gt; because C++ can infer that T=int from the types of X and Y (Does not apply to template classes)</span></code></pre>

<p>If C++ cannot determine T, you can tell it: <code>min&lt;int&gt;(x,y);</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">char</span> w = min (<span class="hljs-string">'a'</span>,<span class="hljs-string">'c'</span>); <span class="hljs-comment">//T = char</span>
<span class="hljs-keyword">auto</span> f = min(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>); <span class="hljs-comment">//T= float</span></code></pre>

<p>for what types T can min be used?</p>

<ul>
<li>For what types T will the body compile?</li>
<li>any type for which operator &lt; is defined</li>
</ul>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> for_each(AbstractIterator start, AbstractIterator finish, <span class="hljs-keyword">int</span>(*f)(<span class="hljs-keyword">int</span>)){
    <span class="hljs-keyword">while</span>(start!=finish){
        f(* start);
        ++start;
    }
}</code></pre>

<p>Works as long as AbstractIterator supports !=, *, ++ <br>
f can be called as a f’n <br>
Make these template arguments:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter, <span class="hljs-keyword">typename</span> Func&gt;
    <span class="hljs-keyword">void</span> for_each(Iter start, Iter finish, Func f){
        <span class="hljs-keyword">while</span>(start!= finish){
            f(*start);
            ++start;
        }
    }</code></pre>

<p>Now Iter can by ANY type supporting !=, *, ++ (including raw pointers)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> n){<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;}
<span class="hljs-keyword">int</span> a[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
for_each(a, a+<span class="hljs-number">5</span>, f); <span class="hljs-comment">//- prints the array</span></code></pre>



<h3 id="stl-algorithm-library">STL <code>&lt;algorithm&gt;</code> library</h3>

<ul>
<li>a suite of template functions, many of which work over iterators</li>
<li>Examples: for_each (as given above)</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter, <span class="hljs-keyword">typename</span> T&gt;
    Iter find(Iter first, Iter last, <span class="hljs-keyword">const</span> T &amp;val){
        <span class="hljs-comment">// returns iterator to first item in [first, last) matching T.</span>
        <span class="hljs-comment">//or last, if not found;</span>
    }</code></pre>

<p>count - like find, but returns # of occurrences of val</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter&gt;
    OutIter copy(InIter first, InIter last, OutIter result){
        <span class="hljs-comment">// copies one container range [first, last)</span>
        <span class="hljs-comment">//to another, starting at result</span>
    }

<span class="hljs-comment">// Note: does not allocate new memory</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> w(<span class="hljs-number">4</span>); <span class="hljs-comment">//space for 4 ints</span>
copy(v.begin()+<span class="hljs-number">1</span>, v.begin()+<span class="hljs-number">5</span>, w.begin());
<span class="hljs-comment">//w = {2,3,4,5}</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter, <span class="hljs-keyword">typename</span> Func&gt;
    OutIter transform(InIter first, InIter last, OutIter result, Func f){
        <span class="hljs-keyword">while</span>(first != last){
            *result = f(*first);
            ++first;
            ++result;
        }
        <span class="hljs-keyword">return</span> result;
    }</code></pre>

<p>Eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> add1(<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;}
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> w(v.size());
transform(v.begin(),v.end(),w.begin(), addI);
<span class="hljs-comment">// w={3,4,6,8,12}</span></code></pre>

<p>How general is this code? <br>
1. what can we use for Func? <br>
2. what can we use for InIter/OutIter?</p>

<ol>
<li>Func: How is f used? f(*first) <br>
<ul><li>f can be anything that can be called as a f’n</li>
<li>Can write operator() for objects</li>
<li>eg: <code>class Plus1{public: int operator()(int n){return n+1;}};</code></li>
<li><code>Plus1 p;</code></li>
<li><code>p(4); //produces 5</code></li></ul></li>
</ol>



<pre class="prettyprint"><code class="language-cpp hljs ">transform(v.begin(), v.end(), w.begin(), Plus1());

<span class="hljs-comment">//Generalize:</span>
<span class="hljs-keyword">class</span> Plus{
    <span class="hljs-keyword">int</span> m;
    <span class="hljs-keyword">public</span>:
        Plus(<span class="hljs-keyword">int</span> m): m{m}{}
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> n) {<span class="hljs-keyword">return</span> n+m;}
};

transform(v.begin(), v.end(), w.begin(), Plus{<span class="hljs-number">1</span>});</code></pre>

<p>Plus1, Plus - called function objects <br>
Advantage of f’n objects - can maintain state</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> IncreasingPlus{
    <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n+(m++);}
        <span class="hljs-keyword">void</span> reset() {m=<span class="hljs-number">0</span>;}
};

<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> w(v.size());
transform(v.begin(), v.end(),w.begin(), IncreasingPlus());
<span class="hljs-comment">// w = {0, 1, 2, 3, 4}</span></code></pre>

<p>Consider: How many ints in vector v are even?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v {...};
<span class="hljs-keyword">bool</span> even(<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;}
<span class="hljs-keyword">int</span> x=count_if(v.begin(),v.end(), even);</code></pre>

<p>Seems a waste to explicitly create the f’n even. If this were Racket, we’d use lambda. <br>
Do the same here:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x=count_if(v.begin(),v.end(),[](<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;});
<span class="hljs-keyword">auto</span> even = [](<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;}

<span class="hljs-keyword">int</span> f(<span class="hljs-keyword">decltype</span>(even)){...} <span class="hljs-comment">//whatever even's type is</span></code></pre>

<p>2 - Iterators - <br>
Apply the notion of iteration to other data sources. eg. streams</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iterator&gt;</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;</span>v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
ostream_iterator &lt;<span class="hljs-keyword">int</span>&gt; out {<span class="hljs-built_in">cout</span>, <span class="hljs-string">","</span>};
copy(v.begin(),v.end(),out); <span class="hljs-comment">//prints 1,2,3,4,5,</span>

<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>w;
copy(v.begin(),v.end(),w.begin()); <span class="hljs-comment">//X won't work. Seg fault</span></code></pre>

<p>Remember - copy doesn’t allocate space in w. It can’t - it doesn’t even know that w’s iterating over a vector!</p>

<p>But what if we had an iterator whose assignment operator inserts a new item?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">copy(v.begin(), v.end(), back_inserter(w));</code></pre>

<p>copies v to w, allocates space if necessary</p>

<p>The end.</p></body>
</html>

<!--
2: Using highlight.js
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CS 246</title>
<link rel="stylesheet" type="text/css" href="https://www.dropbox.com/s/atz4kqwayz4hlhk/markDown.css?raw=1">
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script> 
</head>
<body><h1 id="cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</h1>

<blockquote>
  <p>Brad Lushman <br>
  Office: DC 3110 <br>
  Email: bmlushma <br>
  <a href="http://www.student.cs.uwaterloo.ca/~cs246">http://www.student.cs.uwaterloo.ca/~cs246</a> <br>
  Linux is required! Ripperino</p>
</blockquote>

<p><div class="toc">
<ul>
<li><a href="#cs-246-object-oriented-software-development">CS 246 - Object-Oriented Software Development</a><ul>
<li><a href="#lecture-1">Lecture 1</a><ul>
<li><a href="#linux-please">Linux, Please</a></li>
<li><a href="#module-1-linux-shell">Module 1 - Linux Shell</a></li>
<li><a href="#linux-file-system">Linux File System</a></li>
<li><a href="#pipes">Pipes</a></li>
</ul>
</li>
<li><a href="#lecture-2">Lecture 2</a><ul>
<li><a href="#pipes-cont">Pipes Cont.</a></li>
<li><a href="#pattern-matching-in-text-files">Pattern-Matching in Text Files</a></li>
<li><a href="#permissions">Permissions</a></li>
</ul>
</li>
<li><a href="#lecture-3">Lecture 3</a><ul>
<li><a href="#shell-scripts">Shell Scripts</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#loops">Loops</a></li>
</ul>
</li>
<li><a href="#lecture-4">Lecture - 4</a><ul>
<li><a href="#se-topic-testing">SE Topic: Testing</a></li>
<li><a href="#module-2-c">Module 2: C++</a></li>
<li><a href="#compiling-c-programs">Compiling C++ programs</a></li>
<li><a href="#inputoutput">Input/Output</a></li>
</ul>
</li>
<li><a href="#lecture-5">Lecture 5</a><ul>
<li><a href="#reading-strings">Reading Strings</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#string-operations">String Operations:</a></li>
<li><a href="#default-fn-params">Default f’n Params</a></li>
<li><a href="#overloading">Overloading</a></li>
</ul>
</li>
<li><a href="#lecture-6">Lecture 6</a><ul>
<li><a href="#structs">Structs</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#parameter-passing">Parameter Passing</a></li>
<li><a href="#references">References</a></li>
<li><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
</ul>
</li>
<li><a href="#lecture-7">Lecture 7</a><ul>
<li><a href="#operator-overloading">Operator Overloading</a></li>
<li><a href="#overloading-and">Overloading &lt;&lt; and &gt;&gt;</a></li>
<li><a href="#the-preprocessor">The Preprocessor</a></li>
<li><a href="#separate-compilation">Separate Compilation</a></li>
<li><a href="#compiling-separately">Compiling Separately</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</a><ul>
<li><a href="#lecture-8">Lecture 8</a><ul>
<li><a href="#classes">Classes</a></li>
</ul>
</li>
<li><a href="#lecture-9">Lecture 9</a><ul>
<li><a href="#uniform-initialization">Uniform Initialization</a></li>
<li><a href="#destructors">Destructors</a></li>
<li><a href="#copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</a></li>
</ul>
</li>
<li><a href="#lecture-10">Lecture 10</a><ul>
<li><a href="#rvalues-rvalue-references">Rvalues + Rvalue References</a></li>
<li><a href="#copymove-elision">Copy/Move Elision</a></li>
</ul>
</li>
<li><a href="#lecture-11">Lecture - 11</a><ul>
<li><a href="#separate-compilation-for-classes">Separate Compilation for Classes</a></li>
<li><a href="#arrays-of-objects">Arrays of Objects</a></li>
<li><a href="#const-objects">Const Objects</a></li>
<li><a href="#static-fields-methods">Static Fields + Methods</a></li>
<li><a href="#static-member-functions">Static Member Functions</a></li>
<li><a href="#invariants-encapsulation">Invariants + Encapsulation</a></li>
</ul>
</li>
<li><a href="#cs-246-tut-5">CS 246 TUT 5</a></li>
<li><a href="#lecture-12">Lecture 12</a><ul>
<li><a href="#se-topic-design-patterns">SE Topic: Design Patterns</a></li>
<li><a href="#tools-topic-make">Tools topic: make</a></li>
</ul>
</li>
<li><a href="#lecture-13">Lecture 13</a><ul>
<li><a href="#makefile">Makefile</a></li>
<li><a href="#system-modelling">System Modelling</a></li>
<li><a href="#aggegation">Aggegation</a></li>
<li><a href="#inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</a></li>
</ul>
</li>
<li><a href="#lecture-14">Lecture 14</a><ul>
<li><a href="#destructor-revisited">Destructor Revisited</a></li>
</ul>
</li>
<li><a href="#lecture-15">Lecture 15</a><ul>
<li><a href="#pure-virtual-methods-abstract-classes">Pure Virtual Methods + Abstract Classes</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#the-standard-template-library-stl">The Standard Template Library (STL)</a></li>
</ul>
</li>
<li><a href="#lecture-16">Lecture 16</a><ul>
<li><a href="#design-patterns-ctd">Design Patterns Ct’d</a></li>
<li><a href="#observer-pattern">Observer Pattern</a></li>
</ul>
</li>
<li><a href="#lecture-17">Lecture 17</a><ul>
<li><a href="#decorator-pattern">Decorator Pattern</a></li>
<li><a href="#inheritance-and-copymove">Inheritance and Copy/Move</a></li>
</ul>
</li>
<li><a href="#lecture-18">Lecture 18</a><ul>
<li><a href="#factory-method-pattern">Factory Method Pattern</a></li>
<li><a href="#template-method-pattern">Template Method Pattern</a></li>
<li><a href="#stl-maps-for-creating-dictionaries">STL Maps - for creating Dictionaries</a></li>
</ul>
</li>
<li><a href="#lecture-19">Lecture 19</a><ul>
<li><a href="#visitor-pattern">Visitor Pattern</a></li>
<li><a href="#pimpl-idiom-pointer-to-implementation">Pimpl idiom (“Pointer to implementation”)</a></li>
</ul>
</li>
<li><a href="#lecture-20">Lecture 20</a><ul>
<li><a href="#measures-of-design-quality">Measures of Design Quality</a></li>
<li><a href="#decoupling-the-interface-mvc">Decoupling the Interface (MVC)</a></li>
<li><a href="#single-responsibility-principle">Single Responsibility Principle</a></li>
<li><a href="#pattern-model-view-controller-mvc">Pattern: Model-View-Controller (MVC)</a></li>
<li><a href="#exception-safety">Exception Safety</a></li>
<li><a href="#c-idiom-raii-resource-acquisition-is-initialization-might-appear-on-final-exam-what-does-it-stand-for">C++ idiom : RAII - Resource Acquisition Is Initialization (**Might appear on final exam. What does it stand for?)</a></li>
</ul>
</li>
<li><a href="#lecture-21">Lecture 21</a><ul>
<li><a href="#exn-safety-the-stl-vectors">Exn Safety + the STL: vectors</a></li>
</ul>
</li>
<li><a href="#lecture-22">Lecture 22</a><ul>
<li><a href="#exception-safety-the-stl-continued">Exception Safety + the STL continued</a></li>
<li><a href="#casting">Casting</a><ul>
<li><a href="#staticcast-sensible-casts">static_cast - “sensible” casts</a></li>
<li><a href="#reinterpretcast-unsafe-implementation-specific-weird-casts">reinterpret_cast - Unsafe, implementation-specific, “weird” casts.</a></li>
<li><a href="#constcast-for-converting-between-const-non-const">const_cast - For converting between const + non-const</a></li>
<li><a href="#dynamiccast-is-it-safe-to-convert-a-book-to-a-text">dynamic_cast - Is it safe to convert a Book * to a Text * ?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-23">Lecture 23</a></li>
<li><a href="#lecture-24">Lecture 24</a><ul>
<li><a href="#template-functions">Template Functions</a></li>
<li><a href="#stl-algorithm-library">STL <algorithm> library</algorithm></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>



<h2 id="lecture-1">Lecture 1</h2>



<h3 id="linux-please">Linux, Please</h3>

<blockquote>
  <p>Options: <br>
  1. Lab, computers <br>
  2. Install Linux on your machine <br>
  3. ssh into school machines (recommended) (Windows: download putty.exe, winscp for file transfer) <br>
  4. Cygwin - ewwwwwww <br>
  Also - install an xwindows server. eg. XMing</p>
</blockquote>

<p>Modules:  <br>
1 - Linux Shell (2 weeks) <br>
2 - C++ (10 weeks) <br>
3 - Tools (interspersed) <br>
4 - Software engineering (interspersed)</p>

<p>Homework: Print Linux handout from Piazza, and bring it to class</p>



<h3 id="module-1-linux-shell">Module 1 - Linux Shell</h3>

<blockquote>
  <p>Shell - interface to OS - get the OS to do things - run programs, manage files - graphical shell (clicking with mouse/ touch interface) - command line - type commands at a prompt - more versatile</p>
</blockquote>

<p>This course: bash</p>

<p>Make sure you are using bash! - Log in + type echo $0 <br>
- should say bash</p>



<h3 id="linux-file-system">Linux File System</h3>

<p>Working with files <br>
- cat - displays the contents of a file <br>
- cat /usr/share/dict/words <br>
- general format: root (top) directory/ directories (contains files)/ file</p>

<blockquote>
  <p>In Linux, a directory is considered a kind of file</p>
</blockquote>

<p><code>^C</code> to stop a program <br>
ls : list files in current dir (non-hidden files) <br>
ls -a : gives all files (even hidden ones) <br>
hidden files start with a dot <br>
pwd - prints current directory</p>

<p>What happens if you type cat? <br>
- waits for input <br>
- prints everything you type <br>
Useful? - if we can capture input in file. <br>
Observe: </p>

<p><code>cat &gt; output.txt</code></p>

<p>To stop: Ctrl - D (^D) at the beginning of a line sends an end of file signal <br>
In general: command args &gt; file ; executes command args + captures the output in file <br>
- called <strong><em>output redirection</em></strong></p>

<p>Can also redirect input:</p>

<p><code>cat &lt; inputfile.txt</code></p>

<ul>
<li>takes input from inputfile.txt instead of keyboard</li>
<li>displays inputfile.txt</li>
<li>seems equal to cat inputfile.txt</li>
</ul>

<p>What’s the difference?</p>

<p><code>cat inputfile.txt</code></p>

<p>passes the name <code>inputfile.txt</code> as an arg to cat. cat opens the file and displays it</p>

<p><code>cat &lt; inputfile.txt</code></p>

<p>SHELL opens <code>inputfile.txt</code> and passes the contents to cat in place of keyboard or input</p>

<p>Observe:</p>



<pre class="prettyprint"><code class=" hljs avrasm">wc output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span> output<span class="hljs-preprocessor">.txt</span>

wc &lt; output<span class="hljs-preprocessor">.txt</span>
&gt; <span class="hljs-number">2</span>  <span class="hljs-number">5</span> <span class="hljs-number">27</span></code></pre>

<p>Also: <code>cat *.txt</code> &lt;- globbing pattern <br>
(* means match any sequence of chars) <br>
- shell finds all files in the current dir that matches the pattern + substitutes on the cmd line.  <br>
(eg. <code>cat a.txt, b.txt, c.txt</code> - opens all 3 and displays)</p>

<p>More globbing patterns - Linux Sheet <br>
Many, but not all programs accept input either on the command line or by redirection</p>

<p>Can do both redirections <br>
<code>cat &lt; in.txt &gt; out.txt</code></p>

<p>Every process is attached to 3 streams: stdin, stderr, stdout</p>

<dl>
<dt>By default</dt>
<dd>stdin = keyboard - redirect with &lt;</dd>

<dd>stdout, stderr = screen (redirect with &gt;)</dd>

<dt>stderr</dt>
<dd>separate output stream - for error messages</dd>

<dd>so that output + error messages can go to different places</dd>

<dd>so that error msgs don’t clutter output file + corrupt formatting <br>
Also: stdout may be buffered - system may wait to accumulate output before actually printing it ( flushing the buffer)</dd>
</dl>

<p>stderr - never buffered - get errror msgs immediately</p>



<h3 id="pipes">Pipes</h3>

<p>Use output from one program as the input of another</p>

<blockquote>
  <p><strong>Example: How many words occur in the first 20 lines of myfile.txt?</strong> <br>
  Tools (sheet): <br>
  <code>head -n file</code> gives the first n lines of the file <br>
  <code>wc</code> counts words, lines, characters <br>
  <code>wc -w</code> gives just words <br>
  Soln: head -20 myfile.txt | wc -w <br>
  the | is a pipe</p>
</blockquote>



<h2 id="lecture-2">Lecture 2</h2>



<h3 id="pipes-cont">Pipes Cont.</h3>

<p>How many words occur in the first 20 lines of myfile.txt? <br>
Sol’n <code>head -20 myfile.txt | wc -w</code> or <code>cat myfile.txt | head -20 | wc -w</code></p>

<p>Eg. Suppose words1.txt, words2.txt, etc. contain lists of words, one per line. Print a duplicate-free list of all words that occur in any of these lines.</p>

<blockquote>
  <p><strong>uniq</strong> - removes CONSECUTIVE duplicate entries -if entries are sorted, then it removes <em>all</em> duplicates <br>
  <strong>sort</strong> - sorts lines</p>
</blockquote>

<p><code>cat words*.txt | sort | uniq</code></p>

<p>Can we use the output of one program as param of another? (yes)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> <span class="hljs-string">"Today is <span class="hljs-variable">$(date)</span> and I am <span class="hljs-variable">$(whoami)</span>"</span>
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Shell executes date + whoami + substitues the result into the command line <br>
The quotations make it into only ONE arg. Also, whitespace here is used.</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-built_in">echo</span> Today is $(date) and I am           $(whoami)
&gt; Today is Tue Sep <span class="hljs-number">13</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> EDT <span class="hljs-number">2016</span> and I am alqiu</code></pre>

<p>Here, echo is given 7 arguments. Whitespace is ignored</p>

<blockquote>
  <p>Careful: </p>
  
  <pre class="prettyprint"><code class=" hljs applescript">echo 'Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)'
&gt; Today <span class="hljs-keyword">is</span> $(<span class="hljs-type">date</span>) <span class="hljs-keyword">and</span> I am $(whoami)</code></pre>
  
  <p>Single quotes does not make any substitutions.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs delphi">echo *
echo <span class="hljs-string">'*'</span> #outputs the same <span class="hljs-comment">(*)
echo "*" #outputs the same (*)</span></code></pre>



<h3 id="pattern-matching-in-text-files">Pattern-Matching in Text Files</h3>

<dl>
<dt>egrep (“extended global regular expression print”)</dt>
<dd>egrep pattern file - prints every line in a file that contains a match to pattern</dd>
</dl>

<p>eg. Print every line in index.html that contains cs246.</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep cs246 index.html</code></pre>

<p>How many lines in index.html contain cs246 or CS246?</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"cs246|CS246"</span> index.html | wc <span class="hljs-operator">-l</span> //the quotes are really important here since bash thinks | is a pipe otherwise</code></pre>

<p>Alt soln:</p>



<pre class="prettyprint"><code class="language-bash hljs ">egrep <span class="hljs-string">"(cs|CS)246"</span> index.html | wc <span class="hljs-operator">-l</span></code></pre>

<p>Available patterns - called regular expressions (different from globbing patterns)</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-string">"(c|C)(s|S)246"</span> -also matches cS246, Cs246
<span class="hljs-string">"[cC][sS]246"</span></code></pre>

<p>[..] - any one char between [ and ] <br>
[<script type="math/tex" id="MathJax-Element-1">\text{^}</script> .. ] - any one char except</p>

<p>Add optional space:  <code>"[cC][sS] ?246"</code> <br>
? = 0 or 1 of the preceding expression (0 or 1 space in this case) <br>
* = 0 or more of preceding </p>



<pre class="prettyprint"><code class=" hljs r"><span class="hljs-string">"(cs)*246"</span>
&gt; <span class="hljs-number">246</span>, cs246, cscs246 <span class="hljs-keyword">...</span></code></pre>

<p>. = any single character <br>
.* = anything</p>



<pre class="prettyprint"><code class=" hljs perl">egrep <span class="hljs-string">"cs.<span class="hljs-variable">*246</span>"</span> <span class="hljs-keyword">index</span>.html</code></pre>

<ul>
<li>lines containing cs(anything) 246</li>
<li>^, $ - beginning + end of a line <br>
<code>"^cs246"</code> - lines that start with 246 <br>
<code>"^cs246$"</code> - lines that are exactly 246 <br>
+ = 1 or more occurrences of preceding pattern <br>
.+ - non-empty.</li>
</ul>

<p>Eg lines of even length</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-string">"^(..)*$"</span></code></pre>

<p>Files in the current dir whose names contain exactly one a.</p>



<pre class="prettyprint"><code class=" hljs 1c">ls <span class="hljs-string">| egrep "</span>[^a]*a[^a]*<span class="hljs-string">"</span></code></pre>

<p>All words in the global dictionary that start with e and have 5 characters</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">egrep <span class="hljs-string">"^e....$"</span> /usr/share/dict/<span class="hljs-keyword">words</span></code></pre>



<h3 id="permissions">Permissions</h3>

<p><code>ls - l</code> - “long form” listening</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-attribute">-rw</span><span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span> <span class="hljs-number">1</span> j2smith j2smith <span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span> abc<span class="hljs-built_in">.</span>txt
(<span class="hljs-subst">-</span>)<span class="hljs-keyword">type</span><span class="hljs-subst">|</span>(rw<span class="hljs-attribute">-r</span><span class="hljs-subst">-----</span>)permissions<span class="hljs-subst">|</span>(<span class="hljs-number">1</span>)<span class="hljs-variable">#of</span> links<span class="hljs-subst">|</span> (j2smith) owner<span class="hljs-subst">|</span> (j2smith) <span class="hljs-keyword">group</span><span class="hljs-subst">|</span> (<span class="hljs-number">25</span>) size <span class="hljs-subst">|</span> (<span class="hljs-number">25</span> Sep <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>) last modified <span class="hljs-subst">|</span> (abc<span class="hljs-built_in">.</span>txt) name</code></pre>

<dl>
<dt>groups</dt>
<dd>a user can belong to one or more groups</dd>

<dd>a file can be associated with one group</dd>

<dt>type</dt>
<dd><code>-</code> an ordinary file</dd>

<dd><code>d</code> directory</dd>

<dt>permissions</dt>
<dd><code>rwxrwxrwx</code> -&gt; 1st rwx bits are “user bits”, then next 3 are “group bits”, last is “other bits” <br>
<strong>Apply to:</strong> <br>
- user bits: file’s owner <br>
- group bits: members of the file’s group other than the owner <br>
- other bits: everyone else <br>
<code>r</code> - read bit <br>
<code>w</code> - write bit <br>
<code>x</code> - execute bit</dd>
</dl>

<table>
<thead>
<tr>
  <th>Bit</th>
  <th>Meaning for Ordinary Files</th>
  <th>Meaning for directories</th>
</tr>
</thead>
<tbody><tr>
  <td>r</td>
  <td><code>files contents can be read</code></td>
  <td><code>directory's contents can be read (eg. ls works, globbing, tab completion)</code></td>
</tr>
<tr>
  <td>w</td>
  <td><code>files contents can be modified</code></td>
  <td><code>directory's contents can be modified</code></td>
</tr>
<tr>
  <td>x</td>
  <td><code>file can be executed as a program</code></td>
  <td><code>directory can be navigated (i.e. can cd into the dir)</code></td>
</tr>
</tbody></table>


<blockquote>
  <p>dir’s exec. bit not set = no access at all to the dir, nor to any subdir, nor to any file within it. <br>
  Changing permissions: <code>chmod mode file</code></p>
</blockquote>

<p>Mode:</p>

<table>
<thead>
<tr>
  <th></th>
  <th></th>
  <th></th>
</tr>
</thead>
<tbody><tr>
  <td>u - user</td>
  <td><ul>
add perm
</ul></td>
  <td>r read</td>
</tr>
<tr>
  <td>g - group</td>
  <td><ul>
remove perm
</ul></td>
  <td>w write</td>
</tr>
<tr>
  <td>o - other</td>
  <td>= set perm</td>
  <td>x execute</td>
</tr>
<tr>
  <td>a- all</td>
  <td></td>
  <td></td>
</tr>
</tbody></table>


<p>eg.  <br>
give others read permission: chmod o+r file  <br>
make everyone’s permission rx: a = rx <br>
give owner full control: u = rwx or u+rwx</p>

<blockquote>
  <p>Changing permissions - &gt; exclusive right of the owner</p>
</blockquote>



<h2 id="lecture-3">Lecture 3</h2>



<h3 id="shell-scripts">Shell Scripts</h3>

<blockquote>
  <p>files containing sequences of shell commands, executed as programs</p>
</blockquote>

<p>eg. Print date, current user, current dir</p>



<pre class="prettyprint"><code class="language-bash hljs "><span class="hljs-comment">#!/bin/bash //"shebang" line - executes this file as a bash script</span>
date
whoami
<span class="hljs-built_in">pwd</span></code></pre>

<blockquote>
  <p>Note: the script does not have the execute bit turned on. Give the file execute permission: <code>chmod u+x myscript</code> <br>
  Run the file: <code>./myscript</code></p>
</blockquote>



<h3 id="variables">Variables</h3>

<p><code>x=1</code> (NO spaces)</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
&gt; <span class="hljs-number">1</span></code></pre>

<blockquote>
  <p>Note: use <script type="math/tex" id="MathJax-Element-2"> when fetching the value of a var  
  No </script> when setting a var. <br>
  Good practice: <script type="math/tex" id="MathJax-Element-3">{x}  
  All vars contain STRINGS. x is the string 1  
  Eg. dir=~cs246  
  echo </script>{dir}</p>
</blockquote>

<p>Some “global” vars available: <br>
Important: PATH - list of dirs; When you type a command, the shell searches these directories in order for a program with that name</p>

<blockquote>
  <p>Eg. Check whether a word is in the directory <br>
  eg. <code>./isItAWord hello</code></p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/shar/dict/words</code></pre>

<blockquote>
  <p>Prints nothing if word not found <br>
  Prints the word if found</p>
</blockquote>

<p>Eg. - a good password should not be in the dictionary <br>
answer whether a word is a good password</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> /usr/share/dict/words &gt; /dev/null //(suppresses output)
<span class="hljs-keyword">if</span> [ $? <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> ]; <span class="hljs-keyword">then</span> //the ; here allows you to put the <span class="hljs-keyword">then</span> on the same line
    <span class="hljs-built_in">echo</span> Bad password
<span class="hljs-keyword">else</span> 
    <span class="hljs-built_in">echo</span> Maybe a good password
<span class="hljs-keyword">fi</span> //ends the <span class="hljs-keyword">if</span>?</code></pre>

<p>Note: every program returns a status code when finished <br>
egrep: returns 0 if found, 1 if not found (In Linux: 0 is success, non-0 is fail)</p>

<p>$? = status of the most recently executed command</p>

<p>Verify # of args ; print error msg if wrong</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">usage</span></span>(){
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> password"</span> &gt;&amp;<span class="hljs-number">2</span>
}
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> <span class="hljs-operator">-ne</span> <span class="hljs-number">1</span>]; <span class="hljs-keyword">then</span>
    usage
    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">fi</span>
...(as before)</code></pre>



<pre class="prettyprint"><code class=" hljs r">If stmt: //comparisons + other conditions handout
    <span class="hljs-keyword">if</span> [ cond ]; then
        <span class="hljs-keyword">...</span>
    elif [ cond ]; then
        <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">...</span>
fi</code></pre>



<h3 id="loops">Loops</h3>

<p>Print #’s from 1 to $1</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
x=<span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> [ <span class="hljs-variable">$x</span> -le <span class="hljs-variable">$1</span>]; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
    x=<span class="hljs-variable">$x</span>+<span class="hljs-number">1</span>
<span class="hljs-keyword">done</span></code></pre>

<p>This gives you “1+1” literally if x=1 <br>
you want $((…)) for arithmetic instead</p>

<p>Looping over a list <br>
eg. Rename all .cpp files to .cc</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *.cpp; <span class="hljs-keyword">do</span>
    mv <span class="hljs-variable">${name}</span> <span class="hljs-variable">${name%cpp}</span>cc
<span class="hljs-keyword">done</span></code></pre>

<blockquote>
  <p>note: <br>
  *.cpp -&gt; glob - replaced with all matching files  <br>
  name%cpp is the val of name, without the trailing cpp.</p>
</blockquote>

<p>How many times does word <script type="math/tex" id="MathJax-Element-4">1 appear in file </script>2?</p>



<pre class="prettyprint"><code class=" hljs bash">x=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$2</span>); <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span> = <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]; <span class="hljs-keyword">then</span>
        x=$((x+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span></code></pre>

<blockquote>
  <p>Payday is the last Friday of the month. When is this month’s payday? <br>
  2 tasks: Compute date <br>
               Report answer</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-shebang">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">answer</span></span>(){
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month is the 31st"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"This month: the <span class="hljs-variable">${1}</span>th"</span>
}<span class="hljs-keyword">fi</span>
answer $(cal | awk <span class="hljs-string">'{print $6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<p>Generalize to any month. <code>cal October 2016</code> -gives Oct’s calendar <br>
let payday October 2016 give october’s payday</p>

<p>ALL OF THESE ARE IN THE REPO</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-function"><span class="hljs-title">answer</span></span>(){
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$2</span> ]; <span class="hljs-keyword">then</span>
        preamble=<span class="hljs-variable">$2</span>
    <span class="hljs-keyword">else</span>
        preamble = <span class="hljs-string">"This month"</span>
    <span class="hljs-keyword">fi</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> <span class="hljs-operator">-eq</span> <span class="hljs-number">31</span>]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble}</span>: the 31st"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${preamble: the ${1}</span>th}"</span>
    <span class="hljs-keyword">fi</span>
}
answer $(cal <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> | awk <span class="hljs-string">'{print #6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -<span class="hljs-number">1</span>)</code></pre>

<blockquote>
  <p>note: no such thing as scope. You can reference from anywhere. if the var doesn’t exist, you get a blank.</p>
</blockquote>



<h2 id="lecture-4">Lecture - 4</h2>



<h3 id="se-topic-testing">SE Topic: Testing</h3>

<ul>
<li>essential part of program development</li>
<li>on going  <br>
<ul><li>not just at the end</li>
<li>Begins <strong>before</strong> you start coding</li>
<li>Test suites - expected behaviour <br>
<script type="math/tex" id="MathJax-Element-5">\neq</script> debugging - cannot debug without first testing</li></ul></li>
<li>cannot guarantee correctness - cannot prove wrongness</li>
<li>ideally, developer + tester should be different people</li>
</ul>

<p>Human testing </p>

<ul>
<li>humans look over code, find flaws</li>
<li>code inspections, walk throughs</li>
<li>not on your assignments</li>
</ul>

<p>Machine testing</p>

<ul>
<li>run program on selected input, check against spec</li>
<li>can’t check everything <br>
<ul><li>choose test cases carefully</li></ul></li>
</ul>

<p>Black/White/Grey Box Testing</p>

<ul>
<li>no/full/some knowledge of implementation</li>
</ul>

<p>Start with black box, supplement with white box</p>

<p>Black box:</p>

<ul>
<li>various classes of input <br>
<ul><li>numeric ranges</li>
<li>positive vs. negative</li></ul></li>
<li>boundaries of valid ranges (edge cases)</li>
<li>multiple simultaneous boundaries (corner cases)</li>
<li>intuition/experience - guess at likely errors</li>
<li>extreme cases</li>
</ul>

<p>White box:</p>

<ul>
<li>execute all logical paths through the program</li>
<li>make sure every f’n runs</li>
</ul>

<p>Performance testing - is the program efficient enough? <br>
Regression testing</p>

<ul>
<li>make sure new changes to program don’t break old test caes</li>
<li>test suites, testing scripts</li>
</ul>



<h3 id="module-2-c">Module 2: C++</h3>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">//Hello world in C:</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Hello world in C++:</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hello world"</span> &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>Notes: main <strong>must</strong> return int in C++ (if no return in main, 0 is implied)</p>
</blockquote>

<ul>
<li><code>stdio.h</code> , <code>printf</code> still available in c++</li>
<li>preferred C++ <code>I/O</code> header <code>&lt;iostream&gt;</code></li>
</ul>

<p>Output: <br>
std::cout &lt;&lt; ___ &lt;&lt; ___ &lt;&lt; ___ (___ is data) <br>
std::endl = end of line</p>

<ul>
<li>using namespace std: <br>
<ul><li>lets you say cout/endl instead of std::cout/std::endl</li></ul></li>
</ul>



<h3 id="compiling-c-programs">Compiling C++ programs</h3>

<p><code>g++-5 -std=c++14 program.cc &lt;-o program&gt; (name of the excutable(by default, a.out))</code></p>

<p>OR</p>

<p><code>g++14 program.cc -o program</code> <br>
<code>./program</code></p>



<h3 id="inputoutput">Input/Output</h3>

<p>3 I/O streams: </p>

<ul>
<li>cin - for reading from stdin</li>
<li>cout, cerr - for printing to stdout, stderr</li>
</ul>

<p>I/O operators:</p>

<ul>
<li>&lt;&lt; “put to” (output)</li>
<li>&gt;&gt; “get from” (input)</li>
<li>cerr &lt;&lt; x;</li>
<li>cin &gt;&gt; x; <br>


<blockquote>
  <p>operator points in the direction of information flow</p></blockquote></li>
  </ul> <br>
  E.g. Add 2#’s







<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> nanospace <span class="hljs-built_in">std</span>
<span class="hljs-comment">//above two lines are usually there even if teach doesn't write it (omit from now on)</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;
    <span class="hljs-built_in">cout</span> &lt;&lt; x + y &lt;&lt; endl;
}</code></pre>




<blockquote>
  <p>notes: <code>cin &gt;&gt; ignores whitespace</code> <br>
  what if input doesn’t contain an int? -statement fails, value of var is undefined</p>
</blockquote>

What if the input is exhausted before we get two ints?

<ul>
<li>same as before</li>
</ul>

<hr>

<p>If the read failed: <code>cin.fail()</code> will be true <br>
If EOF: <code>cin.eof()</code> and <code>cin.fail()</code> will both be true</p>

<ul>
<li>but not until attempted read fails</li>
</ul>

<p>Ex: read all ints from stdin, echo them and per line to std out. Stop on any failure.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &gt;&gt; i;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.fail()) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: Here is an implicit conversion from cin to bool</p>
  
  <ul>
  <li>cin can be used as a condition - true if success, false if failed</li>
  </ul>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v2.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">cin</span> &lt;&lt; i;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cin</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>

<blockquote>
  <p>Note: &gt;&gt; is c’s right bitshift operator. <code>a &gt;&gt; b</code> shifts  a’s bits to the right by b spots. <br>
  E.g. 21 &gt;&gt; 3 -&gt; 21 = 10101 shifted 3 =<script type="math/tex" id="MathJax-Element-6">10_{\text(binary)}</script> = 2 <br>
  But when LHS is cin, &gt;&gt; is “get from”</p>
</blockquote>

<p>operator &gt;&gt;: </p>

<ul>
<li>inputs: cin (stream), data (variety of types)</li>
<li>output? - returns cin (istream)</li>
</ul>

<p>This is why we can write <code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</code> the &gt;&gt; returns cin as each &gt;&gt; is calculated, which allows y and z to also be read in.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v3.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//example v4.0</span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; i){
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>



<h2 id="lecture-5">Lecture 5</h2>

<p>Ex: Read ints + echo to stdout until EOF. Skip all non-int input</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span>&gt;&gt;i)){
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>.eof()) <span class="hljs-keyword">break</span>;
            <span class="hljs-built_in">cin</span>.clear(); <span class="hljs-comment">//clears the fail bit</span>
            <span class="hljs-built_in">cin</span>.ignore(); <span class="hljs-comment">//skips the next char (because the char causing this to fail is still there)</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt;i &lt;&lt; endl;
    }
}</code></pre>



<h3 id="reading-strings">Reading Strings</h3>

<p><code>type std::string (#include &lt;string&gt;)</code></p>

<ul>
<li>more details later</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s; <span class="hljs-comment">//skip leading whitespace (stop at whitespace)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">//(therefore only reads one word)</span>
}</code></pre>

<p>If we want the whitespace: <code>getline(cin, s);</code></p>

<ul>
<li>reads from current position to next newline into s.</li>
</ul>

<p><code>cout &lt;&lt; 95 &lt;&lt; endl;</code></p>

<p>What if we want to print a # in hexadecimal?</p>

<p><code>cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; endl; \\prints 5f</code></p>

<blockquote>
  <p>hex : I/O manipulator - all subsequent ints printed in hex</p>
</blockquote>

<p><code>cout &lt;&lt; dec</code> to go back to decimal</p>

<p>Other manipulators - notes <code>#include &lt;iomanip&gt;</code></p>

<p>Stream abstraction applies to other sources of data</p>

<p>Files </p>

<ul>
<li>Read from a file instead of stdin</li>
<li>std::ifstream - read from a file</li>
<li>std::ofstream - write to a file</li>
</ul>

<p>File access in C:</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">char</span> s[<span class="hljs-number">256</span>];
    FILE *file = fopen(<span class="hljs-string">"myfile.txt"</span>,<span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
        <span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">"%255s"</span>, s);
        <span class="hljs-keyword">if</span>(feof(file)) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    }
    fclose(file);
}</code></pre>

<p>C++:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(){
    ifstream file{<span class="hljs-string">"myfile.txt"</span>}; <span class="hljs-comment">// Initialization syntax. Declaring an ifstream opens the file</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(file &gt;&gt; s){
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
    } <span class="hljs-comment">// file is closed automatically as soon as the ifstream (file) goes out of scope :o woah</span>
}</code></pre>

<blockquote>
  <p>note: This is the same as reading from cin in c++ except we use file in the while loop.</p>
</blockquote>

<p>Anything you can do with cin/cout, you can also do with an ifstream/ofstream.</p>

<p>Example - strings - attach a stream to a string var + read from/write to it</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include&lt;sstream&gt;</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span>
<span class="hljs-comment">//-read from/write to a string</span>
<span class="hljs-keyword">int</span> lo = _____, hi = _____;
<span class="hljs-built_in">ostringstream</span> ss;
ss &lt;&lt; <span class="hljs-string">"Enter a # btwn "</span> &lt;&lt; lo &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; hi;
<span class="hljs-built_in">string</span> s = ss.str();</code></pre>

<p>Eg - convert string to #</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter a # "</span> &lt;&lt;endl;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">cin</span> &gt;&gt; s;
    (<span class="hljs-built_in">string</span> stream ss {s}); <span class="hljs-comment">// {s} &lt;- initialization</span>
    <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"I said, "</span>;
}
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"You entered "</span> &lt;&lt; n &lt;&lt; endl;</code></pre>

<p>Example revisited: Echo #’s, skip non-#’s</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; s){
        <span class="hljs-built_in">istringstream</span> ss {s};
        <span class="hljs-keyword">int</span> n;
        <span class="hljs-keyword">if</span>(ss &gt;&gt; n) <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
    }
}</code></pre>



<h3 id="strings">Strings</h3>

<p>In C: </p>

<ul>
<li>array of char (char* or char[]) terminated by ‘\0’</li>
<li>explicitly manage memory - allocate more as strings get larger</li>
<li>easy to overwrite \0 and corrupt memory</li>
</ul>

<p>C++ strings:</p>

<ul>
<li>grow as needed (no memory management)</li>
<li>safer to manipulate</li>
</ul>

<p>Eg: string s = “Hello”; // still a c-style string (char array with \0)</p>

<blockquote>
  <p>s  -  c++ string created from the c string on initialization</p>
</blockquote>



<h3 id="string-operations">String Operations:</h3>

<p>Equality - s1 == s2, s1 != s2 <br>
Comparison - s1 &lt;= s2 (lexicographic) <br>
Get individual chars - s[0] , s[1], … etc <br>
Concat: s3 = s1 + s2;   s3 += s4</p>



<h3 id="default-fn-params">Default f’n Params</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> printWordsInFile(<span class="hljs-built_in">string</span> name = <span class="hljs-string">"suite.txt"</span>){
    ifstream file {name};
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (file &gt;&gt; s) <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
}
printWordsInFile(<span class="hljs-string">"suite2.txt"</span>);
printWordsInFile(); <span class="hljs-comment">//uses stuite.txt</span></code></pre>

<blockquote>
  <p>Note: Optional parameters must be LAST</p>
</blockquote>



<h3 id="overloading">Overloading</h3>

<p>C:</p>

<ul>
<li><code>int negInt(int n) {return -n;}</code></li>
<li><code>bool negBool(bool b) {return !b;}</code></li>
</ul>

<p>C++</p>

<p>F’ns with different param lists can share the same name <br>
<code>int neg(int n) {return -n;}</code> <br>
<code>bool neg(bool b) {return !b;}</code></p>

<p>Compiler uses # + type of args to decide which neg is being called <br>
Overloads must differ in # or types of args - may not differ on just return type</p>



<h2 id="lecture-6">Lecture 6</h2>



<h3 id="structs">Structs</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node next; <span class="hljs-comment">//what's wrong? This makes the struct have no finite size since</span>
    <span class="hljs-comment">// this contains a node in a node in a node ... etc which has no calculable size</span>
};</code></pre>



<h3 id="constants">Constants</h3>

<p><code>const int maxGrade = 100; // must be initialized</code></p>

<p><code>Node n1 = {5, nullptr}; \\syntax for a null ptr. Do not say NULL or 0 in this class</code></p>

<p><code>const Node n2=n1</code></p>

<ul>
<li>immutable copy of n1</li>
<li>can’t change n2’s fields</li>
</ul>



<h3 id="parameter-passing">Parameter Passing</h3>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> n){++n;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 5</span></code></pre>

<p>call-by-value-inc gets a copy of x, increments the copy, original unchanged</p>

<p>If a function needs to modify an arg - pass a ptr</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> inc(<span class="hljs-keyword">int</span> *n){(*n)++;}
...
<span class="hljs-keyword">int</span> x=<span class="hljs-number">5</span>;
inc(&amp;x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//prints 6</span></code></pre>

<blockquote>
  <p>Q: why cin &gt;&gt; x and not cin &gt;&gt; &amp;x ? <br>
  A: C++ has another ptr-like type: references</p>
</blockquote>



<h3 id="references">References</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> &amp;z = y; <span class="hljs-comment">//z is an lvalue reference to y. Like a const ptr.</span>
<span class="hljs-comment">//similar to int *const z = &amp;y;</span></code></pre>

<p>References are like constant ptrs with automatic de-referencing  <br>
z -&gt; y [10]</p>



<pre class="prettyprint"><code class="language-cpp hljs ">z = <span class="hljs-number">12</span>; <span class="hljs-comment">//(NOT *z = 12)</span>
<span class="hljs-comment">//(now, y == 12)</span>

<span class="hljs-keyword">int</span> *p = &amp;z; <span class="hljs-comment">// gives the address of y</span></code></pre>

<p>In all cases, z behaves exactly like y.</p>

<p>z is an alias (“another name”) for y</p>

<p><strong>Things you can’t do with lvalue references:</strong></p>

<ol>
<li>Leave them uninitialized. eg int &amp;x; <br>
<ul><li>Must be initialized to something that has an address (an lvalue), since refs are ptrs: <code>int &amp;x = 3;</code> X , <code>int &amp;x = y + z;</code> X , <code>int &amp;x = y;</code> Is okay</li></ul></li>
<li>Create a ptr to a reference: <br>
<ul><li><code>int &amp;*x;</code>- for c, always start at var and then go left. So x is a pointer to a ref of an int.</li>
<li>ref to ptr OK: <code>int *&amp;x = ... ;</code></li></ul></li>
<li>Create a reference to a reference <br>
<ul><li><code>int &amp;&amp;x = ... ;</code> - this means something difference (we’ll talk about this later)</li></ul></li>
<li>Create an array of references: <code>int &amp;r[3] = {n,n,n};</code> X</li>
</ol>

<p>What <em>can</em> you do? pass as f’n params:</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> inc (<span class="hljs-keyword">int</span> &amp;n){++n;} <span class="hljs-comment">// notice that there's no ptr deref and &amp;n is a const. ptr to the arg.</span>
<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
inc(x);
<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 6</span></code></pre>

<blockquote>
  <p>So why does cin &gt;&gt; x work? - takes x by reference</p>
</blockquote>

<p><code>istream &amp; operator &gt;&gt; (istream &amp;in, int&amp;data)</code></p>

<p>Pass-by-value. eg: <code>int f(int n) { ... } copies the arguement</code></p>

<ul>
<li>if the arg is big, copying can be expensive <br>
eg: <code>struct Really Big { ... }</code>,</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(ReallyBig rb){ ... }; <span class="hljs-comment">// really slow</span>
<span class="hljs-keyword">int</span> g(ReallyBig &amp;rb){ ... }; <span class="hljs-comment">// &amp;rb is now an alias - fast. Downside is that rb can be changed by the f'n. You don't know.</span>
<span class="hljs-keyword">int</span> h(<span class="hljs-keyword">const</span> ReallyBig &amp;rb) { ... }; <span class="hljs-comment">// really fast and param can't be changed. woah</span></code></pre>

<p>Advice: prefer pass-by-const-ref over pass-by-value for anything larger than a ptr - unless the f’n needs to make a copy anyway. Then, maybe pass-by-value.</p>

<p>Also: <code>int f(int &amp;n) { ... }</code>      <code>int g(const int &amp;n) { ... }</code></p>



<pre class="prettyprint"><code class="language-cpp hljs ">f(<span class="hljs-number">5</span>); <span class="hljs-comment">// won't compile. can't initialize an lvalue ref (n) to a literal value. if n changes, can't change the literal 5.</span>
g(<span class="hljs-number">5</span>); <span class="hljs-comment">//is a-OK since n can never be changed. Compiler allows this. How? compiler creates a temp location to hold the 5, so the reference n has something to point to.</span></code></pre>



<h3 id="dynamic-memory-allocation">Dynamic Memory Allocation</h3>

<p>C: </p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>( ... *<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
...
<span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//DON'T USE THESE IN C++</span></code></pre>

<blockquote>
  <p>Instead: new/delete - type aware and less error-prone</p>
</blockquote>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> data;
    Node *next;
};

Node *np = <span class="hljs-keyword">new</span> Node;
...
<span class="hljs-keyword">delete</span> np;</code></pre>

<ul>
<li>all local vars reside on the stack - vars are deallocated when they go out of scope (stack is popped).</li>
<li>allocated memory resides on the heap.</li>
<li>remains allocated until delete is called</li>
<li>if you don’t delete all allocated memory - memory leak</li>
<li>program will eventually fail - incorrect behaviour</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">10</span>];
...
<span class="hljs-keyword">delete</span> [np];</code></pre>



<pre class="prettyprint"><code class=" hljs coffeescript">Node getMeANode(){ <span class="hljs-regexp">//</span><span class="hljs-keyword">return</span>-<span class="hljs-keyword">by</span>-value = copy. expensive?
    Node n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-regexp">//</span>-<span class="hljs-keyword">return</span> <span class="hljs-keyword">by</span> ptr(ret) instead?
Node *getMeANode(){
    Node n;
    <span class="hljs-keyword">return</span> &amp;n;
    <span class="hljs-regexp">//</span>BAD - returns a ptr to stack - allocated data which <span class="hljs-keyword">is</span> dead <span class="hljs-literal">on</span> <span class="hljs-keyword">return</span>
}

Node *getMeANode(){ <span class="hljs-regexp">//</span>Ok - returns a ptr to Heap data - still alive - but don<span class="hljs-string">'t forget to delete it!
    return new Node;
}</span></code></pre>



<h2 id="lecture-7">Lecture 7</h2>



<h3 id="operator-overloading">Operator Overloading</h3>

<p>Give meanings to c++ operators for our own types <br>
eg</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    Vec v={v1.x + v2.x , v1.y + v2.y};
    <span class="hljs-keyword">return</span> v;
}

Vec <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> {k*v.x, k*v.y} <span class="hljs-comment">//okay since compiler knows that it's a vec based on the return type</span>
}
<span class="hljs-comment">// this only works when scalar is on the left (eg. k*v). To get v*k, we need to make another function.</span>
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Vec &amp;v, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k){
    <span class="hljs-keyword">return</span> k*v;
}</code></pre>



<h3 id="overloading-and">Overloading &lt;&lt; and &gt;&gt;</h3>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Grade{
    <span class="hljs-keyword">int</span> theGrade;
};

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Grade &amp;g){
    out &lt;&lt; g.theGrade &lt;&lt; <span class="hljs-string">'%'</span>;
    <span class="hljs-keyword">return</span> out
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, Grade &amp;g){
    in &gt;&gt; g.theGrade;
    <span class="hljs-keyword">if</span>(g.theGrade &lt; <span class="hljs-number">0</span>) g.theGrade=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(g.theGrade&gt;<span class="hljs-number">100</span>) g.theGrade=<span class="hljs-number">100</span>;
    <span class="hljs-keyword">return</span> in;
}</code></pre>



<h3 id="the-preprocessor">The Preprocessor</h3>

<p>Transforms the program before the compiler sees it. #<script type="math/tex" id="MathJax-Element-7">\text{_____}</script> = preprocessor directive</p>

<p>eg.<code>#include</code> <br>
Including old C headers - new naming convention <br>
eg. Instead of <code>#include &lt;stdio.h&gt;, use #include&lt;cstdio&gt;</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define VAR VALUE <span class="hljs-comment">//- sets a preprocessor variable, then all occurrences of VAR in the source file are replaced with VALUE</span></span>
<span class="hljs-preprocessor">#define MAX 10</span>
<span class="hljs-keyword">int</span> x[MAX] <span class="hljs-comment">//transformed to int x[10]. Was a cheap way of const from the old days (1970s) before const was a thing</span>

<span class="hljs-preprocessor">#define FLAG <span class="hljs-comment">//sets the variable FLAG; Value is the empty string</span></span></code></pre>

<p>Defined constants are useful for conditional compilation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#define IOS 1</span>
<span class="hljs-preprocessor">#define BBOS 2</span>
<span class="hljs-preprocessor">#define OS IOS <span class="hljs-comment">//(or BBOS)</span></span>
<span class="hljs-preprocessor">#if OS==IOS</span>
    <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//Removed if OS!=IOS</span>
<span class="hljs-preprocessor">#elif OS==BBOS</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> publickey; <span class="hljs-comment">//this code is removed if OS!=BBOS</span>
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>Special Case</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#if 0 <span class="hljs-comment">//never true - all inner text is removed before it gets to the compiler</span></span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-comment">//heavy-duty "comment out"</span></code></pre>

<p>Can also define symbols via compiler arguments</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class="language-bash hljs ">g++<span class="hljs-number">14</span> -DX=<span class="hljs-number">15</span> define.cc -o define</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifdef NAME <span class="hljs-comment">//true if NAME has been defined</span></span>
<span class="hljs-preprocessor">#ifndef NAME <span class="hljs-comment">//true if NAME HAS NOT been defined</span></span>
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-preprocessor">#ifdef DEBUG</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"setting x=1"</span> &lt;&lt;endl;
    <span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(x&lt;<span class="hljs-number">10</span>){
        ++x;
        <span class="hljs-preprocessor">#ifdef DEBUG</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x is now"</span> &lt;&lt; endl;
        <span class="hljs-preprocessor">#endif</span>
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; endl;
}</code></pre>



<pre class="prettyprint"><code class=" hljs lua">gc++<span class="hljs-number">14</span> -DDEBUG <span class="hljs-built_in">debug</span>.cc -o <span class="hljs-built_in">debug</span>
//enables <span class="hljs-built_in">debug</span> output</code></pre>



<h3 id="separate-compilation">Separate Compilation</h3>

<p>Split program into composable modules, with</p>

<dl>
<dt>Interface</dt>
<dd>type definitions, prototypes for functions - .h file</dd>

<dt>Implementation</dt>
<dd>full definitions of functions - .cc file</dd>

<dt><em>Recall</em>: declaration</dt>
<dd>asserts existence</dd>

<dd>def’n - full details - allocates space (for vars/f’ns)</dd>
</dl>

<p>E.g. Interface (vec.h)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
}
Vec <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> main(){
    Vec v = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
    v = v+v;
    ...
}
<span class="hljs-comment">//implied vec.cc</span>

<span class="hljs-preprocessor">#include "vec.h" <span class="hljs-comment">//we include vec.h here because we don't know what a vec is.</span></span>
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
     ...
     ...
     ...
}</code></pre>

<blockquote>
  <p>Recall: an entity can be declared many times, but defined at most once</p>
</blockquote>



<h3 id="compiling-separately">Compiling Separately</h3>



<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">vec</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span>
<span class="hljs-comment">g</span><span class="hljs-literal">+</span><span class="hljs-literal">+</span><span class="hljs-comment">14</span> <span class="hljs-literal">-</span><span class="hljs-comment">c</span> <span class="hljs-comment">main</span><span class="hljs-string">.</span><span class="hljs-comment">cc</span></code></pre>

<blockquote>
  <p><code>-c</code> -&gt; means compile only, do not link, do not build the executable. Produces an object file.</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs avrasm">g++<span class="hljs-number">14</span> vec<span class="hljs-preprocessor">.o</span> main<span class="hljs-preprocessor">.o</span> -o main</code></pre>



<h1 id="never-ever-ever-compile-h-files-ever">NEVER, EVER EVER COMPILE .h FILES, EVER</h1>

<p>Global var: <code>int globalNum;</code></p>



<h2 id="lecture-8">Lecture 8</h2>

<p>vec.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
};
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> globalVar;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);</code></pre>

<p>vec.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
<span class="hljs-keyword">int</span> global Num;
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2){
    ...
}</code></pre>

<p>Let’s write a linear algebra module <br>
linalg.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>linalg.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>main.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "linalg.h"</span>
<span class="hljs-preprocessor">#include "vec.h"</span>
...</code></pre>

<p>The above won’t compile:</p>

<ul>
<li>main.cc, linalg.cc include linalg.h, vec.h, linalg.h includes vec,h</li>
<li>main.cc, linalg.cc get 2 copies of vec.h therefore struct vec defined twice. x</li>
</ul>

<blockquote>
  <p>Need to prevent files from being included twice</p>
</blockquote>

<p>Sol’n: “include guard:” <br>
vec.h </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#ifndef VEC_H</span>
<span class="hljs-preprocessor">#define VEC_H</span>
... file contents
<span class="hljs-preprocessor">#endif</span></code></pre>

<p>first time vec.h is included. Symbol VEC_H is not defined so file is included. After that, symbol is defined so vec.h is never included twice.</p>

<p>Always - put include guards in .h files <br>
Never - include .cc files - many many different functions. Included .cc file, you defined everything again and again and again.</p>

<p>Never - put using namespace std in header files. This directive would be forced on any client that includes this file <br>
- inside header files, always say std::cin, std::string etc.</p>



<h3 id="classes">Classes</h3>

<ul>
<li>can put functions inside of structs</li>
</ul>

<p>eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> assns*<span class="hljs-number">0.4</span> + mt*<span class="hljs-number">0.2</span> + final*<span class="hljs-number">0.4</span>;
    }
};
Student s{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; s.grade() &lt;&lt; endl;</code></pre>

<p>class </p>

<ul>
<li>a struct type that can contain f’ns</li>
<li>c++ has a class keyword - we will use it later</li>
</ul>

<p>object</p>

<ul>
<li>an instance of a class</li>
</ul>

<p>eg: <code>Student</code> - class, <code>s</code> - object, <code>{60, 70, 80}</code></p>

<p>The function grade - called a member function (or method) <br>
What doe assns, mt, final inside of grade ( ) {…} mean? <br>
- they are fields of the current object upon which grade was invoked</p>

<p>e.g. </p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>};
billy.grade(); \\method call uses billy<span class="hljs-string">'s assns, mt, final</span></code></pre>

<p>Formally: methods take a hidden extra parameter called this - ptr to the object on which the method was invoked. eg. billy.grade() &lt;- (this) == &amp;billy <br>
can write</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;assns *<span class="hljs-number">0.4</span> + <span class="hljs-keyword">this</span>-&gt;mt*<span class="hljs-number">0.2</span> + <span class="hljs-keyword">this</span>-&gt;final*<span class="hljs-number">0.4</span>;
    }
};</code></pre>

<p>Initializing Objects</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//ok, but limited</span></code></pre>

<p>Better: Write a method that does initialization: a constructor (ctor)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade(){...}
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final){
        <span class="hljs-keyword">this</span>-&gt;assns = assns;
        <span class="hljs-keyword">this</span>-&gt;mt = mt;
        <span class="hljs-keyword">this</span>-&gt;final = final;
    }
}

Student billy {<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>}; <span class="hljs-comment">//better. Even though this looks the same as above, this calls a ctor if it has been defined. IF no ctor has been defined, these initialize the individual fields of student.</span></code></pre>

<p>Head allocation:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student xpBilly = <span class="hljs-keyword">new</span> Student{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Advantages  of ctors: default params, overloading, sanity checks</p>

<p>eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    Student(in assns = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> mt=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> final=<span class="hljs-number">0</span>){
        <span class="hljs-keyword">this</span>.assns = assns;
        <span class="hljs-keyword">this</span>.mt = mt;
        <span class="hljs-keyword">this</span>.final =final;
    }
}</code></pre>

<blockquote>
  <p>Note: Every class comes with a default (ie no-arg) ctor (which just default constructs all fields that are objects). <br>
  eg.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec v; <span class="hljs-comment">//default ctor (does nothing in this case, the fields aren't objects)</span></code></pre>

<p>But the built-in default ctor goes away if you provide a ctor <br>
E.g.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y){
        <span class="hljs-keyword">this</span>-&gt;x=x;
        <span class="hljs-keyword">this</span>-&gt;y=y;
    }
}
Vec v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}; OK
Vec v; XXXX</code></pre>

<p>What if a struct contains consts or refs?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> MyStruct{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst; <span class="hljs-comment">//these two have to be initialized</span>
    <span class="hljs-keyword">int</span> &amp;myRef;
};

<span class="hljs-keyword">int</span> z;
<span class="hljs-keyword">struct</span> MyStuct {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst = <span class="hljs-number">5</span>; 
    <span class="hljs-keyword">int</span> &amp;myRef=z;
}; <span class="hljs-comment">//this is kind of bad since not every MyStruct wants the same val. Compiles, though</span></code></pre>

<p>But does every instance of student need the same value of myConst, etc?</p>

<p>Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//const (doesn't change) but not the same for all students.</span>
}</code></pre>

<p>Where do we initialize? ctor body? TOO LATE!</p>

<p>Where do we initialize? ctor body? - too late - fields must be fully constructed by then.</p>

<p>What happens when an object is created:</p>

<ol>
<li>space is allocated</li>
<li>fields are constructed //need to put our initializations here</li>
<li>ctor body runs</li>
</ol>

<p>How? - member initialization list (MIL)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">int</span> assns, mt, final;
    Student(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final):
        id{id}, assns{assns}, mt{mt}, final{final} {}
}</code></pre>

<blockquote>
  <p>Here: id - field, {id} - params <br>
  Note: can initialize any field this way, not just const + refs <br>
  Note: Fields initialized in the order in which they are declared in the class, even if the MIL orders them differently <br>
  Note: MIL sometimes more efficient than setting fields in the body. (o/w - run default ctor, then reassign in the body) EMBRACE THE MIL! ALL HAIL. PRAISE BE.</p>
</blockquote>

<p>what if a field is initialized inline AND in the MIL?</p>



<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">vec</span>(<span class="hljs-keyword">int</span> x); x{x} {}
};</code></pre>

<p>MIL takes precedence</p>



<h2 id="lecture-9">Lecture 9</h2>



<h3 id="uniform-initialization">Uniform Initialization</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> x(<span class="hljs-number">5</span>);
<span class="hljs-built_in">string</span> s = <span class="hljs-string">"hello"</span>;
<span class="hljs-built_in">string</span> s(<span class="hljs-string">"hello"</span>);
Student billy(<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>);
<span class="hljs-comment">//preferred (cs246 doesn't care which init you use though). This was updated as of a few years ago.</span>
<span class="hljs-keyword">int</span> x{<span class="hljs-number">5</span>};
<span class="hljs-built_in">string</span> s{<span class="hljs-string">"hello"</span>};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};</code></pre>

<p>Now consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student bobby = billy; <span class="hljs-comment">//-how does this init happen? the COPY CONSTRUCTOR. For constructing one object as a copy of another</span></code></pre>

<blockquote>
  <p>Note: Every class comes with:</p>
  
  <ul>
  <li>default ctor (default constructs all fields that are objects) <br>
  <ul><li>copy ctor (just copies all the fields)</li>
  <li>copy assignment operator</li>
  <li>destructor</li>
  <li>move ctor</li>
  <li>move assignment operator</li></ul></li>
  </ul>
</blockquote>

<p>Building your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns,mt,final;
    Student(...) {...}
    Student(<span class="hljs-keyword">const</span> Student &amp;other): assns {assns}, mt {mt}, final {final} {}
}; <span class="hljs-comment">//equiv. to built in</span></code></pre>

<p>When is the built-in copy ctor not correct?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next
    Node(<span class="hljs-keyword">int</span> data, Node *next): data {data}, next{next} {}
    ...
};
Node *n = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
Node m = *n;
Node *p =<span class="hljs-keyword">new</span> Node{*n};</code></pre>

<p><img src="http://amyqiu.me/Notes/pointer.png"> <br>
Simple copy of fields -&gt; only the first node is actually copied (<em>shallow copy</em>) <br>
If you want a <em>deep copy</em> (copies the whole list),  must write your own copy ctor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(<span class="hljs-keyword">const</span> Node &amp;other): data{other.data}, next{ other.next? <span class="hljs-keyword">new</span> Node (*other.next) : <span class="hljs-keyword">nullptr</span>}{}
} <span class="hljs-comment">//we have some sneaky recursion going on here. This recursively invokes the copy ctor + copies the rest of the list</span></code></pre>

<p>The copy ctor is called:</p>

<ol>
<li>When an object initializes another object</li>
<li>When an object is passed by value</li>
<li>When an object is returned by value (* - not always)</li>
</ol>

<blockquote>
  <p>Note: Careful with ctors that can take ONE parameter:</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};</code></pre>

<p>single-arg ctors create implicit conversions. <br>
Eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">4</span>};
<span class="hljs-comment">// - also I can call:</span>
Node n =<span class="hljs-number">4</span>; <span class="hljs-comment">//- implicit conversion from int to node.</span>
<span class="hljs-keyword">int</span> f(Node n){...}
f(<span class="hljs-number">4</span>); <span class="hljs-comment">//works -4 is implicitly converted to Node</span></code></pre>

<blockquote>
  <p>Danger - accidentally passing an int to a f’n expecting a Node. Compiler will not signal an error. <br>
  Good idea - disable the implicit conversion - make the ctor explicit</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data): data{data}, next{<span class="hljs-keyword">nullptr</span>}{}
};
Node n{<span class="hljs-number">4</span>}; <span class="hljs-comment">//ok</span>
Node n = <span class="hljs-number">4</span>; <span class="hljs-comment">//error</span></code></pre>



<h3 id="destructors">Destructors</h3>

<p>When an object is destroyed (stack-allocated: goes out of scope, heap-allocated: is deleted) a method called the destructor runs. Classes comes with a dtor (just calls dtor on all fields that are objects) <br>
When an object is destroyed:</p>

<ol>
<li>The dtor body runs</li>
<li>field’s dtors invoked in reverse declaration order</li>
<li>space deallocated</li>
</ol>

<p>When do we need to write one?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node *np = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span> <span class="hljs-keyword">new</span> Node {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};</code></pre>

<p>If np goes out of scope - the pointer is reclaimed (stack-allocated). The entire list is leaked. <br>
If we say <code>delete np;</code> then the 2 &amp; 3 nodes are leaked</p>

<p>Write a dtor to ensure the whole list is freed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;} <span class="hljs-comment">//&lt;- recursively calls next's dtor - frees the whole list.</span>
};</code></pre>

<p>Now - <code>delete np;</code> -frees the whole list</p>



<h3 id="copy-assignment-operator-the-one-everyone-gets-wrong-on-the-midterm-kekekek">Copy Assignment Operator - the one everyone gets wrong on the midterm kekekek</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane = billy; <span class="hljs-comment">//copy ctor</span>
Student mary; <span class="hljs-comment">//default ctor</span>
mary = billy; <span class="hljs-comment">//copy, but not construction. copy assignment operator is `=` - uses compiler-supplied default</span></code></pre>

<p>May need to write your own:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    <span class="hljs-comment">//So that cascading works your return itself. Eg. a=b=c=4; returns a = b = c; (c=4 now), a=b, (b=4 as well now), and then a=4;</span>
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        data=other.data;
        <span class="hljs-keyword">delete</span> next; <span class="hljs-comment">//the existing node might have other nodes so we need to delete those.</span>
        next=other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        <span class="hljs-comment">//THIS IS DANGEROUS</span>
    }
}</code></pre>

<p>Why?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Node {<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>}}};
n=n; <span class="hljs-comment">//deletes n + then tries to copy n to n. undefined behaviour</span>
*p = *q;
a[i] = a[j];</code></pre>

<p>When writing operator=, ALWAYS be wary of self-assignment:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        data = other.data;
        <span class="hljs-keyword">delete</span> next;
        next = other.next? <span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};</code></pre>

<p>Better:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp=next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data=other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }</code></pre>

<p>//if new fails, Node is still in a valid state.</p>



<h2 id="lecture-10">Lecture 10</h2>



<pre class="prettyprint"><code class="language-cpp hljs ">Node&amp; operators=(<span class="hljs-keyword">const</span> Node &amp;other){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp = next;
    next = other.next?<span class="hljs-keyword">new</span> Node{*other.next}:<span class="hljs-keyword">nullptr</span>;
    data = other.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>
}</code></pre>

<p>Alternative: copy + swap idiom &lt;3</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;utility&gt;</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">void</span> swap(Node &amp;other){
        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
        swap(data,other.data);
        swap(next, other.next);
    }
}

Node &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;other){
    Node tmp = other; <span class="hljs-comment">//tmp = copy of other</span>
    swap(tmp); <span class="hljs-comment">//me = copy of other. tmp = my old fields</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//my old data deleted when tmp goes out of scope</span>
}</code></pre>



<h3 id="rvalues-rvalue-references">Rvalues + Rvalue References</h3>

<blockquote>
  <p>Recall: - an lvalue is anything with an address. -an lvalue reference (&amp;) is like a const pointer with automatic dereferencing. -always initialized to a lvalue.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n{<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node m=n; <span class="hljs-comment">//copy ctor;</span>
Node m2;
m2=n; <span class="hljs-comment">//copy assignment operator</span>

Node plusOne(Node n){
    <span class="hljs-keyword">for</span>(Node *p=&amp;n;p;p=p-&gt;next){
        ++p-&gt;data;
    }
    <span class="hljs-keyword">return</span> n;
}
Node m3 = plusOne(n); <span class="hljs-comment">//copy ctor. What is "other" here? Reference to what?</span></code></pre>

<ul>
<li>Compiler creates a <code>temporary</code> object to hold the result of plusOne</li>
<li>Other is a reference to this temporary - copy ctor deep-copies data from this temporary. <br>
<em>But:</em> - the temporary is just going to be discarded anyway, as soon as the stmt <code>Node m3 = plusOne(n);</code> is done</li>
<li>wasteful to copy from the temp. Why not just steal it instead? - save the cost of a copy. <br>
-Need to be able to tell whether the other is a reference to a temporary or a standalone object <br>
C++ - rvalue reference -&gt; Node &amp;&amp; is a reference to a temporary object (rvalue) of type Node.</li>
</ul>

<p>Version of the ctor that takes Node &amp;&amp;.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    ...
    Node(Node &amp;&amp; other): <span class="hljs-comment">//called a move ctor</span>
    <span class="hljs-comment">// what should the move ctor do? Should steal other's data.</span>
        data{other.data},
        next{other.next} {
            other.next=<span class="hljs-keyword">nullptr</span>; <span class="hljs-comment">//else the list is destroyed when other is destroyed. This ctor is constant time.</span>
        }
}</code></pre>

<p>Similarly:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node m;
m=plusOne(n); <span class="hljs-comment">//Assignment from temporary</span>
<span class="hljs-comment">//More assignment operator:</span>
<span class="hljs-keyword">struct</span> Node{
    ...
    Node &amp;<span class="hljs-keyword">operator</span>=(Node &amp;&amp;other){
        swap(other); <span class="hljs-comment">//steal other's data</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//destroy my old data. swap without copy</span>
    }
}</code></pre>

<p>If you don’t define move ctor/assignment, the copy versions will be used. If the move ctor/assignment is defined, it will replace all calls to copy ctor/assignment when the argument is a temporary (rvalue).</p>



<h3 id="copymove-elision">Copy/Move Elision</h3>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec makeAVec(){
    <span class="hljs-keyword">return</span> {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}; <span class="hljs-comment">//invokes a basic ctor</span>
}
Vec v=makeAVec(); <span class="hljs-comment">//what runs? Not Sure! When compiled in g++, there's the basic ctor (no move/copy ctor).</span></code></pre>

<p>In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn’t have to) <br>
In this example: makeAVec writes it’s result ({0,0}) directly into the space occupied by v in the caller, rather than copy or move it later. <br>
Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> doSomething(vec v)<span class="hljs-comment">//&lt;- pass-by-value copy/move ctor</span>
{...}
doSomething(makeAVec()); <span class="hljs-comment">//-result of makeAVec is written directly into the parameter. There is no copy or move. This is allowed even if dropping ctor calls would change the behaviour of the program. eg. if the ctors print something.</span></code></pre>

<p>You are not expected to know exactly when move/copy elision is allowed, just that it is possible.</p>

<p>If you need all of the ctors to run: <code>g++14 -fno-elide-constructors</code> runs all constructors. But this can slow down your program considerably</p>

<p>In Summary: Rule of 5 (Big 5)</p>

<ul>
<li>If you need a custom version of any one of: <br>
<ul><li>copy ctor</li>
<li>copy assignment</li>
<li>dtor</li>
<li>move ctor</li>
<li>move assignment <br>
Then you usually need a custom version of all five. (The circumstances that require you to need one, usually require you to need all of them)</li></ul></li>
</ul>

<blockquote>
  <p>Notice: <br>
  <code>operator=</code> is a member function, not a standalone function <br>
  When an operator is a member, <code>this</code> is the first arguement</p>
  
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
  <span class="hljs-keyword">int</span> x,y;
  ...
  Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec&amp;other){
     <span class="hljs-keyword">return</span>{x+other.x, y+other.y};
  }
  Vec <span class="hljs-keyword">operator</span>*{<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k}{ <span class="hljs-comment">//implements v*k</span>
     <span class="hljs-keyword">return</span> {x*k, y*k};
  }
  <span class="hljs-comment">//How do we implement k*v? Can't be a member -first arg not Vec. -Write it as a standalone:</span>
}
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v){
  <span class="hljs-keyword">return</span> v*k;
}</code></pre>
</blockquote>

<p>I/O operators:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    ...
    ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out){
        <span class="hljs-keyword">return</span> out &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; y;
    }
};
<span class="hljs-comment">//what's wrong? Make Vec the first arg. -&gt; Use as vec&lt;&lt;cout;</span></code></pre>

<p>So define &lt;&lt;. &gt;&gt; as standalone fns.  <br>
Certain operators <strong>must</strong> be members:</p>

<ul>
<li>operator=</li>
<li>operator[]</li>
<li>operator()</li>
<li>operator T (where T is a type)</li>
</ul>



<h2 id="lecture-11">Lecture - 11</h2>



<h3 id="separate-compilation-for-classes">Separate Compilation for Classes</h3>

<p>Node.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor"># ...</span>
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    <span class="hljs-keyword">explicit</span> Node(<span class="hljs-keyword">int</span> data, Node*next=<span class="hljs-keyword">nullptr</span>);
    <span class="hljs-keyword">bool</span> hasNext();
};</code></pre>

<p>Node.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "node.h"</span>
Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next} {} <span class="hljs-comment">//compiler will yell at you for this. No return type and can't use init for f'ns.</span>
Node::Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next}{} <span class="hljs-comment">//tells compiler that it belongs to a class</span>

<span class="hljs-keyword">bool</span> hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;} <span class="hljs-comment">//will yell and say that you're using an undeclared variable</span>
<span class="hljs-keyword">bool</span> Node::hasNext(){<span class="hljs-keyword">return</span> next!=<span class="hljs-keyword">nullptr</span>;}<span class="hljs-comment">//better</span></code></pre>

<p><code>::</code> - scope resolution operator <br>
<code>Node:: ____</code> means <code>____</code> within class node <br>
<code>::</code> like <code>.</code> where LHS is a class or namespace, not an object</p>



<h3 id="arrays-of-objects">Arrays of Objects</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y): x{x}, y{y} {}
};
Vec *vp = <span class="hljs-keyword">new</span> Vec[<span class="hljs-number">5</span>]; <span class="hljs-comment">// X</span>
Vec moreVecs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// X</span>
<span class="hljs-comment">//there want to call the default ctor on each item. Can't init array elements - no default ctor.</span></code></pre>

<p>Options</p>

<ol>
<li>Provide a default ctor</li>
<li>For stack arrays: <br>
<code>Vec moreVecs[] = {{0,0}, {1,3}, {2,4}};</code></li>
<li>For heap arrays: -create an array of ptrs</li>
</ol>



<pre class="prettyprint"><code class="language-cpp hljs ">Vec **vp = <span class="hljs-keyword">new</span> Vec*[<span class="hljs-number">5</span>];
vp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> Vec {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
vp[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> Vec[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>;++i){
    <span class="hljs-keyword">delete</span> vp[i];
}
<span class="hljs-keyword">delete</span>[] vp;</code></pre>



<h3 id="const-objects">Const Objects</h3>

<p>Const objects arise often</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> f(<span class="hljs-keyword">const</span> Node &amp;n) {...}</code></pre>

<p>What is a const object? Can’t change fields <br>
Question: Can we call methods on a const object? <br>
<em>Issue:</em> <br>
The method may modify fields, violate const <br>
Answer: Yes - we can call methods that promise not to change fields</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>; <span class="hljs-comment">//this method will not change fields</span>
};</code></pre>

<p>Compiler checks that const methods don’t modify fields. Only const methods can be called on const objects.</p>

<p>Now consider: want to collect usage stats on student objects</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">int</span> numMethodCalls=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodcalls; <span class="hljs-comment">//method isn't const anymore. If you take const out, can't call grade on const students</span>
        <span class="hljs-keyword">return</span> ...
    }
};</code></pre>

<p>But mutating numMethodCalls affects only the <strong>physical constness</strong> of student objects, not the <strong>logical constness</strong></p>

<p>Want to be able to update numMethodCalls, even if the object is const - declare the field <code>mutable</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    <span class="hljs-keyword">float</span> grade() <span class="hljs-keyword">const</span>{
        ++numMethodCalls;
        <span class="hljs-keyword">return</span> ...;
    }
};</code></pre>

<p>mutable fields can be changed, even if the object is const.</p>



<h3 id="static-fields-methods">Static Fields + Methods</h3>

<p><code>numMethodCalls</code> tracked # of method calls for each particular Student <br>
What if we want to track method calls over all Students? <br>
Or what if we want to know how many Students were created? <br>
<strong>Static members</strong> - associated with the class itself, not with any specified instance (object).</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstances;
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final): assns{assns}, mt{mt}, final{final} {
        ++numInstances;
    }
};

<span class="hljs-keyword">int</span> Student::numInstances=<span class="hljs-number">0</span>; <span class="hljs-comment">//in .cc file</span></code></pre>

<p>static fields must be defined, external to the class</p>



<h3 id="static-member-functions">Static Member Functions</h3>

<ul>
<li>Don’t depend on a specific instance (no <code>this</code> param)</li>
<li>Can only access static fields + call other static methods</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Student{
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstance;
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> printNumInstances(){
        <span class="hljs-built_in">cout</span> &lt;&lt; numInstances &lt;&lt; endl;
    }
};
Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane{<span class="hljs-number">70</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>};
Student::printNumInstances(); <span class="hljs-comment">//2</span></code></pre>



<h3 id="invariants-encapsulation">Invariants + Encapsulation</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(<span class="hljs-keyword">int</span> data, Node*next);
    ...
    ~Node(){<span class="hljs-keyword">delete</span> next;}
};
Node n1 {<span class="hljs-number">1</span>, newNode {<span class="hljs-number">2</span>, <span class="hljs-keyword">nullptr</span>}};
Node n2 {<span class="hljs-number">3</span>, <span class="hljs-keyword">nullptr</span>};
Node n3 {<span class="hljs-number">4</span>, &amp;n2};</code></pre>

<p>What happens when these go out of scope?</p>

<ul>
<li>n1: dtor runs, whole list is deleted OK</li>
<li>n2, n3 go out of scope - n3’s dtor attempts to delete n2 but n2 is on the stack, not the heap! Undefined behaviour!</li>
</ul>

<p>Class Node relies on an assumption for its proper operation - next is either <code>nullptr</code> or allocated by <code>new</code>.</p>

<p>This is an <strong>invariant</strong> - statement that holds true, upon which Node relies. <br>
But we can’t guarantee this invariant - can’t trust the user to use Node properly.  <br>
Can’t enforce any invariants - user can interfere with our data.</p>

<blockquote>
  <p>Eg. - Stack : Invariant -&gt; last item pushed is first item popped. <br>
  but not if the client can rearrange the underlying data. </p>
</blockquote>

<p>Hard to reason about programs if you can’t rely on invariants. <br>
To enforce invariants - we introduce <code>encapsulation</code>  - we can’t clients to treat our objects as black boxes - capsules.</p>

<ul>
<li>implementation details sealed away</li>
<li>can only interact via provided methods</li>
<li>abstraction - regains control over our objects</li>
</ul>

<p>Eg</p>



<pre class="prettyprint"><code class="language-cpp hljs ">strut Vec{
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y); <span class="hljs-comment">//public by default</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">//can't be accessed outside the struct Vec.</span>
    <span class="hljs-keyword">public</span>:
        Vec <span class="hljs-keyword">operator</span>+(...);<span class="hljs-comment">//anyone can access</span>
        ...
};</code></pre>

<p>In general: want fields to be private - only methods should be public.  <br>
Better to have default visibility to be private. <br>
Switch from struct to class. <br>
THIS IS THE ONLY DIFFERENCE BETWEEN STRUCT AND CLASS -&gt; default visibility. Public in <code>struct</code>. Private in <code>class</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    Vec(<span class="hljs-keyword">int</span> x,y);
    Vec <span class="hljs-keyword">operator</span>+(...);
    ...
};</code></pre>



<h2 id="cs-246-tut-5">CS 246 TUT 5</h2>

<blockquote>
  <p>Summary: Rvalues &amp; Lvalues <br>
  Move Copy/Assignment <br>
  Rule of Five <br>
  Member Operators</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> value;
    Node *next;
};

Node add(Node n, <span class="hljs-keyword">int</span> inc){ <span class="hljs-comment">//copy ctor runs</span>
    <span class="hljs-keyword">for</span>(Node *m=&amp;n; m != <span class="hljs-keyword">nullptr</span>; m = m-&gt;next){
        m-&gt;value += inc;
    }
    <span class="hljs-keyword">return</span> n;
}

Node n1{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
Node n2 = add(n1,<span class="hljs-number">3</span>); <span class="hljs-comment">//move ctor</span>
n2 = add(n1, <span class="hljs-number">4</span>); <span class="hljs-comment">//move assign</span>

Node(Node &amp;&amp;other): <span class="hljs-comment">//impl of the move ctor</span>
value{other.value}, next{other.next} {
    other.next = <span class="hljs-keyword">nullptr</span>;
}</code></pre>

<p>Node &amp;operator=(Node &amp;&amp;other){ <br>
    swap(value, other.value); <br>
    swap(next, other.next); <br>
    return *this; <br>
}</p>

<p>lvalue -&gt; with address <br>
rvalue -&gt; without address</p>



<h2 id="lecture-12">Lecture 12</h2>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
        <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);
        Vec <span class="hljs-keyword">operator</span>+(...);
        ...
};</code></pre>

<p>Fix our linked list class: <br>
list.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node; <span class="hljs-comment">//private nested class. Only accessible within list.</span>
    Node *theList = <span class="hljs-keyword">nullptr</span>;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> addToFront(<span class="hljs-keyword">int</span> n);
        <span class="hljs-keyword">int</span> ith(<span class="hljs-keyword">int</span> n) <span class="hljs-keyword">const</span>;
        ~List(){<span class="hljs-keyword">delete</span> theList;}
};</code></pre>

<p>list.cc</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include "list.h"</span>
<span class="hljs-keyword">struct</span> List::Node{ <span class="hljs-comment">// Nested class</span>
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(...): ... {}
    ~Node() {<span class="hljs-keyword">delete</span> next;}
};

<span class="hljs-keyword">void</span> List::addToFront(<span class="hljs-keyword">int</span> n){
    theList = <span class="hljs-keyword">new</span> Node {n, theList};
}

<span class="hljs-keyword">int</span> List::ith(<span class="hljs-keyword">int</span> i)<span class="hljs-keyword">const</span>{
    Node *cur = theList;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n &lt; i &amp;&amp; cur; ++n; curr=cur-&gt;next);
    <span class="hljs-keyword">return</span> cur-&gt; data;
}</code></pre>

<p>Only List can create/manipulate Node objects <br>
<script type="math/tex" id="MathJax-Element-8">\therefore</script> Can guarantee the invariant that next is either nullptr or allocated by new.</p>

<p>pause</p>

<hr>

<p>But - Now we can’t traverse the list from front node to node, as would a linked list.  <br>
Repeatedly calling ith - <script type="math/tex" id="MathJax-Element-9">O(n^2)</script> time. <br>
But we can’t expose the nodes, or we lose encapsulation</p>



<h3 id="se-topic-design-patterns">SE Topic: Design Patterns</h3>

<ul>
<li>certain problems arise frequently</li>
<li>keep track of good solutions, use in similar situations</li>
</ul>

<dl>
<dt>Design Pattern</dt>
<dd>If you have problem X, solution Y will fix it.</dd>
</dl>

<blockquote>
  <p>Book Rec: Design Patterns (by the gang of four)</p>
</blockquote>

<hr>

<p>resume</p>

<p>Solution: Create a class that manages access to nodes <br>
- Create a class that manages access to nodes <br>
- abstraction of a ptr <br>
- walk the list without exposing the actual ptrs.</p>

<p>Inspiration:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *p=a; p! = a+n ; ++p){
    ... *p ...
}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    Node *theList;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">explicit</span> Iterator(Node *p):p{p}{}
                <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> p-&gt;data;} <span class="hljs-comment">// returns p-&gt;data ITSELF. allows the user to update it themselves. (eg. Iterator it ... ; *it = 7;)</span>
                Iterator &amp;<span class="hljs-keyword">operator</span>++(){p=p-&gt;next; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Iterator &amp;other){ <span class="hljs-keyword">return</span> p==other.p;}
                <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Iterator &amp;other){
                    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>==other);
                }
        };
        Iterator begin(){<span class="hljs-keyword">return</span> Iterator{theList};}
        Iterator end(){<span class="hljs-keyword">return</span> Iterator{<span class="hljs-keyword">nullptr</span>};}
        ...<span class="hljs-comment">//other methods like ith</span>
        ... 
};</code></pre>

<p>Client:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> main(){
    List l;
    l.addToFront(<span class="hljs-number">1</span>);
    l.addToFront(<span class="hljs-number">2</span>);
    l.addToFront(<span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span>(List::Iterator it=l.begin(); it!=l.end();++it){
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;endl;
    }
}</code></pre>

<blockquote>
  <p>Shortcut: automatic type deduction - <code>auto x = y;</code> . <code>auto</code> automatically gives x the same type as y.</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = l.begin(); it!=l.end(); ++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}</code></pre>

<blockquote>
  <p>Shorter cut: range-based for loop</p>
</blockquote>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:l){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}</code></pre>

<p>Available for any class with:</p>

<ul>
<li>methods begin + end that produces iterators</li>
<li>iterators must support !=, prefix ++, unary *</li>
</ul>

<p>If you want to modify the list items (or save copying):</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;n: l){
    ++n;
}</code></pre>

<p>Iterators shall return later.</p>

<p>Encapsulation ctd.</p>

<p>List  Client can create iterators directly :o</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> it = List::Iterator{<span class="hljs-keyword">nullptr</span>}; <span class="hljs-comment">//well, they only can make a nullptr iterator. But still. Bad form.</span></code></pre>

<ul>
<li>violate encapsulation - client should be using begin/end.</li>
</ul>

<p>We could make Iterator’s ctor private. Then client can’t call <code>List::Iterator(...)</code> . But then neither can List.</p>

<p>Solution: Give List privileged access to Iterator. Make it a <code>friend</code>.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">explicit</span> Iterator(Node *p); <span class="hljs-comment">//private</span>
            <span class="hljs-keyword">public</span>:
                ...
                <span class="hljs-keyword">friend</span> clas List; <span class="hljs-comment">// List has access to all members of Iterator.</span>
        };
    ...
};</code></pre>

<p>Now List can still create iterators, but client can only create them by calling <code>begin()</code> and <code>end()</code>.</p>

<p>Advice: give your classes as few friends as possible. weakens encapsulation. <br>
Once again: keep fields private. What if you want to give access to fields? use accessor + mutator methods.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> getX()<span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> x;} <span class="hljs-comment">//accessor</span>
        <span class="hljs-keyword">void</span> setY(<span class="hljs-keyword">int</span> newY){y=newY;} <span class="hljs-comment">//mutator</span>
};</code></pre>

<hr>

<p>what about operator &lt;&lt; - needs x+y, can’t be a member <br>
If no getX, getY - make operator &lt;&lt; a friend function</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v);
}

<span class="hljs-comment">//.cc</span>
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v){
    <span class="hljs-keyword">return</span> out &lt;&lt; v.x &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v.y;
}</code></pre>



<h3 id="tools-topic-make">Tools topic: make</h3>

<p>Separate compilation: <code>g++14 -c list.cc</code> , <code>g++14 -c node.cc</code>, <code>g++14 -c iter.cc</code>, <code>g++14 -c main.cc</code>, <code>g++14 list.o node.o iter.o main.o -o myprog</code> <br>
Why do we do this? So we don’t have to recompile files that haven’t changed.</p>

<p>How do you keep track of what’s changed? <br>
Let Linux help you - with make.</p>

<p>Create a Makefile that says which files depend on which other files. <br>
myprog: main.o list.o node.o iter.o //myprog depends on these <br>
[   ] (MUST be a TAB) g++-5 -std=c++14 main.o list.o node.o iter.o -o myprog (&lt;- how to rebuild)</p>



<h2 id="lecture-13">Lecture 13</h2>



<h3 id="makefile">Makefile</h3>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">myprog:</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>==++<span class="hljs-number">14</span> main<span class="hljs-preprocessor">.o</span> list<span class="hljs-preprocessor">.o</span> iter<span class="hljs-preprocessor">.o</span> node<span class="hljs-preprocessor">.o</span> -o myprog
<span class="hljs-label">list.o:</span> list<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span>
    g++-<span class="hljs-number">5</span> -<span class="hljs-keyword">std</span>=c++<span class="hljs-number">14</span> -c list<span class="hljs-preprocessor">.cc</span>
etc</code></pre>

<p>What does myprogram depend on? <br>
- Recursively build these, if necessary <br>
iter.cc changes: - now newer than iter.o (by last modified date). <script type="math/tex" id="MathJax-Element-10">\therefore</script> rebuilt iter.o <br>
- now iter.o newer than myprogram. <script type="math/tex" id="MathJax-Element-11">\therefore</script> rebuild myprogram <br>
- To do a full rebuild, make clean, make</p>

<p>Generalize with variables</p>



<pre class="prettyprint"><code class=" hljs lasso">CXX <span class="hljs-subst">=</span> g<span class="hljs-subst">++-</span><span class="hljs-number">5</span> <span class="hljs-comment">//compiler's name</span>
CXXFLAGS <span class="hljs-subst">=</span> <span class="hljs-attribute">-std</span><span class="hljs-subst">=</span>c<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-Wall</span> <span class="hljs-comment">//(Wall turns on warnings)</span></code></pre>

<p>eg. </p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> iter<span class="hljs-preprocessor">.h</span>
    ${CXX} ${CXXFLAGS} -c iter<span class="hljs-preprocessor">.cc</span></code></pre>

<p>Shortcut: for any rule of the form</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">x.o:</span> <span class="hljs-built_in">x</span><span class="hljs-preprocessor">.cc</span> a<span class="hljs-preprocessor">.h</span> b<span class="hljs-preprocessor">.h</span></code></pre>

<p>-can leave out the build command <br>
- make guesses that you want</p>



<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-variable">${CXX}</span> <span class="hljs-variable">${CXXFLAGS}</span> -c x.cc -o x.o</code></pre>

<p>Biggest problem with writing Makefiles <br>
-working out dependencies <br>
and maintaining them if they change.</p>

<p>Can get help from g++</p>



<pre class="prettyprint"><code class=" hljs lasso">g<span class="hljs-subst">++</span><span class="hljs-number">14</span> <span class="hljs-attribute">-MMD</span> <span class="hljs-attribute">-c</span> iter<span class="hljs-built_in">.</span>cc</code></pre>

<p>-creates iter.o and iter.d <br>
iter.d</p>



<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">iter.o:</span> iter<span class="hljs-preprocessor">.cc</span> list<span class="hljs-preprocessor">.h</span> node<span class="hljs-preprocessor">.h</span></code></pre>

<p>Now just include this in the Makefile</p>



<pre class="prettyprint"><code class=" hljs r">CXXFLAGS= -std=c++<span class="hljs-number">14</span> -Wall -MMD
<span class="hljs-keyword">...</span>
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS: .o=.d}
<span class="hljs-keyword">...</span></code></pre>

<p>-include ${DEPENDS}</p>



<h3 id="system-modelling">System Modelling</h3>

<p>building an 00 system: <br>
- identify abstractions <br>
- formalize relationships among them <br>
Helpful to map these out <br>
popular standard: UML (Unified Modelling Language) <br>
Modelling a Class</p>

<table>
<thead>
<tr>
  <th>Name</th>
  <th>Vec</th>
</tr>
</thead>
<tbody><tr>
  <td>Fields(optional)</td>
  <td>-x:Integer, -y:Integer</td>
</tr>
<tr>
  <td>Methods(optional)</td>
  <td>+getx: Integer, +getY:Integer</td>
</tr>
</tbody></table>


<p>Visibility: <code>-</code> -&gt; private, <code>+</code> -&gt; public <br>
Relationship: Composition of Classes</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Vec{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">public</span>:
        Vec(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);
};
<span class="hljs-comment">//Two vecs define a basis</span>
<span class="hljs-keyword">class</span> Basis{
    Vec v1,v2;
};
Basis b; <span class="hljs-comment">//XXX can't initialize v1, v2 - no default ctor for Vec.</span></code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Basis{
    Vec v1, v2;
    <span class="hljs-keyword">public</span>:
        Basis(): v1{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}, v2 {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>} {}
};</code></pre>

<p>Embedding one obj.(Vec) inside another (Basis) called <strong>Composition</strong> <br>
Relationship between Basis + Vec is called “owns-a” - A Basis “owns” the two Vec objects.</p>

<p>If A “owns-a” B then typically -</p>

<ul>
<li>B has no identity outside A (B is a part of A)</li>
<li>If A is destroyed, B is destroyed</li>
<li>If A is copied, B is copied (deep copy) <br>
E.g: A car owns y wheels - a wheel is a part of a car <br>
-destroy the car -&gt; destroy the wheels <br>
-copy the car -&gt; copy the wheels</li>
</ul>

<p>Implement: usually as composition of classes <br>
Modelling <br>
<img src="http://amyqiu.me/Notes/ownsa.png"> <br>
More details: links on course website</p>



<h3 id="aggegation">Aggegation</h3>

<p>Compare car parts in a car (“owns a”) vs car parts in a catalogue. <br>
The catalogue contains parts, but the parts exists on their own. “has-a” relationship (aggregation)</p>

<p>If A “has a” B, then typically</p>

<ul>
<li>B has an existence outside of its association with A</li>
<li>If A is destroyed, B lives on</li>
<li>If A is copied, B is not (shallow copies) <br>
<ul><li>copies of A share the same B</li></ul></li>
</ul>

<p>e.g.: Ducks in a pond <br>
<img src="http://amyqiu.me/Notes/hasa.png"> <br>
Typical Implementation</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Pond {
    Duck *ducks[maxDucks];
};</code></pre>



<h3 id="inheritance-specialization-generalization">Inheritance (Specialization/ Generalization)</h3>

<p>Suppose you want to track your collection of books</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    ...
};

<span class="hljs-keyword">class</span> Text{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> topic;
    ...
};

<span class="hljs-keyword">class</span> Comic{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-built_in">string</span> hero;
    ...
};</code></pre>

<p>-Doesn’t affress relationship among these classes. <br>
-How would we create an array or list containing a mixture of these? <br>
Observe that Texts + comics are KINDS of books. Books with extra features <br>
In c++ - inheritance</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{ <span class="hljs-comment">//Base class or superclass</span>
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        Book(...);
        ...
};

<span class="hljs-comment">//Derived classes or subclasses</span>
<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(...);
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> hero;
    <span class="hljs-keyword">public</span>:
        Comic(...);
};</code></pre>

<p>Derived classes inherit fields + methods from the base class. <br>
So Text, Comic have title author, numPages. <br>
Any method that can be called on Book can be called on Text, Comic. <br>
Who can see these members? <br>
title, author, numPages are private in Book. - outsiders can’t see them. <br>
Can Text, Comic see them? <br>
No. Even subclasses can’t see them!</p>

<p>How do we initialize Text?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
        Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): title{title}, author{author}, numPages{numPages}, topic{topic}{} <span class="hljs-comment">//WRONG. DOESN'T WORK HAHA</span>
};</code></pre>

<p>Wrong for 2 reasons:</p>

<ul>
<li>title, author, numPages not accessible in Text</li>
<li>when an object is created: <br>
<ol><li>space is allocated</li>
<li><strong>superclass part is constructed</strong> (in this case, Book doesn’t have a default ctor. Can’t do this)</li>
<li>fields are constructed</li>
<li>ctor body runs</li></ol></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p; <span class="hljs-comment">//read right to left. p is a constant pointer to an int.</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//p is a pointer to an int that is constant</span></code></pre>



<h2 id="lecture-14">Lecture 14</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
      Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> numPages, <span class="hljs-built_in">string</span> topic): Book {title, author, numPages}, topic{topic}{}
};</code></pre>

<p>If the superclass has no default ctor, the subclass MUST invoke a superclass ctor in its Member Initialization List.</p>

<p>If you want to give the subclass access to certain superclass members, use <strong>protected</strong> visibility.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-keyword">protected</span>:
      <span class="hljs-built_in">string</span> title, author;
      <span class="hljs-keyword">int</span> numPages;
      ...
};

<span class="hljs-keyword">class</span> Topic: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-keyword">public</span>:
      ...
      <span class="hljs-keyword">void</span> addAuthor(<span class="hljs-built_in">string</span> auth) {author+=auth;} <span class="hljs-comment">//ok since we protected author</span>
};</code></pre>

<p>Not a good idea to give subclasses unlimited access to fields. Breaks encapsulation and invariant. -&gt; eg. if you really don’t want Book to have the author Robert Munch, but you can’t guarantee that all subclasses will follow that rule and since they can change fields, breaks invariant.</p>

<p>Better: make fields private and provide protected access.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-built_in">string</span> getTitle() <span class="hljs-keyword">const</span>;
        <span class="hljs-keyword">void</span> setAuthor(<span class="hljs-built_in">string</span> auth);
        ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span>;
    ...
};</code></pre>

<p>Relationship among Text, Comic, Book is called “is-a” <br>
- a Text is a Book <br>
- a Comic is a Book <br>
- protected: #</p>

<p><img src="http://amyqiu.me/Notes/TextComic.png"></p>

<p>Method isItHeavy - when is a book heavy? <br>
- for ordinary Books - &gt; 200 pgs <br>
- for Text - &gt; 500 pages <br>
- for Comics - &gt; 30 pages</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">200</span>;}
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">30</span>;}
};

<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> numPages &gt; <span class="hljs-number">500</span>;}
};

Book b{<span class="hljs-string">"A small book"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">50</span>};
Comic c{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; b.isItHeavy() <span class="hljs-comment">//false</span>
     &lt;&lt; c.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>Since a Comic “is a” Book, we can do this:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{<span class="hljs-string">"A big comic"</span>, <span class="hljs-string">"..."</span>, <span class="hljs-number">40</span>};</code></pre>

<p>Q: Is b heavy? <br>
Which isItHeavy runs: Book::isItHeavy, or Comic:isItHeavy ? <br>
A: NO - b is not heavy. Book::isItHeavy runs. <br>
Why?</p>

<p><img src="http://amyqiu.me/Notes/ComcvsBook.png"></p>

<p>Since I’ve allocated only enough space for a Book and Comic is bigger, I must treat b as a book no matter what.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book b = Comic{...};
<span class="hljs-comment">//tries to fit a Comic object where there is only space for a Book object. What happens? - slicing occurs - c++ makes comic fit by chopping off bits. Hero field is chopped off so comic is coerced into a Book.</span></code></pre>

<p>So this converts the comic into a Book and Book::isItHeavy runs.</p>

<p>When accessing objects through ptrs, slicing is unnecessary and doesn’t happen.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Comic *pc = &amp;c;
<span class="hljs-built_in">cout</span> &lt;&lt;  pc -&gt; isItHeavy(); <span class="hljs-comment">//true</span>
     &lt;&lt; pb -&gt; isItHeavy(); <span class="hljs-comment">//not heavy</span></code></pre>

<p>still Book:isItHeavy runs when we access pb-&gt;isItHeavy(). <br>
Same object behaves differently, depending on what kind of ptr points at it. <br>
Compiler uses the type of the pointer (or reference) to determine which isItHeavy to run. - does not consider the actual type of the object <br>
Means a comic is only a comic when pointed at by a comic ptr -proabably not what we want.</p>

<p>How do we make comic act like a Comic, even when pointed at by a Book ptr? <br>
Declare the method <strong>virtual</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Book (...);
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> {...};
        ...
};

<span class="hljs-keyword">class</span> Comic: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Comic(...);
        <span class="hljs-keyword">bool</span> isItHeavy() <span class="hljs-keyword">const</span> override{...}
        ...
};

Comic c {...,...,<span class="hljs-number">40</span>,...};
Book *pb = &amp;c;
Book &amp;rb = c;
Comic *pc = &amp;;

<span class="hljs-built_in">cout</span> &lt;&lt; pc-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; pb-&gt;isItHeavy() <span class="hljs-comment">//true</span>
<span class="hljs-built_in">cout</span> &lt;&lt; rb.isItHeavy() <span class="hljs-comment">//true</span></code></pre>

<p>E.g. <br>
My Book Collection:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *myBooks[<span class="hljs-number">20</span>];
...
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span> ; ++i){
    <span class="hljs-built_in">cout</span> &lt;&lt; myBooks[i] -&gt;isItHeavy() &lt;&lt; endl; <span class="hljs-comment">// uses the right isItHeavy for corresponding types. :D</span>
}</code></pre>

<p>Accommadates multiple types under one abstraction <br>
-polymorphism (“many forms”)</p>

<hr>



<h3 id="destructor-revisited">Destructor Revisited</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    <span class="hljs-keyword">int</span> *x;
    <span class="hljs-keyword">public</span>:
        X(<span class="hljs-keyword">int</span> n): x{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]}{}
        ~X(){<span class="hljs-keyword">delete</span> [] x;}
};

<span class="hljs-keyword">class</span> Y: <span class="hljs-keyword">public</span> X{
    <span class="hljs-keyword">int</span> *y;
    <span class="hljs-keyword">public</span>:
        Y(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n): X{n}, y{<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m]}{}
        ~Y(){<span class="hljs-keyword">delete</span> [] y};
};</code></pre>

<p>You don’t have to delete X. X’s dtor will run after Y automatically since it’s the superclass.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">X *myX = <span class="hljs-keyword">new</span> Y{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>};
<span class="hljs-keyword">delete</span> myX; <span class="hljs-comment">//- leaks, why? X's dtor ran, but myX points to a Y. Y's dtor never runs here.</span></code></pre>

<p>So only x, but not y is freed. <br>
How can we ensure that deletion through superclass ptr will call subclass dtor? <br>
- declare the dtor virtual</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> X{
    ...
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">virtual</span> ~X(){
            <span class="hljs-keyword">delete</span> x;
        }
};</code></pre>

<p>ALWAYS - make the dtor virtual in classes that are meant to have subclasses <br>
-even if the dtor doesn’t do anything <br>
If a subclass is NOT meant to have subclasses, declare it <code>final</code>:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Y final: <span class="hljs-keyword">public</span> X{
    ...
};</code></pre>



<h2 id="lecture-15">Lecture 15</h2>



<h3 id="pure-virtual-methods-abstract-classes">Pure Virtual Methods + Abstract Classes</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Student{
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-keyword">int</span> numCourses;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> fees();
};</code></pre>

<p>2 Kinds of Student: Regular + Co-op</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Regular: <span class="hljs-keyword">public</span> Student{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> fees() override; <span class="hljs-comment">//reg student fees</span>
};

<span class="hljs-keyword">class</span> Coop: <span class="hljs-keyword">public</span> Student{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> fees() override; <span class="hljs-comment">//coop student fees</span>
};</code></pre>

<p>What should we put for Student fees? <br>
Not sure - every student should be regular or co-op</p>

<p>Can explicitly give NO implementation to Student::fees()</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Student{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> fees()=<span class="hljs-number">0</span>; <span class="hljs-comment">//this syntactically tells that this method has no implementation(***). no, 1,2,3 ... etc doesn't work. Called a pure virtual method</span>
}</code></pre>

<p>A class with pure virtual methods cannot be instantiated.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Student s; X</code></pre>

<p>-called an <code>abstract class</code> <br>
Purpose of an abstract class is to organize subclasses.</p>

<p>Subclasses of an abstract class are also abstract unless they implement the pure virtual methods. <br>
If a class is not abstract, then it is <strong>concrete</strong></p>

<dl>
<dt>UML</dt>
<dd>Virtual + pure methods: italics <br>
Abstract classes: class name in italics <br>
Static - underline</dd>
</dl>



<h3 id="templates">Templates</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    Node *theList;
    ...
}
<span class="hljs-keyword">struct</span> List::Node{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    ...
}</code></pre>

<p>What if you want to store something else? <br>
Whole new class? <br>
OR a <strong>template</strong> : A class parameterized by a <strong>type</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> Stack{
    <span class="hljs-keyword">int</span> size;
    <span class="hljs-keyword">int</span> cap;
    T *contents;
    <span class="hljs-keyword">public</span>:
        Stack(){...}
        <span class="hljs-keyword">void</span> push(T x){...}
        T top(){...}
        <span class="hljs-keyword">void</span> pop(){...}
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node{
        T data;
        Node *next;
    };
    Node *theList;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator{
            Node *p;
            <span class="hljs-keyword">explicit</span> Iterator(Node *p):p{p}{}
            <span class="hljs-keyword">public</span>:
                T &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> p-&gt;data;}
                ...
        };
        ...
        T ith(<span class="hljs-keyword">int</span> i){...};
        <span class="hljs-keyword">void</span> addToFront(T n){...}
};
<span class="hljs-comment">//Client:</span>
List &lt;<span class="hljs-keyword">int</span>&gt; l1;
List&lt;List&lt;<span class="hljs-keyword">int</span>&gt;&gt; l2;
l1.addToFront(<span class="hljs-number">3</span>);
l2.addToFront(l1);

<span class="hljs-keyword">for</span>(List&lt;<span class="hljs-keyword">int</span>&gt;::Iterator it=l1.begin();it!=l1.end();++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}</code></pre>

<p>or indeed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:l1){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}</code></pre>



<h3 id="the-standard-template-library-stl">The Standard Template Library (STL)</h3>

<p>Large # of useful templates: <br>
Eg: dynamic-length arrays : <strong>vectors</strong></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include&lt;vector&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">4</span>,<span class="hljs-number">5</span>}; <span class="hljs-comment">// [4, 5]</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;</span> v1(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// [5, 5, 5, 5]</span>
<span class="hljs-comment">//oh no!</span>

v.emplace-back(<span class="hljs-number">6</span>);
vemplace.back(<span class="hljs-number">7</span>); <span class="hljs-comment">//4,5,6,7</span></code></pre>

<p>Looping:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v.size();++i){
    <span class="hljs-built_in">cout</span> &lt;&lt;v[i]&lt;&lt;endl;
}

<span class="hljs-comment">//CAN REPLACE vector&lt;int&gt;::reverse.iterator WITH AUTO FOR ALL OCCURRENCES</span>
<span class="hljs-keyword">for</span>(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator it=v.begin();it!=v.end();++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;endl;
}
<span class="hljs-comment">//OR</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:v){
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;
}

<span class="hljs-comment">//To iterate in revers:</span>
<span class="hljs-keyword">for</span>(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::reverse.iterator it=v.rbegin(); it!=v.rend(); ++it){
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; endl;
}
v.pop.back() <span class="hljs-comment">//remove last element</span></code></pre>

<p>use iterators to remove from inside a vector</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> it = v.erase(v.begin()); <span class="hljs-comment">//erases the first element</span>
<span class="hljs-keyword">auto</span> it = v.erase(v.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//erases item 3</span>
<span class="hljs-keyword">auto</span> it = v.erase(it); <span class="hljs-comment">//erases item pointed at by it. returns an iterator to item past the item just removed.</span>
<span class="hljs-keyword">auto</span> it = v.erase(v.end()-<span class="hljs-number">1</span>);
v[i] <span class="hljs-comment">//- returns ith element of v; it's unchecked so if you go out of bounds.</span>
<span class="hljs-comment">// it's undefined behaviour. </span>
v.at(i) <span class="hljs-comment">//- checked version of v[i] . What happens when you go out of bounds?</span></code></pre>

<p>What should happen?</p>

<dl>
<dt>Problem</dt>
<dd>Vector’s code can detect the error, but doesn’t know what to do about it. <br>
Client can respond, but can’t detect the error.</dd>

<dt>C solution</dt>
<dd>functions return a status code, or set the global variable errno <br>
Leads to awkward programming. Lots of if statements <br>
Encourages programming to ignore error checks</dd>

<dt>C++</dt>
<dd>When an arror condition arises, the function raises an exception <br>
What happens? By default, execution stops</dd>
</dl>

<p>But we can write handlers to catch ex’ns + deal with them. <br>
<code>vector&lt;T&gt;::at</code> raises the exn <code>std::out_of_range</code> when it fails <br>
We can handle it as follows:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;stdexcept&gt;</span>
...
<span class="hljs-keyword">try</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; v.at(<span class="hljs-number">1000</span>) &lt;&lt;endl; <span class="hljs-comment">//out of range</span>
}
<span class="hljs-keyword">catch</span>(out_of_range r){
    <span class="hljs-built_in">cerr</span> &lt;&lt;<span class="hljs-string">"Range error "</span> &lt;&lt; r.what() &lt;&lt;endl;
}</code></pre>

<p>From midterm</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> y{x};
y+x;
<span class="hljs-built_in">cin</span> &lt;&lt; x;
<span class="hljs-comment">//here, {x}, {x, x}, {x, y}, {cin, x, cin&lt;&lt;x} are lvalues.</span>
<span class="hljs-comment">// y+x is rvalue;</span></code></pre>



<h2 id="lecture-16">Lecture 16</h2>

<p>Now consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-keyword">throw</span> out_of_range{<span class="hljs-string">"f"</span>}; <span class="hljs-comment">//raise an exception. "f" is displayed in .what()</span>
}

<span class="hljs-keyword">void</span> g() {f();}
<span class="hljs-keyword">void</span> h() {g();}
<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">try</span>{
        h();
    }
    <span class="hljs-keyword">catch</span> (out_of_range r){...}
}</code></pre>

<dl>
<dt>What happens:</dt>
<dd>main calls h <br>
h calls g <br>
g calls f <br>
f throws out_of_range <br>
g has no handler for out_of_range <br>
- control goes back through the call chain (unwinds the stack) until a handler is found <br>
- control goes all the way back to main and main handles the exception <br>
- if no handler in the entire call chain, program terminates</dd>
</dl>

<p>What is out_of_range? - A class.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">throw</span> out_of_range{<span class="hljs-string">"f"</span>} <span class="hljs-comment">//ctor call, create an out_of_range object and throw it</span></code></pre>

<p>A handler can do part of the recovery job - execute some corrective code + raise another exn:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">try</span>{...}
<span class="hljs-keyword">catch</span>(SomeErrorType s){
    ...
    <span class="hljs-keyword">throw</span> SomeOtherError{<span class="hljs-string">"..."</span>};
}</code></pre>

<p>or throw the same ex’n</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">try</span>{...}
<span class="hljs-keyword">catch</span>(SomeErrorType s){
    ...
    <span class="hljs-keyword">throw</span>;
}</code></pre>

<p><code>throw;</code> vs <code>throw s;</code></p>

<p><strong>throw s;</strong> <br>
Throw s; -&gt; s may be a subtype of SomeErrorType. throws a new exn of type SomeErrorType</p>



<div class="flow-chart"><svg height="133" version="1.1" width="141.046875" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="overflow: hidden; position: relative; top: -0.109375px;"><desc style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">Created with Raphaël 2.1.2</desc><defs style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path><marker id="raphael-marker-endblock33-obj4" markerHeight="3" markerWidth="3" orient="auto" refX="1.5" refY="1.5" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#raphael-marker-block" transform="rotate(180 1.5 1.5) scale(0.6,0.6)" stroke-width="1.6667" fill="black" stroke="none" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></use></marker></defs><rect x="0" y="0" width="135.046875" height="36.5" rx="20" ry="20" fill="#ffffff" stroke="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" stroke-width="2" class="flowchart" id="e" transform="matrix(1,0,0,1,4,4)"></rect><text x="10" y="18.25" text-anchor="start" font-family="sans-serif" font-size="14px" stroke="none" fill="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); text-anchor: start; font-family: sans-serif; font-size: 14px; font-weight: normal;" id="et" class="flowchartt" font-weight="normal" transform="matrix(1,0,0,1,4,4)"><tspan style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" dy="5.25">SpecialErrorType</tspan></text><rect x="0" y="0" width="125.03125" height="36.5" rx="20" ry="20" fill="#ffffff" stroke="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" stroke-width="2" class="flowchart" id="st" transform="matrix(1,0,0,1,9.0078,94.5)"></rect><text x="10" y="18.25" text-anchor="start" font-family="sans-serif" font-size="14px" stroke="none" fill="#000000" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); text-anchor: start; font-family: sans-serif; font-size: 14px; font-weight: normal;" id="stt" class="flowchartt" font-weight="normal" transform="matrix(1,0,0,1,9.0078,94.5)"><tspan style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" dy="5.25">SomeErrorType</tspan></text><path fill="none" stroke="#000000" d="M71.5234375,40.5C71.5234375,40.5,71.5234375,80.15409994125366,71.5234375,91.50043908460066" stroke-width="2" marker-end="url(#raphael-marker-endblock33-obj4)" font-family="sans-serif" font-weight="normal" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); font-family: sans-serif; font-weight: normal;"></path></svg></div>

<p><strong>throw;</strong> <br>
actual type of s is retained</p>

<p>A handler can act as a catch-all:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">try</span>{...}
<span class="hljs-keyword">catch</span>(...){ <span class="hljs-comment">//here, we LITERALLY PUT "..." to catch ALL exceptions</span>
    ...
}</code></pre>

<p>You can throw anything you want - don’t have to throw objects</p>

<p>Define your own exception classes (or use appropriate existing ones) for your errors:</p>

<p>eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> BadInput{};
<span class="hljs-keyword">try</span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">cin</span> &gt;&gt; n)) <span class="hljs-keyword">throw</span> BadInput{};
}
<span class="hljs-keyword">catch</span>(BadInput &amp;s){ <span class="hljs-comment">//in general: catch by reference</span>
    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"input not well-formed"</span> &lt;&lt;endl;
}</code></pre>

<dl>
<dt>Some standard exceptions</dt>
<dd>length_error : attempt to resize strings/vectors that are too long</dd>

<dd>bad_alloc : new fails</dd>
</dl>

<p>Much more on exns later</p>



<h3 id="design-patterns-ctd">Design Patterns Ct’d</h3>

<p>Guiding Principle: Program to the interface, not the implementation</p>

<ul>
<li>abstract base class to define the interface.</li>
<li>work with pointers or references to abstract base classes + call their methods.</li>
<li>concrete subclasses can be swapped in and out</li>
<li>abstraction over a variety of behaviours</li>
</ul>

<p>eg. Iterator Pattern</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> AbstractIterator{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp;<span class="hljs-keyword">operator</span>*()=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> AbstractIterator &amp;<span class="hljs-keyword">operator</span>++()=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> AbstractIterator &amp;other)=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> ~AbstractIterator();
};

<span class="hljs-keyword">class</span> List{
    <span class="hljs-keyword">struct</span> Node;
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator: <span class="hljs-keyword">public</span> AbstractIterator{
            ...
        };
    ...
};

<span class="hljs-keyword">class</span> Set{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">class</span> Iterator: <span class="hljs-keyword">public</span> AbstractIterator{
            ...
        };
    ...
};</code></pre>

<p>Then you can write code that operates over Iterators:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> foreach(AbstractIterator start, AbstractIterator end, <span class="hljs-keyword">void</span>(*f)(<span class="hljs-keyword">int</span>)){
    <span class="hljs-keyword">while</span>(start!=end){
        f(*start);
        ++start;
    } <span class="hljs-comment">//-works over Lists and Sets.</span>
}</code></pre>



<h3 id="observer-pattern">Observer Pattern</h3>

<dl>
<dt>Publish -subscribe mode 1.</dt>
<dd>One class: publisher/subject - generates data</dd>

<dd>One or more subscriber/observer classes - receive data and react to it</dd>
</dl>

<p>Eg: Publisher = spreadsheet cells. Observers = graphs. When cells change, graphs update.</p>

<p>Can have many different observer objects. <br>
- subject should not need to know all the details.</p>

<p>Observer pattern: <br>
<img src="http://amyqiu.me/Notes/observerpattern.png"></p>

<p>Sequence of method calls:</p>

<ol>
<li>Subject’s state is updated</li>
<li>Subject::notifyObservers() -calls each observer’s notify</li>
<li>Each observer calls ConcretSubject::getState tp query the state and react accordingly.</li>
</ol>

<p>Example: Horse races <br>
Subject - publishes winners <br>
Observers - individual bettors </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Subject{
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Observer *&gt;</span> observers;
    <span class="hljs-keyword">public</span>:
        Subject();
        <span class="hljs-keyword">bool</span> attach(Observer *o){observers.emplace.back(o);}
        <span class="hljs-keyword">void</span> detach(Observer *o){observers.remove(o);}
        <span class="hljs-keyword">void</span> notifyObservers(){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ob:observers) ob-&gt;notify();
        }
        <span class="hljs-keyword">virtual</span> ~Subject()=<span class="hljs-number">0</span>;
};
<span class="hljs-comment">//IMPORTANT</span>
Subject::~Subject(){}
<span class="hljs-comment">/*
virtual destructor must ALWAYS be implemented, even if it is pure virtual.
*/</span></code></pre>



<h2 id="lecture-17">Lecture 17</h2>

<p><img src="http://amyqiu.me/Notes/a1.png"></p>

<p>From last class</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Subject{
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Observer *&gt;</span> observers;
    <span class="hljs-keyword">public</span>:
        Subject();
        <span class="hljs-keyword">bool</span> attach(Observer *o){observers.emplace.back(o);}
        <span class="hljs-keyword">void</span> detach(Observer *o){observers.remove(o);}
        <span class="hljs-keyword">void</span> notifyObservers(){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ob:observers) ob-&gt;notify();
        }
        <span class="hljs-keyword">virtual</span> ~Subject()=<span class="hljs-number">0</span>;
};
Subject::~Subject(){}</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Observer{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> notify()=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> ~Observer();
};

Observer::~Observer(){}

<span class="hljs-keyword">class</span> Horserace: <span class="hljs-keyword">public</span> Subject{
    ifstream in; <span class="hljs-comment">//source of data</span>
    <span class="hljs-built_in">string</span> lastwinner;
    <span class="hljs-keyword">public</span>:
        HorseRace(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;source): in{source}{}
        <span class="hljs-keyword">bool</span> runRace(); <span class="hljs-comment">//set lastwinner. Returns false if no winners left</span>
        <span class="hljs-built_in">string</span> getState() {<span class="hljs-keyword">return</span> lastwinner;}
};

<span class="hljs-keyword">class</span> Bettor: <span class="hljs-keyword">public</span> Observer{
    HorseRace *subject;
    <span class="hljs-built_in">string</span> name, myHorse;
    <span class="hljs-keyword">public</span>:
        Bettor(...)...{
            subject-&gt;attach(<span class="hljs-keyword">this</span>);
        }
        ~Bettor(){subject-&gt;detach(<span class="hljs-keyword">this</span>);}
        <span class="hljs-keyword">void</span> notify(){
            <span class="hljs-built_in">string</span> winner = subject-&gt;getState();
            <span class="hljs-keyword">if</span>(winner == myHorse){
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Yay!"</span> &lt;&lt; endl;
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Double or nothing"</span> &lt;&lt; endl;
            }
        }
};
<span class="hljs-comment">//main.cc</span>

HorseRace hr;
Bettor Larry(&amp;hr, <span class="hljs-string">"Larry"</span>, <span class="hljs-string">"RunsLikeACow"</span>);
...
<span class="hljs-keyword">while</span>(hr.runRace()){
    hr.notifyObservers();
}</code></pre>



<h3 id="decorator-pattern">Decorator Pattern</h3>

<p>Want to enhance an object at run-time-add functionality/features <br>
E.g. Windowing system: -start with a basic window. -add scrollbar. -add menu. <br>
Want to choose these enhancements at runtime. <br>
<img src="http://amyqiu.me/Notes/a2.png"></p>

<dl>
<dt>Class Component</dt>
<dd>defines the interface</dd>

<dd>operations your objects will provide</dd>

<dt>Concrete Component</dt>
<dd>implements the interface</dd>

<dt>Decorators</dt>
<dd>all inherit from Decorator, which inherits from component</dd>
</dl>

<p>Therefore, Every Decorator IS a component, AND every Decorator HAS a component</p>

<p>E.g. Window with scrollbar is a kind of window, and has a pointer to the underlying plain window</p>

<p>Window with scrollbar + menu IS a window, has a ptr to window w/ scrollbar, which has a ptr to a plain window.</p>

<p>All inherit from Abstract Window class, so window methods can be used polymorphically on all of them.</p>

<p>E.g Pizza <br>
<img src="http://amyqiu.me/Notes/a3.png"></p>

<p>Basic Pizza is crust and sauce</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Pizza{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> price()<span class="hljs-keyword">const</span>=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> desc()<span class="hljs-keyword">const</span>=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">virtual</span>~Pizza();
};

<span class="hljs-keyword">class</span> CrustAndSauce:<span class="hljs-keyword">public</span> Pizza{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">float</span> price() <span class="hljs-keyword">const</span> override{<span class="hljs-keyword">return</span> <span class="hljs-number">5.99</span>;}
        <span class="hljs-built_in">string</span> desc() <span class="hljs-keyword">const</span> override{<span class="hljs-keyword">return</span> <span class="hljs-string">"Pizza"</span>;}
};

<span class="hljs-keyword">class</span> Decorator: <span class="hljs-keyword">public</span> Pizza{
    <span class="hljs-keyword">protected</span>:
        Pizza *component;
    <span class="hljs-keyword">public</span>:
        Decorator(Pizza *p): component{p}{}
        <span class="hljs-keyword">virtual</span> ~Decorator{<span class="hljs-keyword">delete</span> component;} <span class="hljs-comment">//what happens in delete component here is the whole pizza is thrown away. Uh, this is the choice we made to keep things simple</span>
};

<span class="hljs-keyword">class</span> StuffedCrust: <span class="hljs-keyword">public</span> Decorator{
    <span class="hljs-keyword">public</span>:
        StuffedCrust(Pizza *p): Decorator {p}{}
        <span class="hljs-keyword">float</span> price() <span class="hljs-keyword">const</span> override{
            <span class="hljs-keyword">return</span> component-&gt;price() + <span class="hljs-number">2.69</span>;
        }
        <span class="hljs-built_in">string</span> desc() <span class="hljs-keyword">const</span> override{
            <span class="hljs-keyword">return</span> component-&gt;desc() + <span class="hljs-string">" with stuffed crust"</span>;
        }
};</code></pre>

<p>Use:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Pizza *p1= <span class="hljs-keyword">new</span> CrustAndSauce;
p1 = <span class="hljs-keyword">new</span> Topping (<span class="hljs-string">"Cheese"</span>, p1);
p1 = <span class="hljs-keyword">new</span> Topping(<span class="hljs-string">"Jelly Beans"</span>, p1);
p1 = <span class="hljs-keyword">new</span> StuffedCrust(p1);
<span class="hljs-built_in">cout</span> &lt;&lt; p1-&gt;desc() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; p1-&gt;price();
<span class="hljs-keyword">delete</span> p1;</code></pre>



<h3 id="inheritance-and-copymove">Inheritance and Copy/Move</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-comment">//Defines copy/move ctor, copy/move operator=</span>
};
<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">//does not define copy/move operations</span>
};
Text t{<span class="hljs-string">"Algorithms"</span>, <span class="hljs-string">"CLRS"</span>, <span class="hljs-string">"500"</span>, <span class="hljs-string">"CS"</span>};
Text t2=t; <span class="hljs-comment">//No copy ctor in Text - what happens?</span></code></pre>

<p>-calls Book’s copy ctor <br>
-then goes field-by-field (ie default behaviour) for Text part <br>
-same for other operations</p>

<p>To write your own operations:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Text::Text(<span class="hljs-keyword">const</span> Text &amp;other): Book{other},topic{other.topic}{}
Text &amp;Text::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Text &amp;other){
    Book::<span class="hljs-keyword">operator</span>=(&amp;other);
    topic=other.topic;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">//other points at an rvalue, but IS ITSELF an lvalue</span>
Text::Text(Text &amp;&amp;other):Book{other}, topic{other.topic}{}
<span class="hljs-comment">//HERE, Book{other} is a copy ctor because other is an lvalue. It exists and has a name within this function</span>

<span class="hljs-comment">//Better but still not correct: move treats other as an rvalue.</span>
Text::Text(Text &amp;&amp;other):Book{<span class="hljs-built_in">std</span>::move(other)}, topic{other.topic}{}
<span class="hljs-comment">//HERE, other.topic is ALSO an lvalue.</span>

<span class="hljs-comment">//Final:</span>
Text::Text(Text &amp;&amp;other):Book{<span class="hljs-built_in">std</span>::move(other)}, topic{<span class="hljs-built_in">std</span>::move(other.topic)}{}

Text&amp;Text::<span class="hljs-keyword">operator</span>=(Text &amp;&amp;other){
    Book::<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::move(other));
    topic=<span class="hljs-built_in">std</span>::move(other.topic);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre>

<blockquote>
  <p>Note: Even though other “points” at an rvalue, other itself is an lvalue (so is other.topic). <br>
  std::move(x) forces an lvalue x to be treated as an rvaluem so that “move” versions of the operations run. What we did above is equivalent to DEFAULT behaviour</p>
</blockquote>



<h2 id="lecture-18">Lecture 18</h2>



<pre class="prettyprint"><code class="language-cpp hljs ">Text t1 {...}, t2{...};
Book *pb1=&amp;t1, *pb2=&amp;t2;</code></pre>

<p>What if we do *pb1 = *pb2; <br>
Partial assignment - copies only the Book part. <br>
- only Book::operator= ran.</p>

<p>How can we fix this? Try making operator= virtual.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> Book &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book &amp;other){...}
};

<span class="hljs-keyword">class</span> Text:<span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Text &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Text &amp;other) override {...}
        <span class="hljs-comment">//this WONT WORK. Parameters don't match</span>
};

<span class="hljs-comment">//better</span>
<span class="hljs-keyword">class</span> Text:<span class="hljs-keyword">public</span> Book{
    ...
    <span class="hljs-keyword">public</span>:
        Text &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book &amp;other) override {...}
        <span class="hljs-comment">//Note: Different return types OK. (as long as you return a subtype by reference) but the parameter types must be the same or it's not an override and won't compile.</span>
};</code></pre>

<p>Params not matching =&gt; violates is-a <br>
<script type="math/tex" id="MathJax-Element-12">\therefore</script> Assignment of a book object to a text variable would be allowed</p>

<p>Allowed:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Text t{...};
Book b{...};
Text *pt=&amp;t;
Book *pb=&amp;b;
*pt=*pb; <span class="hljs-comment">//- uses a Book to assign a Text BAD (but it compiles).</span>

<span class="hljs-comment">//Also</span>
Comic c{...};
Comic *pc=&amp;c;
*pt=*pc; <span class="hljs-comment">// REALLY BAD, but compiles</span></code></pre>

<p>If operator= is non-virtual. -partial assignment through base class ptrs. <br>
If it is virtual, then the compiler allows mixed assignment</p>

<p>Recommendation - All superclasses should be ABSTRACT</p>

<p>Rewrite Book hierarchy: <br>
<img src="http://amyqiu.me/Notes/a4.png"></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> AbstractBook{
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> numPages;
    <span class="hljs-keyword">protected</span>: <span class="hljs-comment">//prevents assignments through base class  ptrs from compiling but still makes the implementation available to subclasses.</span>
        AbstractBook &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> AbstractBook &amp;other);
    <span class="hljs-keyword">public</span>:
        AbstractBook(...);
        <span class="hljs-keyword">virtual</span> ~AbstractBook()=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> NormalBook: <span class="hljs-keyword">public</span> AbstractBook{
    <span class="hljs-keyword">public</span>:
        NormalBook(...);
        ~NormalBook();
        NormalBook &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> NormalBook &amp;other){
            AbstractBook::<span class="hljs-keyword">operator</span>=(other);
            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        }
};
<span class="hljs-comment">//other classes - exercise</span></code></pre>

<p>-Operator= is not virtual therefore no mixed assignment</p>



<pre class="prettyprint"><code class="language-cpp hljs ">NormalBook n1{...}, n1{...}
Abstract *pa1 = &amp;n1, *pa2=&amp;n2;
*pa1 = *pa2 <span class="hljs-comment">//won't compile. AbstractBook::operator= here is protected so client can't call it. No partial assignment</span></code></pre>



<h3 id="factory-method-pattern">Factory Method Pattern</h3>

<p>-Write a video game with two kinds of enemies: turtles and bullets <br>
- system randomly sends turtles and bullets, but bullets become more frequent closer to the end <br>
UML <br>
<img src="http://amyqiu.me/Notes/a5.png"></p>

<p>Never know exactly which enemy comes next, so can’t call turtle/bullet ctors directly. <br>
Instead, put a <code>factory method</code> in level that creates enemies.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Level{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> Enemy *createEnemy()=<span class="hljs-number">0</span>;
        ...
};

<span class="hljs-keyword">class</span> NormalLevel: <span class="hljs-keyword">public</span> Level{
    <span class="hljs-keyword">public</span>:
        Enemy *createEnemy() override{
            <span class="hljs-comment">//create mostly turtles</span>
        }
};

<span class="hljs-keyword">class</span> castle: <span class="hljs-keyword">public</span> Level{
    <span class="hljs-keyword">public</span>:
        Enemy *createEnemy() override{
            <span class="hljs-comment">//mostly bullets</span>
        }
};

Level *l = <span class="hljs-keyword">new</span> NormalLevel;
Enemy *e = l-&gt;createEnemy();</code></pre>



<h3 id="template-method-pattern">Template Method Pattern</h3>

<p>Want subclasses to override superclass behaviour, but some aspects must stay the same.</p>

<p>E.g. There are red turtles + green turtles</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Turtle{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> draw(){
            drawHead();
            drawShell();
            drawFeet();
        }
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">void</span> drawHead();
        <span class="hljs-keyword">void</span> drawFeet();
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> drawShell()=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> RedTurtle:<span class="hljs-keyword">public</span> Turtle{
    <span class="hljs-keyword">void</span> drawShell()override{<span class="hljs-comment">/*draw red shell */</span>}
};

<span class="hljs-keyword">class</span> GreenTurtle: <span class="hljs-keyword">public</span> Turtle{
    <span class="hljs-keyword">void</span> drawShell()override{<span class="hljs-comment">/*draw green shell */</span>}
};</code></pre>

<p>subclasses can’t change what it means to draw a turtle (ie. head, then shell, then feet) <br>
but CAN change the way the shell is drawn</p>

<p>Extension: The Non-Virtual Interface (NVI) idiom. <br>
A public virtual method is really two things:</p>

<ul>
<li>an interface to the client <br>
-indicates provided behaviour, with pre/post conditions</li>
<li><p>an interface to subclasses <br>
-a”hook” to insert specialized behaviour <br>
Hard to separate these ideas if they are tied to the same f’n</p></li>
<li><p>What if you later want to separate the customizale behaviour into 2 f’ns with some unchanging code inbetween, while still providing clients the same interface?</p></li>
<li>how could you make sure overriding f’ns conform to the pre/post conditions</li>
</ul>

<p>The NVI idiom says: </p>

<ul>
<li>All public methods should be non-virtual. </li>
<li>All virtual methods should be private or AT LEAST protected.</li>
<li>except the dtor</li>
</ul>

<p>Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> DigitalMedia{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> play()=<span class="hljs-number">0</span>;
};

<span class="hljs-comment">//instead, do this:</span>
<span class="hljs-keyword">class</span> DigitalMedia{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> play(){doPlay();} <span class="hljs-comment">//can add before/after code. eg check copyright before. Update play count after.</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> doPlay()=<span class="hljs-number">0</span>;
};</code></pre>

<p>Extends Template Method <br>
-put every virtual method inside a template method</p>



<h3 id="stl-maps-for-creating-dictionaries">STL Maps - for creating Dictionaries</h3>

<p>E.g. “arrays” that map string to int</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span> &lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;</span>m;
m[<span class="hljs-string">"abc"</span>] = <span class="hljs-number">1</span>;
m[<span class="hljs-string">"def"</span>] = <span class="hljs-number">4</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; m[<span class="hljs-string">"ghi"</span>] &lt;&lt; endl; <span class="hljs-comment">//if key is not present, it is inserted and the value is default constructed (for ints, 0)</span>
m.erase(<span class="hljs-string">"abc"</span>);
<span class="hljs-keyword">if</span>(m.count(<span class="hljs-string">"def"</span>)) ... <span class="hljs-comment">//0 if found, 1 if not found</span></code></pre>



<h2 id="lecture-19">Lecture 19</h2>

<p>Recall: <code>&lt;map&gt;</code> <br>
<code>map&lt;string, int&gt; m;</code> <br>
Iterating over a map: sorted key order</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;p:m){
    <span class="hljs-built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; p.second &lt;&lt; endl;
}</code></pre>

<p>p’s type is <code>std::pair&lt;string,int&gt;&amp;</code> (<code>&lt;utility&gt;</code>)</p>



<h3 id="visitor-pattern">Visitor Pattern</h3>

<p>For implementation, <strong>double dispatch</strong> <br>
e.g <br>
<img> <br>
-effect depends on type of Enemy and type of weapon <br>
Want something like: virtual void(Enemy, Weapon)::strike(); which is impossible <br>
If we put this method in Enemy - choose based on enemy but not on the weapon. <br>
If we put it in weapon - choose based on weapon but not enemy.</p>

<p>To get dispatch based on both (double dispatch): <br>
-combine overriding with overloading</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Enemy{
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> beStruckBy(Weapon &amp;w)=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> Turtle: <span class="hljs-keyword">public</span> Enemy{
    <span class="hljs-keyword">void</span> beStruckBy(Weapon &amp;w) override{
        w.strike(*<span class="hljs-keyword">this</span>);
    }
};
<span class="hljs-keyword">class</span> Bullet:<span class="hljs-keyword">public</span> Enemy{
    <span class="hljs-keyword">void</span> beStruckBy(Weapon &amp;w) override{
        w.Strike(*<span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-keyword">class</span> Weapon{
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> strike(Turtle &amp;t)=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> strike(Bullet &amp;b)=<span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> Stick: <span class="hljs-keyword">public</span> Weapon{
    <span class="hljs-keyword">void</span> strike(Turtle &amp;t) override{
        <span class="hljs-comment">//strike Turtle with stick</span>
    }
    <span class="hljs-keyword">void</span> strike(Bullet &amp;b) override{
        <span class="hljs-comment">//bullet with stick</span>
    }
};

Enemy* e = <span class="hljs-keyword">new</span> Bullet{...};
Weapon*w = <span class="hljs-keyword">new</span> Rock{...};

e-&gt;beStruckBy(*w); <span class="hljs-comment">//what happens?</span>
<span class="hljs-comment">//virtual mthd of Enemy. Bullet::beStruckBy calls Weapon::strike</span>
<span class="hljs-comment">//chosen at compile-time - virtual</span>
<span class="hljs-comment">//resolves to Rock::Strike(Bullet &amp;) </span></code></pre>

<p>Visitor can be used to add functionality to existing classes, without changing or recompiling the classes themselves</p>

<p>Eg. add a visitor to the Book hierarchy:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Book{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> accept(BookVisitor &amp;v){v.visit(*<span class="hljs-keyword">this</span>);}
};

<span class="hljs-keyword">class</span> Text: <span class="hljs-keyword">public</span> Book{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">void</span> accept(Book Visitor &amp;v) override{
            v.visit(*<span class="hljs-keyword">this</span>);
        }
};

<span class="hljs-keyword">class</span> BookVisitor{
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> visit(Book &amp;b) = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> visit(Text&amp;b) = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> visit(Comic &amp;b) = <span class="hljs-number">0</span>;
};</code></pre>

<p>Application: <br>
Track how many of each type of book we have: <br>
Books - by author <br>
Texts - by topic <br>
Comics - by hero <br>
Use a <code>map &lt;string, int&gt;</code> <br>
Could add virtual updateMap (…) to each class or write a visitor</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> Catalogue: <span class="hljs-keyword">public</span> BookVisitor{
    <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;</span> theCatalogue;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;</span> getCatalogue(){<span class="hljs-keyword">return</span> theCatalogue;}
        <span class="hljs-keyword">void</span> visit(Book &amp;b) override{
            ++theCatalogue[b.getAuthor()];
        };
        <span class="hljs-keyword">void</span> visit(Text &amp;b) override{
            ++theCatalogue[b.getTopic()];
        };
        <span class="hljs-keyword">void</span> visit(Comic &amp;b) override{
            ++theCatalogue[b.getHero()];
        };
};</code></pre>

<p>but it won’t compile! why?</p>

<p>main -&gt; includes book - includes Book Visitor -&gt; inclodes both Text and Book <br>
-circular include dependency <br>
Text doesn’t know what Book is <br>
How many of these includes are really needed?</p>

<p>Compilation Dependencies - include vs forward declare</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Consider <span class="hljs-keyword">class</span> A{...};
<span class="hljs-comment">//B needs #includes A</span>
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
...
};
<span class="hljs-comment">//C needs #include A</span>
<span class="hljs-keyword">class</span> C{A my A;};
<span class="hljs-comment">//D doesn't need to know how big A is therefore doesn't need #include</span>
<span class="hljs-comment">//can get away with just `class A`;</span>
<span class="hljs-keyword">class</span> D{A *myAp;};
<span class="hljs-comment">//E needs #include A</span>
<span class="hljs-keyword">class</span> E{
    A f(A x)
};</code></pre>

<p>Don’t introduce unnecessary compilation dependencies with unneeded includes <br>
When A changes - only A,B,C need recompilation <br>
Now, in the implementations of D,E;</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//d.cc</span>
<span class="hljs-preprocessor">#include "A.h"</span>
<span class="hljs-keyword">void</span> D::f(){
    myAp-&gt;someMethod(); <span class="hljs-comment">//Need to know about class A here</span>
}</code></pre>

<p>Do the #include in the .cc file instead of the .h file. (will never get an include cycle because .cc is never included) where possible.</p>

<p>Now consider the XWindow class</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> XWindow{
    <span class="hljs-comment">//this is private data here. Yet we must look at it. Do we know what it means? Do we care?</span>
    Display *d;
    Window w;
    <span class="hljs-keyword">int</span> s;
    GC gc;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> colours[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">public</span>:
        ...
};</code></pre>

<p>If we add or change a private member, all clients must recompile. May be better to hide these details away.</p>

<p>Sol’n:</p>



<h3 id="pimpl-idiom-pointer-to-implementation">Pimpl idiom (“Pointer to implementation”)</h3>

<p>Create a second class XWindowImpl:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//XWindowImpl.h</span>
<span class="hljs-preprocessor">#include &lt;X11/Xlib.h&gt;</span>
<span class="hljs-keyword">struct</span> XWindowImpl{
    Display *d;
    window w;
    <span class="hljs-keyword">int</span> s;
    GC gc;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> colours[<span class="hljs-number">10</span>];
};

<span class="hljs-comment">//Window.h</span>
<span class="hljs-comment">//No need to include Xlib.h. Forward declare the impl. class</span>
<span class="hljs-keyword">class</span> XWindowImpl;
<span class="hljs-keyword">class</span> XWindow{
    XWindowImpl *pImpl;
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-comment">//no change</span>
};</code></pre>

<p>No compilation dependency on XWindowImpl. Clients also don’t depend on XWindowImpl.h</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Window.cc</span>
<span class="hljs-preprocessor">#include "window.h"</span>
<span class="hljs-preprocessor">#include "XWindowImpl.h"</span>
XWindow::XWindow(...): pImpl{newXWindowImpl{...}}{}</code></pre>

<p>Other methods: replace fields d,w,s, etc. <br>
with pImpl-&gt;d, pImpl-&gt;w etc</p>

<p>If all private fields are in XWindowImpl, then only window.cc needs recompiling if they change.</p>

<p>Generalization - Several possible window implementations <br>
e.g. XWindows YWindows - Then Impl struct could be a superclass <br>
<img src="http://amyqiu.me/Note/a7.png"></p>

<p>Bridge Pattern</p>



<h2 id="lecture-20">Lecture 20</h2>



<h3 id="measures-of-design-quality">Measures of Design Quality</h3>

<ul>
<li>coupling + cohesion</li>
</ul>

<dl>
<dt>coupling</dt>
<dd>the degree to which distinct program modules depend on each other</dd>

<dd>below: low to high coupling examples and degree.</dd>

<dd><strong>low</strong>: modules interact via function calls with basic params/results (lowest)</dd>

<dd><ul>
modules pass arrays/structs back + forth <br>
modules affect each other’s control flow (medium) <br>
modules share global data
</ul></dd>

<dd><strong>high</strong>: modules have access to each other’s implementation (friends) (highest)</dd>

<dt>cohesion</dt>
<dd>how closely elements of a module are related to each other</dd>

<dd><strong>low</strong>: arbitrary grouping of unrelated elements (eg <code>&lt;utility&gt;</code>)</dd>

<dd><ul>
elements share a common theme, otherwise unrelated - perhaps share some bas code  eg, <code>&lt;algorithm&gt;</code> <br>
elements manipulate state over the lifetime of an object (eg. open/read/close files) <br>
elements pass data to eachother
</ul></dd>

<dd><strong>high</strong>: elements cooperate to perform exactly one task</dd>
</dl>

<p>High coupling: changes to one module require greater changes to other modules. <br>
- harder to reuse individual modules <br>
Low cohesion: poorly organized code. Hard to understand/maintain.</p>

<p>Goal: low coupling, high cohesion</p>



<h3 id="decoupling-the-interface-mvc">Decoupling the Interface (MVC)</h3>

<p>Your primary program classes should not be printing things <br>
Eg.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> ChessBoard{
    ...
    cou &lt;&lt; <span class="hljs-string">"Your move"</span> &lt;&lt; endl;
};</code></pre>

<p>Bad design - inhibits code reuse <br>
What if you want to reuse ChessBoard, but not have it communicate via stdout?</p>

<p>One solution: give the class stream objects where it can send it’s input/output</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> ChessBoard{
    <span class="hljs-built_in">std</span>::istream &amp;in;
    <span class="hljs-built_in">std</span>::ostream &amp;out;
    <span class="hljs-keyword">public</span>:
        ChessBoard(<span class="hljs-built_in">std</span>::istream &amp;in, <span class="hljs-built_in">std</span>::ostream &amp;out): in{in}, out{out} {...}
        ...
        out &lt;&lt; <span class="hljs-string">"Your move"</span> &lt;&lt;endl;
};</code></pre>

<p>Better - but what if we don’t want to use streams at all? Your chessboard class should not be doing any communication at all.</p>



<h3 id="single-responsibility-principle">Single Responsibility Principle</h3>

<p>“A class should have only one reason to change.”</p>

<ul>
<li>game state + communication are TWO reasons</li>
</ul>

<p>Better - Communicate with the chessboard via params/results</p>

<ul>
<li>confine user communication to outside the class</li>
</ul>

<p>Q: Should main do all of the communication and then call chessboard methods? <br>
A: No - hard to reuse code if it’s in main. Should have a class to manage interaction that is separate from the game state class.</p>



<h3 id="pattern-model-view-controller-mvc">Pattern: Model-View-Controller (MVC)</h3>

<p>Separate the distinct notions of the data (state), its presentation, and the control of the data. <br>
Model: the data (game state) <br>
View: how the model is displayed <br>
Controller: how the model is manipulated <br>
<img src="http://amyqiu.me/Notes/a8.png"> <br>
Model : </p>

<ul>
<li>can have multiple views (e.g. text + graphics)</li>
<li>doesn’t need to know their details</li>
<li>classic observer pattern (or communicate through controller)</li>
</ul>

<p>Controller </p>

<ul>
<li>mediates control flow through model + view</li>
<li>may encapsulate turn-taking, or full game rules</li>
<li>may fetch input from user (or this could be the view)</li>
</ul>

<p>By decoupling presentation + control, MVC promotes reuse</p>



<h3 id="exception-safety">Exception Safety</h3>

<p>Consider:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    MyClass *p = <span class="hljs-keyword">new</span> MyClass;
    MyClass mc;
    g();
    <span class="hljs-keyword">delete</span> p;
}</code></pre>

<p>No leaks - but what if g raises an exception?  <br>
What is guaranteed </p>

<ul>
<li>During stack unwinding, all stack allocated data is cleaned up - dtors run, memory reclaimed</li>
<li>so mc is cleaned up</li>
<li>heap-allocated memory is not freed</li>
</ul>

<p>So if g throws, p is leaked.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    MyClass *p = <span class="hljs-keyword">new</span> MyClass;
    MyClass mc;
    <span class="hljs-keyword">try</span> {
        g();
    }
    <span class="hljs-keyword">catch</span>(..){
        <span class="hljs-keyword">delete</span> p;
        <span class="hljs-keyword">throw</span>;
    }
    <span class="hljs-keyword">delete</span> p;
}</code></pre>

<p>This is tedious, error-prone and code duplication <br>
How else can we guarantee that something like <code>delete p</code> will happen no matter how we exit f? (normally or exn?)</p>

<p>In some languages - “finally” clauses that guarantee final actions - not in c++ <br>
Only thing you can count on in C++ <br>
- dtors for stack-allocated data will run <br>
Use stack-allocated data with dtors as much as possible <br>
Use this guarantee to your advantage</p>



<h3 id="c-idiom-raii-resource-acquisition-is-initialization-might-appear-on-final-exam-what-does-it-stand-for">C++ idiom : RAII - Resource Acquisition Is Initialization (**Might appear on final exam. What does it stand for?)</h3>

<p>Every resources should be wrapped in a stack-allocated object whose dtor frees it.</p>

<p>E.g. files:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">ifstream f{<span class="hljs-string">"name"</span>}; <span class="hljs-comment">//Acquiring the resource ("name") = initializing the object (f). File is guaranteed to be freed when f is popped from the stack because f's dtor runs.</span></code></pre>

<p>This can be done with dynamic memory</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> <span class="hljs-built_in">std</span>::unique_ptr&lt;T&gt;
<span class="hljs-comment">//- Takes a T* in the ctor</span>
<span class="hljs-comment">//- The dtor will delete the ptr.</span></code></pre>

<p>A better f()</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;();
    <span class="hljs-comment">// instead of auto, could also type, std::unique_ptr&lt;MyClass&gt;</span>
    <span class="hljs-comment">// ctor arges for myClass in ();</span>
    MyClass mc;
    g();
    <span class="hljs-comment">//no leaks, guaranteed</span>
};</code></pre>

<p>Get 4/10 bonus marks if your program doesn’t leak and doesn’t call delete</p>



<h2 id="lecture-21">Lecture 21</h2>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-keyword">auto</span> p=<span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;();
    MyClass mc;
    g();
    <span class="hljs-comment">//No leaks</span>
}</code></pre>

<p>Difficulty:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> c {...};
unique_ptr&lt;C&gt; p {<span class="hljs-keyword">new</span> C{...}};
unique_ptr&lt;C&gt; q=p; <span class="hljs-comment">//what happens here? when q/p is popped, may delete something twice :'(. X</span></code></pre>

<p>What happens when a unique_ptr is copied - don’t want to delete the same ptr twice! <br>
Instead - copying is disabled for unique_ptrs <br>
They can only be moved.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Sample implementation (repository)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> unique_ptr{
    T *ptr;
    <span class="hljs-keyword">public</span>:
        unique_ptr(T *p): ptr{p}{}
        ~unique_ptr() {<span class="hljs-keyword">delete</span> ptr;}
        unique_ptr(<span class="hljs-keyword">const</span> unique_ptr&lt;T&gt; &amp;other)=<span class="hljs-keyword">delete</span>;
        unique_ptr&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> unique_ptr&lt;T&gt; &amp;other)=<span class="hljs-keyword">delete</span>;
        unique_ptr(unique_ptr&lt;T&gt;&amp;&amp;other):ptr{other.ptr}{other.ptr=<span class="hljs-keyword">nullptr</span>;}
        unique_ptr&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(unique_ptr&lt;T&gt;&amp;&amp;other){
            <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
            swap(ptr, other.ptr);
            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        }       
        T &amp;<span class="hljs-keyword">operator</span>*(){<span class="hljs-keyword">return</span> *ptr;}
};</code></pre>

<p>If you need to copy ptrs + can’t distinguish an owner - std::shared_ptr</p>



<pre class="prettyprint"><code class="language-cpp hljs ">{<span class="hljs-keyword">auto</span> p1=<span class="hljs-built_in">std</span>::make_shared&lt;MyClass&gt; ();
<span class="hljs-keyword">if</span>(...){
    <span class="hljs-keyword">auto</span> p2=p1;
} <span class="hljs-comment">//p2 is popped, ptr is not deleted</span>
}<span class="hljs-comment">//p1 is popped, ptr is deleted</span></code></pre>

<p>Shared ptrs maintain a reference count</p>

<ul>
<li>count of all shared_ptrs pointing at the same object</li>
<li>Memory is freed when the ref count hits 0</li>
</ul>



<pre class="prettyprint"><code class="language-scheme hljs clojure"><span class="hljs-list">(<span class="hljs-title">define</span> l1<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 1</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 2</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 3</span> empty)</span>)</span>)</span>)</span>
<span class="hljs-list">(<span class="hljs-title">define</span> l2<span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">cons</span></span><span class="hljs-number"> 4</span> <span class="hljs-list">(<span class="hljs-title"><span class="hljs-built_in">rest</span></span> l1)</span>)</span>)</span></code></pre>

<p>Use shared + unique ptrs as much as possible <br>
Dramatically fewer opportunities for leaks <br>
NEVER let the dtor emit an exception <br>
- if the dtor was executed during stack unwinding while dealing with another exn, you now have TWO active, unhandled exns and the program will abort immediately <br>
3 levels of exception safety for a f’n f: <br>
1. Basic guarantee - if an exn occurs, the program will be in a valid state. Nothing leaked, nothing corrupted, class invariants maintained <br>
2. Strong guarantee - if an exn is raised while executing f, the state of the program will be as it was before f was called. <br>
3. No-throw guarantee - f will never throw an ex’n and will always accomplish its task.</p>

<p>Example:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> A{...};
<span class="hljs-keyword">class</span> B{...};
<span class="hljs-keyword">class</span> C{
    A a;
    B b;
    <span class="hljs-keyword">void</span> f(){
        a.method1();<span class="hljs-comment">//may throw (strong guarantee)</span>
        b.method2();<span class="hljs-comment">//may throw (strong guarantee)</span>
    }
};</code></pre>

<p>Is C::f exn safe?. <br>
- if a.method1 throws, nothing has happened yet. OK <br>
- if b.method2 throws, effects of method1 would have to be undone to offer the strong guarantee. Very hard or impossible if method 1 has non-local side effects. <br>
- So no, probably not exn safe. <br>
If A’s method1 and B’s method2 do NOT have non-local side effects, can use COPY + SWAP.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> C{
    ...
    <span class="hljs-keyword">void</span> f(){
        A atemp=a; <span class="hljs-comment">// if these throws, f throws. Original A and B are still intact.</span>
        B btemp=b;
        atemp.method1();
        btemp.method2();
        a=atemp;
        b=btemp;
        <span class="hljs-comment">//If these throw, f throws, but original a + b still intact. HOWEVER, what if copy assignment throws?</span>
    }
};</code></pre>

<p>Better if the swap was nothrow. Copying ptrs can’t throw <br>
Sol’n. Use the pImpl idiom: </p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> CImpl{
    A a;
    B b;
};

<span class="hljs-keyword">class</span> C{
    unique_ptr&lt;CImpl&gt; pImpl;
    ...
    <span class="hljs-keyword">void</span> f(){
        <span class="hljs-keyword">auto</span> temp = make_unique&lt;CImpl&gt;(*pImpl);
        temp-&gt;a.method1();
        temp-&gt;b.method2();
        <span class="hljs-built_in">std</span>::swap(pImpl. temp); <span class="hljs-comment">//no-throw</span>
    }
};</code></pre>

<p>If either A::method1 or B::method2 offer no exn safety guarantee, then neither can f.</p>



<h3 id="exn-safety-the-stl-vectors">Exn Safety + the STL: vectors</h3>

<p>Vectors - encapsulate a heap-allocated array <br>
-follow RAII - when a stack-allocated vector goes out of scope, the internal heap-allocated array is freed</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(){
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;MyClass&gt;</span> v;
    ...
} <span class="hljs-comment">//v goes out of scope - array is freed, MyClass dtor runs on all objects in the vector.</span></code></pre>

<p>But:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> g(){
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;MyClass *&gt;</span> v;
    ...
}<span class="hljs-comment">//array is freed but pointers don't have dtors so any objects pointed to by the pointers are not deleted (potential to leak)</span></code></pre>

<ul>
<li>v doesn’t know whether the pointers in the array own the objs they point at</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) <span class="hljs-keyword">delete</span> x;</code></pre>

<p>But:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> h(){
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;</span>&gt; v;
    ...
    <span class="hljs-comment">//array is freed, shared_ptr dtors run. So the objs ARE deleted if no other shared ptr points at them. NO explicit deallocation.</span>
}</code></pre>



<h2 id="lecture-22">Lecture 22</h2>



<h3 id="exception-safety-the-stl-continued">Exception Safety + the STL continued</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>::emplace_back</code></pre>

<ul>
<li>offers the strong guarantee</li>
<li>if the array is full (ie size = cap) <br>
<ul><li>allocate new array</li>
<li>copy objects over (copy ctor) <br>
<ul><li>if a copy ctor throws: destroy the new array. The old array is still intact. Strong guarantee</li></ul></li>
<li>delete old array</li></ul></li>
</ul>

<p>But:</p>

<ul>
<li>copying is expensive + the old data will be thrown away</li>
<li>wouldn’t moving the objs be more efficient? <br>
<ul><li>allocate new array</li>
<li>move objs over (move ctor). HOWEVER, if move ctor throws, can’t offer the strong guarantee. Original no longer intact.</li>
<li>delete old array</li></ul></li>
</ul>

<p>BUT: <br>
If the move ctor offers the nothrow guarantee, emplace_back will use the move ctor; else it will use the copy ctor, which is slower. So your move ops should provide the no-throw guarantee, and you should indicate that they do:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> MyClass{
    <span class="hljs-keyword">public</span>:
        MyClass(MyClass &amp;other) <span class="hljs-keyword">noexcept</span>{...}
        MyClass &amp;<span class="hljs-keyword">operator</span>=(MyClass &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;
};</code></pre>

<p>If you know a function will never throw or propagate an exception, declare it noexcept. This facilitates optimization.</p>

<p>At minimum: moves + swaps should be noexcept</p>



<h3 id="casting">Casting</h3>

<p>In C:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Node n;
<span class="hljs-keyword">int</span> *ip=(<span class="hljs-keyword">int</span> *) &amp;n; <span class="hljs-comment">//cast - forces c++ to treat a Node * as an int*</span></code></pre>

<p>C-style casts should be avoided in C++ <br>
If you must cast, use a C++-style cast:</p>

<p>4 Kinds:</p>



<h4 id="staticcast-sensible-casts">static_cast - “sensible” casts</h4>

<ul>
<li>Eg: double-&gt;int: </li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> i);
<span class="hljs-keyword">void</span> f(<span class="hljs-keyword">double</span> d);
f(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(d));</code></pre>

<ul>
<li><code>superclass ptr-&gt;subclass ptr</code></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *b = <span class="hljs-keyword">new</span> Text{...};
Text *t = <span class="hljs-keyword">static_cast</span>&lt;Text *&gt;(b);</code></pre>

<ul>
<li>you are taking responsibility that b actually points at a Text. “Trust me.”</li>
</ul>



<h4 id="reinterpretcast-unsafe-implementation-specific-weird-casts">reinterpret_cast - Unsafe, implementation-specific, “weird” casts.</h4>



<pre class="prettyprint"><code class="language-cpp hljs ">Student s;
Turtle *t = <span class="hljs-keyword">reinterpret_cast</span>&lt;Turtle *&gt; (&amp;s);</code></pre>



<h4 id="constcast-for-converting-between-const-non-const">const_cast - For converting between const + non-const</h4>

<p>The only C++ cast that can cast away const</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//Won't compile if you just call g(p) since g doesn't guarantee p stays the same</span>
<span class="hljs-keyword">void</span> g(<span class="hljs-keyword">int</span> *p); <span class="hljs-comment">//given to you</span>
<span class="hljs-keyword">void</span> f(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p){ <span class="hljs-comment">// say you know that g will not modify *p - just not reflected in g's signature</span>
    ...
    g(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> *&gt;(p));
    ...
}</code></pre>



<h4 id="dynamiccast-is-it-safe-to-convert-a-book-to-a-text">dynamic_cast - Is it safe to convert a Book * to a Text * ?</h4>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *pb;
...
<span class="hljs-keyword">static_cast</span>&lt;Text *&gt; (pb)-&gt;getTopic(); <span class="hljs-comment">//safe? depends</span></code></pre>

<p>Depends on what pb actually points at. Better to do a tentative cast - try it + see if it succeeds.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">Book *pb = ...;
Text *pt = <span class="hljs-keyword">dynamic_cast</span> &lt;Text *&gt; (pb);</code></pre>

<p>If the cast works (pb REALLY points at a Text, or at a subclass of Text), now pt points at that object. <br>
If the cast fails - pt will be nullptr</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">if</span>(pt) <span class="hljs-built_in">cout</span> &lt;&lt; pt-&gt;getTopic();
<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not a text"</span>;</code></pre>

<p>Should be using smart ptrs - can we do the same on them? <br>
Yes - <code>static_pointer_cast</code>, <code>const_pointer_cast</code>, <code>dynamic_pointer_cast</code> <br>
Cast shared_ptrs to shared_ptrs <br>
can use dynamic casting to make decisions based on an object’s RTTI(run time type information)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> whatIsIt(<span class="hljs-built_in">shared_ptr</span>&lt;Book&gt; b){
    <span class="hljs-keyword">if</span>(dynamic_pointer_cast &lt;Comic&gt;(b)) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Comic"</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dynamic_pointer_cast &lt;Text&gt;(b)) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Text"</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Normal Book"</span>;
}</code></pre>

<p>Code like this is highly coupled to the book class hierarchy and may indicate bad design. Better - use virtual methods or write a visitor.</p>

<blockquote>
  <p>Note: dynamic casting only works on classes with at least one virtual method</p>
</blockquote>



<h2 id="lecture-23">Lecture 23</h2>

<p></p>

<p>The one I missed. Uhhh refer to pdf.</p>

<h2 id="lecture-24">Lecture 24</h2>

<p><img src="http://amyqiu.me/Notes/a9.png"> <br>
Distance to base class not always the same!</p>

<ul>
<li>location of superclass is stored in the vtable</li>
</ul>

<p>Diagram doesn’t look like A,BmCmD simultaneously - but slices of it do look like A,B,C,D</p>



<pre class="prettyprint"><code class="language-cpp hljs ">D d;
A*a = &amp;d;<span class="hljs-comment">//shifts the address</span></code></pre>

<p>Therefore ptr assignment among A,B,C,D changes the address stored in the ptr.</p>

<ul>
<li>static/const/dynamic cast under multi-inheritance also chang the value of the ptr.</li>
<li>reinterpret_cast will not</li>
</ul>



<h3 id="template-functions">Template Functions</h3>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T min(T x, T y){
    <span class="hljs-keyword">return</span> x&lt;y? x: y;
}

<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span> z=min(x,y); <span class="hljs-comment">//T=int - Don't need to say min&lt;int&gt; because C++ can infer that T=int from the types of X and Y (Does not apply to template classes)</span></code></pre>

<p>If C++ cannot determine T, you can tell it: <code>min&lt;int&gt;(x,y);</code></p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">char</span> w = min (<span class="hljs-string">'a'</span>,<span class="hljs-string">'c'</span>); <span class="hljs-comment">//T = char</span>
<span class="hljs-keyword">auto</span> f = min(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>); <span class="hljs-comment">//T= float</span></code></pre>

<p>for what types T can min be used?</p>

<ul>
<li>For what types T will the body compile?</li>
<li>any type for which operator &lt; is defined</li>
</ul>

<p>Recall:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> for_each(AbstractIterator start, AbstractIterator finish, <span class="hljs-keyword">int</span>(*f)(<span class="hljs-keyword">int</span>)){
    <span class="hljs-keyword">while</span>(start!=finish){
        f(* start);
        ++start;
    }
}</code></pre>

<p>Works as long as AbstractIterator supports !=, *, ++ <br>
f can be called as a f’n <br>
Make these template arguments:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter, <span class="hljs-keyword">typename</span> Func&gt;
    <span class="hljs-keyword">void</span> for_each(Iter start, Iter finish, Func f){
        <span class="hljs-keyword">while</span>(start!= finish){
            f(*start);
            ++start;
        }
    }</code></pre>

<p>Now Iter can by ANY type supporting !=, *, ++ (including raw pointers)</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> n){<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; endl;}
<span class="hljs-keyword">int</span> a[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
for_each(a, a+<span class="hljs-number">5</span>, f); <span class="hljs-comment">//- prints the array</span></code></pre>



<h3 id="stl-algorithm-library">STL <code>&lt;algorithm&gt;</code> library</h3>

<ul>
<li>a suite of template functions, many of which work over iterators</li>
<li>Examples: for_each (as given above)</li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter, <span class="hljs-keyword">typename</span> T&gt;
    Iter find(Iter first, Iter last, <span class="hljs-keyword">const</span> T &amp;val){
        <span class="hljs-comment">// returns iterator to first item in [first, last) matching T.</span>
        <span class="hljs-comment">//or last, if not found;</span>
    }</code></pre>

<p>count - like find, but returns # of occurrences of val</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter&gt;
    OutIter copy(InIter first, InIter last, OutIter result){
        <span class="hljs-comment">// copies one container range [first, last)</span>
        <span class="hljs-comment">//to another, starting at result</span>
    }

<span class="hljs-comment">// Note: does not allocate new memory</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> w(<span class="hljs-number">4</span>); <span class="hljs-comment">//space for 4 ints</span>
copy(v.begin()+<span class="hljs-number">1</span>, v.begin()+<span class="hljs-number">5</span>, w.begin());
<span class="hljs-comment">//w = {2,3,4,5}</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter, <span class="hljs-keyword">typename</span> Func&gt;
    OutIter transform(InIter first, InIter last, OutIter result, Func f){
        <span class="hljs-keyword">while</span>(first != last){
            *result = f(*first);
            ++first;
            ++result;
        }
        <span class="hljs-keyword">return</span> result;
    }</code></pre>

<p>Eg:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> add1(<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;}
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> w(v.size());
transform(v.begin(),v.end(),w.begin(), addI);
<span class="hljs-comment">// w={3,4,6,8,12}</span></code></pre>

<p>How general is this code? <br>
1. what can we use for Func? <br>
2. what can we use for InIter/OutIter?</p>

<ol>
<li>Func: How is f used? f(*first) <br>
<ul><li>f can be anything that can be called as a f’n</li>
<li>Can write operator() for objects</li>
<li>eg: <code>class Plus1{public: int operator()(int n){return n+1;}};</code></li>
<li><code>Plus1 p;</code></li>
<li><code>p(4); //produces 5</code></li></ul></li>
</ol>



<pre class="prettyprint"><code class="language-cpp hljs ">transform(v.begin(), v.end(), w.begin(), Plus1());

<span class="hljs-comment">//Generalize:</span>
<span class="hljs-keyword">class</span> Plus{
    <span class="hljs-keyword">int</span> m;
    <span class="hljs-keyword">public</span>:
        Plus(<span class="hljs-keyword">int</span> m): m{m}{}
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> n) {<span class="hljs-keyword">return</span> n+m;}
};

transform(v.begin(), v.end(), w.begin(), Plus{<span class="hljs-number">1</span>});</code></pre>

<p>Plus1, Plus - called function objects <br>
Advantage of f’n objects - can maintain state</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> IncreasingPlus{
    <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n+(m++);}
        <span class="hljs-keyword">void</span> reset() {m=<span class="hljs-number">0</span>;}
};

<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> w(v.size());
transform(v.begin(), v.end(),w.begin(), IncreasingPlus());
<span class="hljs-comment">// w = {0, 1, 2, 3, 4}</span></code></pre>

<p>Consider: How many ints in vector v are even?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v {...};
<span class="hljs-keyword">bool</span> even(<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;}
<span class="hljs-keyword">int</span> x=count_if(v.begin(),v.end(), even);</code></pre>

<p>Seems a waste to explicitly create the f’n even. If this were Racket, we’d use lambda. <br>
Do the same here:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> x=count_if(v.begin(),v.end(),[](<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;});
<span class="hljs-keyword">auto</span> even = [](<span class="hljs-keyword">int</span> n){<span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;}

<span class="hljs-keyword">int</span> f(<span class="hljs-keyword">decltype</span>(even)){...} <span class="hljs-comment">//whatever even's type is</span></code></pre>

<p>2 - Iterators - <br>
Apply the notion of iteration to other data sources. eg. streams</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iterator&gt;</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;</span>v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
ostream_iterator &lt;<span class="hljs-keyword">int</span>&gt; out {<span class="hljs-built_in">cout</span>, <span class="hljs-string">","</span>};
copy(v.begin(),v.end(),out); <span class="hljs-comment">//prints 1,2,3,4,5,</span>

<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>w;
copy(v.begin(),v.end(),w.begin()); <span class="hljs-comment">//X won't work. Seg fault</span></code></pre>

<p>Remember - copy doesn’t allocate space in w. It can’t - it doesn’t even know that w’s iterating over a vector!</p>

<p>But what if we had an iterator whose assignment operator inserts a new item?</p>



<pre class="prettyprint"><code class="language-cpp hljs ">copy(v.begin(), v.end(), back_inserter(w));</code></pre>

<p>copies v to w, allocates space if necessary</p>

<p>The end.</p></body>
</html>
-->